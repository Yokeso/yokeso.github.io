<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yokeso</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yokeso.github.io/"/>
  <updated>2023-07-26T11:08:44.054Z</updated>
  <id>http://yokeso.github.io/</id>
  
  <author>
    <name>BigtreeLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核设计与实现ch14  块IO层</title>
    <link href="http://yokeso.github.io/2023/07/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch14/"/>
    <id>http://yokeso.github.io/2023/07/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch14/</id>
    <published>2023-07-20T07:11:22.000Z</published>
    <updated>2023-07-26T11:08:44.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核设计与实现第十四章—块I-O层"><a href="#Linux内核设计与实现第十四章—块I-O层" class="headerlink" title="Linux内核设计与实现第十四章—块I/O层"></a>Linux内核设计与实现第十四章—块I/O层</h1><p>块设备是系统中能够随机访问固定大小数据片的硬件设备，所以这些固定大小的数据片就称为块。最常见的块设备是硬盘，其余闪存，光驱等也均为块设备。在内核中，这些块设备都是以安装文件系统的方式使用的。</p><p>与块设备相对应的设备类型是字符设备。字符设备会按照字节流的方式被有序访问（例如串口或者键盘这样的设备）。也就是说字符设备和块设备之间的最主要区别就是——数据是否可以被随机访问。</p><p>对于内核来讲，对于块设备的管理要比对于字符设备的管理细致的多。因为块设备中要考虑的问题比字符设备更多。字符设备只需要控制当前位置的数据，而块设备上的位置需要在介质的区间中不停移动。更重要的是，块设备普遍来说对执行性能的要求很高。对硬盘的每多一份利用都会对整个系统带来性能上的提升。所以内核给块设备提供了专门提供服务的子系统。而这一章讲述的就是内核如何对块设备和块设备的请求进行管理。</p><span id="more"></span><h3 id="14-1-刨析一个块设备"><a href="#14-1-刨析一个块设备" class="headerlink" title="14.1 刨析一个块设备"></a>14.1 刨析一个块设备</h3><p>块设备中最小的可寻址单元是扇区，其大小一般为2的整数倍，最常见的是512字节。扇区的大小是设备的物理属性，扇区是所有块设备的基本单元——块设备无法对比它还小的单元进行寻址和操作，但很多块设备可以一次对多个扇区进行操作。</p><p>由于内核执行的所有磁盘操作都是按照块进行访问的，所以块概念不能比扇区还要小，通常是倍数于扇区大小。并且块大小要是扇区大小的二的整数倍。所以通常来说块定义为512字节，1KB或者4KBDD</p><h3 id="14-2-缓冲区和缓冲头"><a href="#14-2-缓冲区和缓冲头" class="headerlink" title="14.2 缓冲区和缓冲头"></a>14.2 缓冲区和缓冲头</h3><p>当一个块被调入内存时，它要存储在一个缓冲区中。每个缓冲区与一个块对应，相当于是磁盘块在内存中的表示。块包含了一个或多个扇区，但是不能超过页大小。由于内核在处理数据时需要一些相关的控制信息（块属于哪个块设备、块属于哪个缓冲区等），所以每个缓冲区都要有一个对应的描述符<code>buffer_head</code>来表示。该缓冲区在<code>&lt;linux/buffer_head.h&gt;</code>中定义，描述了磁盘块到物理内存缓冲区之间的映射关系。</p><blockquote><p>在2.6内核之前，缓冲头是一个更重要的多的数据结构。除了描述了磁盘块到物理内存的映射之外，还作为所有块I/O操作的容器存在。但是这样就使得这个结构体的大小很大，而且操作起来不清晰也不方便。并且会导致效率低下。所以从2.6内核开始，为块IO引入了一种新型，灵活且轻量的容器。这个我们再后面一节再介绍</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> b_state;          <span class="comment">/* buffer state bitmap (see above) */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span><span class="comment">/* circular list of page&#x27;s buffers */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span>            <span class="comment">/* the page this bh is mapped to */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">sector_t</span> b_blocknr;             <span class="comment">/* start block number */</span></span><br><span class="line">        <span class="keyword">size_t</span> b_size;                  <span class="comment">/* size of mapping */</span></span><br><span class="line">        <span class="keyword">char</span> *b_data;                   <span class="comment">/* pointer to data within the page */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span></span><br><span class="line">        <span class="keyword">bh_end_io_t</span> *b_end_io;          <span class="comment">/* I/O completion */</span></span><br><span class="line">        <span class="keyword">void</span> *b_private;                <span class="comment">/* reserved for b_end_io */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span> <span class="comment">/* associated with another mapping */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span>      <span class="comment">/* mapping this buffer is</span></span><br><span class="line"><span class="comment">                                                   associated with */</span></span><br><span class="line">        <span class="keyword">atomic_t</span> b_count;               <span class="comment">/* users using this buffer_head */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>b_state</code>是多种标志的组合，合法的标志存放在一个名为<code>bh_state_bits</code>的枚举中，该枚举同样在该文件中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bh_state_bits</span> &#123;</span></span><br><span class="line">        BH_Uptodate,    <span class="comment">/* Contains valid data */</span></span><br><span class="line">        BH_Dirty,       <span class="comment">/* Is dirty */</span></span><br><span class="line">        BH_Lock,        <span class="comment">/* Is locked */</span></span><br><span class="line">        BH_Req,         <span class="comment">/* Has been submitted for I/O */</span></span><br><span class="line">        BH_Uptodate_Lock,<span class="comment">/* Used by the first bh in a page, to serialise</span></span><br><span class="line"><span class="comment">                          * IO completion of other buffers in the page</span></span><br><span class="line"><span class="comment">                          */</span></span><br><span class="line"></span><br><span class="line">        BH_Mapped,      <span class="comment">/* Has a disk mapping */</span></span><br><span class="line">        BH_New,         <span class="comment">/* Disk mapping was newly created by get_block */</span></span><br><span class="line">        BH_Async_Read,  <span class="comment">/* Is under end_buffer_async_read I/O */</span></span><br><span class="line">        BH_Async_Write, <span class="comment">/* Is under end_buffer_async_write I/O */</span></span><br><span class="line">        BH_Delay,       <span class="comment">/* Buffer is not yet allocated on disk */</span></span><br><span class="line">        BH_Boundary,    <span class="comment">/* Block is followed by a discontiguity */</span></span><br><span class="line">        BH_Write_EIO,   <span class="comment">/* I/O error on write */</span></span><br><span class="line">        BH_Unwritten,   <span class="comment">/* Buffer is allocated on disk but not written */</span></span><br><span class="line">        BH_Quiet,       <span class="comment">/* Buffer Error Prinks to be quiet */</span></span><br><span class="line">        BH_Meta,        <span class="comment">/* Buffer contains metadata */</span></span><br><span class="line">        BH_Prio,        <span class="comment">/* Buffer should be submitted with REQ_PRIO */</span></span><br><span class="line">        BH_Defer_Completion, <span class="comment">/* Defer AIO completion to workqueue */</span></span><br><span class="line"></span><br><span class="line">        BH_PrivateStart,<span class="comment">/* not a state bit, but the first bit available</span></span><br><span class="line"><span class="comment">                         * for private allocation by other entities</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>BH_PrivateStart</code>，该标志不是状态标志。而是用来指明可被其他代码使用的起始位。块I/O层不会使用<code>BH_PrivateStart</code>或者更高位，那么当驱动程序希望通过<code>b_state</code>域存储信息时就可以安全使用这些位进行状态自定义。只要保证自定义的标志状态不和块IO层的专用位起冲突就可以了。</p><p><code>b_count</code>域代表缓冲区的使用用户计数，通过内联函数进行增减。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_bh</span><span class="params">(struct buffer_head *bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        atomic_inc(&amp;bh-&gt;b_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_bh</span><span class="params">(struct buffer_head *bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        smp_mb__before_atomic();</span><br><span class="line">        atomic_dec(&amp;bh-&gt;b_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要注意的是，在操作缓冲区头之前要先用<code>get_bh()</code>增加缓冲区头的引用计数，确保该缓冲区头不会再被分配出去；当完成对缓冲区头的操作之后，还需要用<code>put_bh()</code>减少引用计数。</p></blockquote><p><code>b_blocknr</code>用于索引与缓冲区相对应的物理块，其值是<code>b_bdev</code>域指明的块设备中的逻辑块号。缓冲区对应的物理页则用<code>b_page</code>域表示，而<code>b_data</code>则直接指向位于<code>b_page</code>域指明的页面上的对应的块。块的大小则由<code>b_size</code>来表示，起始位置在<code>b_data</code>处，结束位置在<code>b_data + b_size</code>处。</p><h3 id="14-3-bio结构体"><a href="#14-3-bio结构体" class="headerlink" title="14.3 bio结构体"></a>14.3 bio结构体</h3><p>内核中的块I/O操作的基本容器由bio结构体来表示，该结构体定义在文件<code>&lt;linux/blk_types.h&gt;</code>中（内核5.4）。代表了正在活动的以<code>segment</code>链表形式组织的块I/O操作。这里的一个<code>segment</code>是一小块连续的缓冲区。这样以来就可以通过<code>segment</code>来描述缓冲区，即使缓冲区分散在多个位置上，bio结构体也能对内核保证I/O操作的执行。从而保证了单个缓冲区不一定要连续。这样的I/O我们起了一个名称叫做<strong>聚散I/O</strong>。</p><p>由于本节中的bio结构体与2.6内核中的bio结构体变化较大，所以这节按照5.4内核来进行分析。下面给出bio结构体的各个域的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio</span>              *<span class="title">bi_next</span>;</span>       <span class="comment">/* request queue link */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span>          *<span class="title">bi_disk</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>            bi_opf;         <span class="comment">/* bottom bits req flags,</span></span><br><span class="line"><span class="comment">                                                 * top bits REQ_OP. Use</span></span><br><span class="line"><span class="comment">                                                 * accessors.</span></span><br><span class="line"><span class="comment">                                                 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>          bi_flags;       <span class="comment">/* status, etc and bvec pool number */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>          bi_ioprio;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>          bi_write_hint;</span><br><span class="line">        <span class="keyword">blk_status_t</span>            bi_status;</span><br><span class="line">        u8                      bi_partno;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span>        <span class="title">bi_iter</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">atomic_t</span>                __bi_remaining;</span><br><span class="line">        <span class="keyword">bio_end_io_t</span>            *bi_end_io;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>                    *bi_private;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Represents the association of the css and request_queue for the bio.</span></span><br><span class="line"><span class="comment">         * If a bio goes direct to device, it will not have a blkg as it will</span></span><br><span class="line"><span class="comment">         * not have a request_queue associated with it.  The reference is put</span></span><br><span class="line"><span class="comment">         * on release of the bio.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">blkcg_gq</span>         *<span class="title">bi_blkg</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio_issue</span>        <span class="title">bi_issue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_CGROUP_IOCOST</span></span><br><span class="line">        u64                     bi_iocost_cost;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span> <span class="comment">/* data integrity */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>          bi_vcnt;        <span class="comment">/* how many bio_vec&#x27;s */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Everything starting with bi_max_vecs will be preserved by bio_reset()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>          bi_max_vecs;    <span class="comment">/* max bvl_vecs we can hold */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">atomic_t</span>                __bi_cnt;       <span class="comment">/* pin count */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>          *<span class="title">bi_io_vec</span>;</span>     <span class="comment">/* the actual vec list */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio_set</span>          *<span class="title">bi_pool</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We can inline a number of vecs at the end of the bio, to avoid</span></span><br><span class="line"><span class="comment">         * double allocations for a small number of bio_vecs. This member</span></span><br><span class="line"><span class="comment">         * MUST obviously be kept at the very end of the bio.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>          <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bio结构体的目的是代表正在现场执行的io操作。所以结构体中的主要域都是管理相关信息的。这里面最重要的几个域是<code>bi_io_vec</code>、<code>bi_vcnt</code>以及<code>bi_idx</code>(这个位于<code>struct bvec_iter bi_iter</code>中)。<code>bi_io_vec</code>是现场执行的页的结构体链表，其总数为<code>bio_vcnt</code>。而<code>bi_idx</code>则指向了目前在用的页。</p><p><code>bi_io_vec</code>域指向一个结构体链表，该链表的每一个节点都是<code>bio_vec</code>结构体。该结构体的成员组成了一个<code>&lt;page, offset, len&gt;</code>的向量。在每个给定的块I/O操作中，和前面刚描述完的一样，<code>bio_vcnt</code>用来描述<code>bi_io_vec</code>所指向的<code>vio_vec</code>数组中的向量数目。而<code>bi_idx</code>指向数组的当前索引。</p><p>块I/O层可以通过跟踪<code>bi_idx</code>来了解I/O操作的完成进度。但该域更重要的作用是用于分割bio结构体，例如RAID可以将单独的bio结构体分割到RAID阵列上的各个硬盘中去。RAID驱动只需要拷贝这个bio结构体，然后将<code>bi_idx</code>域设置为每个独立硬盘操作时需要的位置就可以了。</p><p><code>bi_cnt</code>域记录了bio结构体的使用计数，如果其值减为0，则bio结构体将会被撤销并进行内存释放。这个域通过以下两个函数来进行管理：前者增加使用计数，后者减少使用计数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_get</span><span class="params">(struct bio *bio)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_put</span><span class="params">(struct bio *bio)</span></span>;</span><br></pre></td></tr></table></figure><p>还有一个需要注意的域是<code>bi_private</code>域。该域为创建者所属的私有域。只有创建了bio结构的拥有者可以对该域进行读写。</p><h3 id="14-4-请求队列"><a href="#14-4-请求队列" class="headerlink" title="14.4 请求队列"></a>14.4 请求队列</h3><p>块设备将他们挂起的块I/O请求保存在请求队列中，该队列由<code>reques_queue</code>来表示，定义在文件<code>&lt;linux/blkdev.h&gt;</code>中。包含了一个双向链表及其相关的控制信息。通过内核中的文件系统这样的高层代码添加到请求队列中。只要队列不为空，队列对应的块设备驱动就会从队列头获取请求，然后将其送入对应的块设备上去。请求队列表中的每一项都是一个单独的请求，由<code>request</code>结构体来表示。</p><p><code>request</code>结构体定义在<code>&lt;linux/blkdev.h&gt;</code>中，由于一个请求可能要设计操作多个连续的盘块，所以每个请求可以由多个bio结构体组成。虽然磁盘上的块必须连续，但是在内存中这些块并不一定要连续——每个bio结构体都可以描述多个片段。</p><h3 id="14-5-I-O调度程序"><a href="#14-5-I-O调度程序" class="headerlink" title="14.5 I/O调度程序"></a>14.5 I/O调度程序</h3><p>磁盘寻址是整个计算机中最慢的操作之一。每一次寻址都需要花费大量的时间。所以对于系统来说，系统性能提升的关键路径之一就是缩短寻址时间。</p><p>为了优化寻址操作，内核既不会简单的请求接收次序，也不会立即将其提交给磁盘，而是在提交前进行合并与排序的预操作。而在内核中用于提交I/O请求的子系统称为I/O 调度程序。</p><blockquote><p>I/O 调度程序通过将请求队列中挂起的请求进行合并与排序将磁盘I/O资源分配给系统中所有挂起的块I/O请求。这里的调度程序要注意与第四章中描述的进程调度区分开，进程调度是将处理器的资源分配给系统中正在进行的进程，而I/O调度程序则是对虚拟块设备的资源整合，给多个磁盘请求，以降低磁盘寻址时间，确保磁盘性能最优化。</p></blockquote><h4 id="14-5-1-I-O调度程序的工作"><a href="#14-5-1-I-O调度程序的工作" class="headerlink" title="14.5.1 I/O调度程序的工作"></a>14.5.1 I/O调度程序的工作</h4><p>I/O调度程序的工作是管理块设备的请求队列。它决定了队列中的请求排列顺序以及在什么时刻派发请求到块设备。这样做有利于减少磁盘寻址时间，提高全局吞吐量（之所以说提高全局吞吐量是因为一个I/O调度器可能因为系统整体性能考虑从而不公平对待所有请求）</p><p>前面提到过，I/O调度程序通过两种办法来减少磁盘寻址时间：合并与排序。让我们对这两个情况分别举一个例子：</p><ul><li><p>合并指的是将多个请求进行结合生成一个新的请求。假定两次请求中需要的块刚好是相邻扇区，那么这两个请求就可以合并为一个请求，从而将多次寻址开销转化为一次寻址开销。这种合并显然能减少系统的开销以及磁盘的寻址次数。</p></li><li><p>排序则是对多个请求进行重排序操作。假定存在一个请求，他所请求的磁盘操作的扇区与当前请求比较接近，那么显然让他们进行相邻请求更加合理。所以说I/O调度程序做了这样一件事情：将整个请求队列按照扇区增长的方向有序排列。尽可能使得所有请求按照硬盘上扇区的排列顺序有序。这一操作的目的不仅仅为了缩短单独一次请求的寻址时间，更重要的是通过磁盘头直线方向的移动来缩短磁盘所需的寻道时间。这一算法类似于电梯的调度——电梯不能随意跳跃楼层，而是应该向一个方向移动到需求的最大后再向另外一个方向移动。处于这种相似性，I/O调度算法也被称为电梯调度。</p></li></ul><h4 id="14-5-2-Linus电梯"><a href="#14-5-2-Linus电梯" class="headerlink" title="14.5.2 Linus电梯"></a>14.5.2 Linus电梯</h4><p>Linus电梯再现在的内核中已经不复存在了（2.6版本开始被替换掉）。但是由于这个电梯的思想比其他的调度程序都简单不少，而且执行功能有很多相似，所以可以作为一个入门程序来进行学习。</p><p>Linus电梯能执行合并于排序的预处理。当有新请求加入队列时，它首先会检查其他每一个挂起的请求是否可以和新的请求进行合并。Linus电梯I/O调度程序可以执行向前和向后合并，合并描述了请求是向前还是向后的，并与现有的请求相连。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux内核设计与实现第十四章—块I-O层&quot;&gt;&lt;a href=&quot;#Linux内核设计与实现第十四章—块I-O层&quot; class=&quot;headerlink&quot; title=&quot;Linux内核设计与实现第十四章—块I/O层&quot;&gt;&lt;/a&gt;Linux内核设计与实现第十四章—块I/O层&lt;/h1&gt;&lt;p&gt;块设备是系统中能够随机访问固定大小数据片的硬件设备，所以这些固定大小的数据片就称为块。最常见的块设备是硬盘，其余闪存，光驱等也均为块设备。在内核中，这些块设备都是以安装文件系统的方式使用的。&lt;/p&gt;
&lt;p&gt;与块设备相对应的设备类型是字符设备。字符设备会按照字节流的方式被有序访问（例如串口或者键盘这样的设备）。也就是说字符设备和块设备之间的最主要区别就是——数据是否可以被随机访问。&lt;/p&gt;
&lt;p&gt;对于内核来讲，对于块设备的管理要比对于字符设备的管理细致的多。因为块设备中要考虑的问题比字符设备更多。字符设备只需要控制当前位置的数据，而块设备上的位置需要在介质的区间中不停移动。更重要的是，块设备普遍来说对执行性能的要求很高。对硬盘的每多一份利用都会对整个系统带来性能上的提升。所以内核给块设备提供了专门提供服务的子系统。而这一章讲述的就是内核如何对块设备和块设备的请求进行管理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux内核设计与实现" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Linux内核" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="块IO层" scheme="http://yokeso.github.io/tags/%E5%9D%97IO%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核设计与实现ch10 内核同步方法</title>
    <link href="http://yokeso.github.io/2023/06/18/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0ch10%20%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/"/>
    <id>http://yokeso.github.io/2023/06/18/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0ch10%20%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/</id>
    <published>2023-06-18T07:11:22.000Z</published>
    <updated>2023-07-26T11:08:21.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核设计与实现ch10-内核同步方法"><a href="#Linux内核设计与实现ch10-内核同步方法" class="headerlink" title="Linux内核设计与实现ch10 内核同步方法"></a>Linux内核设计与实现ch10 内核同步方法</h1><h3 id="10-1-原子操作"><a href="#10-1-原子操作" class="headerlink" title="10.1 原子操作"></a>10.1 原子操作</h3><p>原子操作可以保证命令以原子方式执行，不会被打断。内核提供了两组原子操作接口——一组针对整数进行操作，一组针对单独位进行操作。在Linux支持的所有体系结构上都实现了这两组接口。大多数体系结构都会提供支持原子操作的简单算数指令，而有些体系结构缺少简单的原子操作指令，但是也提供了锁存总线的指令。</p><span id="more"></span><h4 id="10-1-1-原子整数操作"><a href="#10-1-1-原子整数操作" class="headerlink" title="10.1.1 原子整数操作"></a>10.1.1 原子整数操作</h4><p>针对原子整数操作只能对<code>atomic_t</code>（定义在<code>&lt;linux/types.h&gt;</code>中）的数据类型进行处理，在64位系统中也存在类似的<code>atomic64_t</code>。在这里没有直接使用c语言的int类型，是处于几个方面考虑：</p><ul><li>一是希望原子操作只对这种特殊类型起作用，而且该类型的数据不会传给任何非原子数。</li><li>二是确保了编译器不会对相应的值做出优化——使得原子操作最后能收到正确的地址而非别名。</li><li>三是希望在不同结构体系上实现原子操作的时候，<code>atomic_t</code>可以屏蔽其间的差异。</li></ul><p>其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        s64 counter;</span><br><span class="line">&#125; <span class="keyword">atomic64_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>尽管Linux支持的所有机器的整形数据都是32位，但是<code>atomic_t</code>只将该类型的数据作为24位来使用。这个限制是因为在<code>SPRAC</code>体系结构上，原子操作实现与其他体系不同。32位int类型的低八位被嵌入了一个锁。<code>SPRAC</code>结构缺乏对原子操作指令集的支持，所以只能用锁来避免原子类型数据被并发访问</p></blockquote><p>使用原子操作需要的类型声明存放在<code>&lt;arch/体系结构名称/include/asm/atomic.h&gt;</code>中。有些体系结构会提供一些只能在该体系结构上的额外原子操作方法，但所有体系结构都能保证内核上使用到的操作的最小集。</p><p>定义一个atomic_t类型的数据很平常，可以在定义的时候给他赋初值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">atomic_t</span> v;</span><br><span class="line"><span class="keyword">atomic_t</span> u = ATOMIC_INT(<span class="number">0</span>);   <span class="comment">/*init and set to zero*/</span></span><br></pre></td></tr></table></figure><p>下表列出了所有的标准原子操作，某些特定的体系结构上实现的操作可以在<code>atomic.h</code>中找到。</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">ATOMIC_INIT(int i)</td><td style="text-align:center">声明一个atoimic_t变量时将其初始化为i</td></tr><tr><td style="text-align:center">int atomic_read(atomic_t *v)</td><td style="text-align:center">读取原子变量v并返回其int值</td></tr><tr><td style="text-align:center">void atomic_set(atomic_t *v, int i)</td><td style="text-align:center">原子的将v值设置为i</td></tr><tr><td style="text-align:center">void atomic_add(int i, atomic_t *v)</td><td style="text-align:center">原子地给v加上i</td></tr><tr><td style="text-align:center">void atomic_sub(int i, atomic_t *v)</td><td style="text-align:center">原子地给v减去i</td></tr><tr><td style="text-align:center">int atomic_inc(atomic_t *v)</td><td style="text-align:center">原子地给v加上1</td></tr><tr><td style="text-align:center">int atomic_dec(atomic_t *v)</td><td style="text-align:center">原子地给v减去1</td></tr><tr><td style="text-align:center">void atomic_add_return(int i, atomic_t *v)</td><td style="text-align:center">原子地给v加上i，且返回结果</td></tr><tr><td style="text-align:center">void atomic_sub_return(int i, atomic_t *v)</td><td style="text-align:center">原子地给v减去i，且返回结果</td></tr><tr><td style="text-align:center">int atomic_inc_return(atomic_t *v)</td><td style="text-align:center">原子地给v加上1，且返回结果</td></tr><tr><td style="text-align:center">int atomic_dec_return(atomic_t *v)</td><td style="text-align:center">原子地给v减去1，且返回结果</td></tr><tr><td style="text-align:center">bool atomic_inc_and_test(atomic_t *v)</td><td style="text-align:center">原子地给v加上1，如果结果为0，返回真，否则返回假</td></tr><tr><td style="text-align:center">bool atomic_dec_and_test(atomic_t *v)</td><td style="text-align:center">原子地给v减去1，如果结果为0，返回真，否则返回假</td></tr></tbody></table></div><p>原子操作往往是内联函数，通过内嵌汇编指令来实现的。如果某个函数本身就是原子的，那么往往会定义一个宏。例如在大部分体系结构上，读取一个字节本身就是原子操作。</p><blockquote><p>64位的函数只需要在所有的函数中的atomic后面加64，例如atomic64_sub()</p></blockquote><h4 id="10-1-2-原子位操作"><a href="#10-1-2-原子位操作" class="headerlink" title="10.1.2 原子位操作"></a>10.1.2 原子位操作</h4><p>与原子位操作相关的函数定义在<code>&lt;arch/体系结构名称/include/asm/atomic.h&gt;</code>中。这里的位操作函数是对普通的内存地址进行操作的，形参是一个指针加一个位号。并且对位号没有做限制。例如在32位上31位是最高有效位，但可以指定32为下一个字的最低有效位。下面给出了原子位操作的表</p><div class="table-container"><table><thead><tr><th style="text-align:center">原子位操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">void set_bit(int nr, void *addr)</td><td style="text-align:center">原子地设置addr所指对象的第nr位</td></tr><tr><td style="text-align:center">void clear_bit(int nr, void *addr)</td><td style="text-align:center">原子地清空addr所指对象的第nr位</td></tr><tr><td style="text-align:center">void change_bit(int nr, void *addr)</td><td style="text-align:center">原子地翻转addr所指对象的第nr位</td></tr><tr><td style="text-align:center">int test_and_set_bit(int nr, void *addr)</td><td style="text-align:center">原子地设置addr所指对象的第nr位，并返回原先的值</td></tr><tr><td style="text-align:center">int test_and_clear_bit(int nr, void *addr)</td><td style="text-align:center">原子地清空addr所指对象的第nr位，并返回原先的值</td></tr><tr><td style="text-align:center">int test_and_change_bit(int nr, void *addr)</td><td style="text-align:center">原子地翻转addr所指对象的第nr位，并返回原先的值</td></tr><tr><td style="text-align:center">int test_bit(int nr, void *addr)</td><td style="text-align:center">原子地返回addr所指对象的第nr位</td></tr></tbody></table></div><blockquote><p>为了方便起见，内核还提供了一组与上述对应的非原子性操作，其名字前有两个下华夏，例如set_bit()的非原子对应形式就是__set_bit()。如果不需要原子操作的话，非原子操作可能会执行的更快一些。</p></blockquote><h3 id="10-2-自旋锁"><a href="#10-2-自旋锁" class="headerlink" title="10.2 自旋锁"></a>10.2 自旋锁</h3><p>自旋锁是linux内核中最常见的锁。自旋锁最多只能被一个可执行进程所占有。如果一个执行线程试图获取一个被持有的自旋锁，那么该线程就会一直进行<code>忙循环-旋转-等待锁重新可用</code>。而锁未被持有的话，进程就会立刻得到它。自旋锁的要点是进程等待锁可用时自旋，这种行为特别浪费处理器时间。所以自旋锁不应该被长时间持有。</p><h4 id="10-2-1-自旋锁方法"><a href="#10-2-1-自旋锁方法" class="headerlink" title="10.2.1 自旋锁方法"></a>10.2.1 自旋锁方法</h4><p>自旋锁的实现与体系结构紧密相关，往往通过汇编来实现。这些与体系相关的代码定义在文件<code>&lt;asm/spinlock.h&gt;</code>中，实际需要用到的接口文件在<code>&lt;linux/spinlock.h&gt;</code>中。自旋锁的基本使用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(mr_lock);</span><br><span class="line">spin_lock(&amp;mr_lock);</span><br><span class="line"><span class="comment">/*临界区*/</span></span><br><span class="line">spin_unlock(&amp;mr_lock);</span><br></pre></td></tr></table></figure><blockquote><p>注意在单处理器机器上，编译的时候并不会加入自旋锁。它仅仅被当作一个设置内核抢占机制是否被启用的开关。如果禁止内核抢占，则在编译时自旋锁会被完全剔除内核。</p><p>与其他操作系统不同，Linux内核实现的自旋锁不可递归。所以在设计的时候要注意避免死锁问题！</p></blockquote><p>自旋锁可以使用在中断处理程序中（第七章就使用了自旋锁）。在中断处理程序中使用自旋锁之前一定要先禁止本地中断（当前处理器上的中断）。否则中断处理程序就会打断持有锁的内核代码。有可能导致死锁。</p><p>内核提供了禁止中断并且请求锁的接口，使用起来很方便，其方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEFIDEFINE_SPINLOCK(mr_lock);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;mr_lock, flags);</span><br><span class="line"><span class="comment">/*临界区*/</span></span><br><span class="line">spin_unlock_irqrestore(&amp;mr_lock, flags);</span><br></pre></td></tr></table></figure><p>函数<code>spin_lock_irqsave</code>保存中断当前状态，并禁止本地中断，然后再去获取指定的锁。反过来<code>spin_unlock_irqrestore</code>对指定的锁解锁，让中断恢复到加锁前的状态。</p><blockquote><p>这里的flag看起来是传值的，是因为函数实现有些部分是通过宏来实现的。在单处理器上，加锁和解锁能分别禁止和允许内核进行抢占。</p><p>配置选项<code>CONFIG_DEBUG_SPINLOCK</code>为使用自旋锁代码加入了许多调试手段，必须是否使用未初始化的锁以及是否还未加锁时就执行开锁操作。如果需要进一步全程调试锁，则需要打开<code>CONFIG_DEBUG_LOCL_ALLOC</code>选项。</p></blockquote><h4 id="10-2-2-其他针对自旋锁的操作"><a href="#10-2-2-其他针对自旋锁的操作" class="headerlink" title="10.2.2 其他针对自旋锁的操作"></a>10.2.2 其他针对自旋锁的操作</h4><p>自旋锁的初始化可以使用<code>spin_lock_init()</code>来实现。<code>spin_try_lock()</code>试图获得某个特定的锁，如果该锁已被征用，该方法立刻返回一个非0值，不会自旋等待锁释放。如果成功获得了这个自旋锁，则函数返回0。同理，<code>spin_is_locked()</code>方法用于检查待定的锁当前是否被占用，若已占用返回非0值，否则返回0值。但是该方法只做判断，并不实际占用。</p><h4 id="10-2-3-自旋锁和下半部"><a href="#10-2-3-自旋锁和下半部" class="headerlink" title="10.2.3 自旋锁和下半部"></a>10.2.3 自旋锁和下半部</h4><p>由于下半部可以抢占进程上下文中的代码，所以下半部和进程上下文共享数据时，必须对进程上下文中的共享数据进行保护，所以需要加锁的同时禁止下半部的执行(<code>spin_lock_bh()</code>)。<code>spin_unlock_bh()</code>来执行相反操作。</p><p>由于同类的<code>tasklet</code>不可能同时运行，所以对于同类tasklet中的共享数据不需要保护。但是当数据被两个不同种类的tasklet共享时，就需要在访问下半部的数据中先获得一个普通的自旋锁。（因为同一个处理器上不会有testlet抢占的情况出现，所以不需要禁止下半部）</p><h3 id="10-3-读写自旋锁"><a href="#10-3-读写自旋锁" class="headerlink" title="10.3 读写自旋锁"></a>10.3 读写自旋锁</h3><p>为了读写场景的不同需求，内核提供了专门的读-写自旋锁。这种锁为读和写提供了不同的锁。多个读任务可以并发的持有读者锁，而写者锁只能同时被一个写任务持有。读写锁的使用方法类似于普通的自旋锁，通过以下方法进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_RWLOCK(mr_rwlock);</span><br></pre></td></tr></table></figure><p>在读者代码分支中使用如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read_lock(&amp;mr_rwlock);</span><br><span class="line"><span class="comment">/*临界区（只读）*/</span></span><br><span class="line">read_unlock(&amp;mr_rwlock);</span><br></pre></td></tr></table></figure><p>写者代码分支中使用如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write_lock(&amp;mr_rwlock);</span><br><span class="line"><span class="comment">/*临界区（只读）*/</span></span><br><span class="line">write_unlock(&amp;mr_rwlock);</span><br></pre></td></tr></table></figure><p>通常情况下，读锁和写锁会位于完全割离开的代码分支中，但是要注意不能将一个读锁升级为写锁，否则可能会带来死锁。如果读写不能清晰分开的话更好的方法是使用一般的自旋锁。</p><blockquote><p>要注意在内核中的读写自旋锁中，锁机制照顾读比照顾写多一点，所以如果读锁持有而未被释放时，写操作只能进行等待。但其他读者可以很轻松的占有锁。这样会导致写锁饥饿。所以在设置锁的时候要考虑到这一点。</p></blockquote><h3 id="10-4-信号量"><a href="#10-4-信号量" class="headerlink" title="10.4 信号量"></a>10.4 信号量</h3><p>Linux中的信号量是一种睡眠锁。如果一个任务试图获取一个不可用的信号量时，信号量将会将其推入一个等待队列，并使其休眠，从而让处理器能够执行其他代码。当持有的信号量被释放时，处于等待队列的进程被唤醒，并可以获取该信号量。但是要注意的是信号量的开销要比自旋锁更大。</p><p>从信号量的睡眠特性中可以得出这样一些结论：</p><ul><li>由于征用信号量的进程在等待的时候会进入睡眠，所以信号量适用于锁会被长时间持有的情况。</li><li>与第一条相反，如果锁短时间持有的情况下，由于睡眠，维护等待队列以及选择唤醒的开销会比锁占有的全部时间还要长。</li><li>中断上下文中是不能调度的，所以只有在进程上下文过程中才能获取信号量锁。</li><li>在持有信号量时可以去睡眠，其他进程试图获取该信号量时不会因此死锁。</li><li>在占用信号量的同时不能占用自旋锁。因为信号量机制允许睡眠，而自旋锁不允许睡眠。</li></ul><blockquote><p>要注意信号量不同于自旋锁的地方，信号量不会禁止内核抢占，也就意味着信号量不会对调度的等待时间产生负面影响。</p></blockquote><p>下面是关于信号量的一些使用方法，这些方法定义在<code>&lt;asm/semaphore.h&gt;</code>中。<code>struct semaphore</code>类型来表示信号量。各种操作定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建信号量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">name</span>;</span></span><br><span class="line">sema_init(&amp;name, count);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建互斥信号量</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span><span class="params">(name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化指向信号量的间接指针</span></span><br><span class="line">sema_init(sem, count);</span><br><span class="line">init_MUTEX(sem);</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图获取指定的信号量，</span></span><br><span class="line">down_interruptible(&amp;name);   <span class="comment">//如果信号量不可用则进入睡眠。(在获取信号量之后返回-EINTR),睡眠时的状态为TASK_INTERRUPTIBLE(可被中断唤醒)</span></span><br><span class="line">down(&amp;name);                 <span class="comment">//如果信号量不可用则进入睡眠。睡眠时的状态为TASK_UNINTERRUPTIBLE(不可被中断唤醒)</span></span><br><span class="line">down_trylock(&amp;name);         <span class="comment">//以堵塞的方式获取指定信号量，在信号量被占用时立即返回非0值，否则返回0</span></span><br><span class="line"></span><br><span class="line">up(&amp;name);                   <span class="comment">//释放指定信号量，如果睡眠队列不为空，则唤醒一个任务</span></span><br></pre></td></tr></table></figure><h3 id="10-5-读写信号量"><a href="#10-5-读写信号量" class="headerlink" title="10.5 读写信号量"></a>10.5 读写信号量</h3><p>读写信号量是由<code>rw_semaphore</code>结构表示的，定义在文件<code>&lt;linux/rwsem.h&gt;</code>中。以下是函数操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明读写信号量</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_RWSEM</span><span class="params">(name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态创建读写信号量</span></span><br><span class="line">init_rwsem(struct rw_semaphore *sem);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取用于读的信号量</span></span><br><span class="line">down_read(&amp;mr_rwsem);</span><br><span class="line">down_read_trylock(&amp;mr_rwsem);   <span class="comment">//效果类似于down_trylock(&amp;name);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line">up_read(&amp;mr_rwsem);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取用于写的信号量</span></span><br><span class="line">down_write(&amp;mr_rwsem);</span><br><span class="line">down_write_trylock(&amp;mr_rwsem);   <span class="comment">//效果类似于down_trylock(&amp;name);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line">up_write(&amp;mr_rwsem);</span><br><span class="line"></span><br><span class="line">downgrade_write(); <span class="comment">//动态的将写锁转为读锁</span></span><br></pre></td></tr></table></figure><h3 id="10-6-互斥锁"><a href="#10-6-互斥锁" class="headerlink" title="10.6 互斥锁"></a>10.6 互斥锁</h3><p>mutex的实现方式与使用计数为一的信号量类似，但操作接口更加简单，实现也更加高效。而且使用限制更强</p><ul><li>任意一个时刻只能有一个任务可以持有mutex</li><li>给mutex上锁的人要负责解锁（解锁和上锁要在同一个上下文中执行）</li><li>持有一个mutex时进程不可以退出</li><li>mutex不能在下半部分或中断使用</li><li>mutex只能通过官方API管理，不可被拷贝，手动初始化或者重复初始化。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态定义mutex</span></span><br><span class="line">DEFINE_MUTEX(name);</span><br><span class="line"><span class="comment">//动态</span></span><br><span class="line">mutex_init(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁定</span></span><br><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">mutex_trylock(&amp;mutex);</span><br><span class="line">mutex_is_locked(&amp;mutex);</span><br></pre></td></tr></table></figure><h3 id="10-7-完成变量"><a href="#10-7-完成变量" class="headerlink" title="10.7 完成变量"></a>10.7 完成变量</h3><p>完成变量<code>(completion variable)</code>是同步两个任务的简单方法，它使得内核中的一个任务可以发出信号通知另一个任务发生了某个特定事件。如果一个任务要执行一个工作时，另一个任务就会在完成变量上等待。当这个任务完成工作后，会使用完成变量去唤醒在等待的任务。</p><p>事实上，完成变量仅仅提供了代替信号量的一个简单的解决办法，例如：子进程执行或者退出时，<code>vfork()</code>系统调用使用完成变量唤醒父进程。</p><p>完成变量由结构<code>completion</code>表示，定义在<code>&lt;linux/completion.h&gt;</code>中，可以通过<code>DECLARE_COMPLETION(mr_comp)</code>去静态的创建变量并将其初始化。或者通过<code>init_completion()</code>动态创建并初始化完成变量。</p><p>在一个指定的完成变量上，需要等待的任务调用<code>wait_for_completion()</code>来等待特定事件。当特定事件发生后，产生的时间调用<code>complete()</code>来发送信号唤醒正在等待的任务。</p><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">init_completion(struct completion *)</td><td style="text-align:center">初始化指定的动态创建的完成变量</td></tr><tr><td style="text-align:center">wait_for_completion(struct completion *)</td><td style="text-align:center">等待指定的完成变量接收信号</td></tr><tr><td style="text-align:center">complete(struct completion *)</td><td style="text-align:center">发信号唤醒任何等待任务</td></tr></tbody></table></div><blockquote><p>使用完成变量的例子可以参考<code>kernel/sched.c</code>以及<code>kernel/fork.c</code>。完成变量的通常用法是：将完成变量作为数据结构中的一项进行动态创建，而完成数据结构初始化工作的内核代码将调用<code>wait_for_completion()</code>进行等待。初始化完成后，初始化函数调用<code>completion()</code>唤醒在等待的内核任务。</p></blockquote><h3 id="10-8-顺序锁"><a href="#10-8-顺序锁" class="headerlink" title="10.8 顺序锁"></a>10.8 顺序锁</h3><p>顺序锁，也成为seq锁，从linux 2.6版本中引入，这种锁提供了一种很简单的机制，用于读写共享数据。实现这种锁主要依靠一个序列计数器。当有疑义的数据被写入时，会得到一个锁。而且序列值会增加。在读取数据前后会读取序列号。</p><ul><li>如果读取的序列号值相同，说明在读操作进行的过程中没有被写操作打断过，</li><li>如果读取的是偶数，则表明写操作没有发生</li></ul><p>（锁的初始值是0，所以写锁会将值置为奇数，写锁释放的时候会变为偶数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义seq锁</span></span><br><span class="line">seq_lock mr_seq_lock = DEFINE_SEQOCK(mr_seq_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写锁</span></span><br><span class="line">write_seqlock(&amp;mr_seq_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁</span></span><br><span class="line">write_sequnlock(&amp;mr_seq_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在读时与普通自旋锁有很大的不同</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> seq;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    seq = read_seqbegin(&amp;mr_seq_lock);</span><br><span class="line">&#125;<span class="keyword">while</span>(read_seqretry(&amp;mr_seq_lock));</span><br></pre></td></tr></table></figure><p>在多个读者和少数写者共享一把锁的时候，seq锁有助于提供一种非常轻量级和具有可扩展性的外观。但是seq锁对写者更有利。只要没有其他写者，写锁总是能被成功获取。挂起的写者会使得读不断循环，直到没有写者持有锁为止。</p><p>Seq锁主要适用于以下几个方向：</p><ul><li>读者比写者多得多，写者很少</li><li>希望优先读，并且不允许读者让写者饥饿</li><li>数据简单，只有简单的结构或者甚至简单的标准类型</li></ul><p>使用seq锁最具有说服力的是jiffies。该变量存储了Linux机器启动到当前时间。该方法的实现就使用了seq锁。</p><h3 id="10-9-禁止抢占"><a href="#10-9-禁止抢占" class="headerlink" title="10.9 禁止抢占"></a>10.9 禁止抢占</h3><p>由于内核是抢占性的，内核中的进程在任何时刻都可能停下来以便另一个具有更高优先权的进程运行。这就意味着一个任务与被抢占的任务可能会在同一个临界区运行。为了避免这种情况，内核抢占代码使用自旋锁作为非抢占区域的标记。如果一个自旋锁被持有，内核便不能进行抢占。如果自旋锁没有被持有，并且内核又是抢占式的，那么一个新的调度任务就可能会访问同一变量，从而引发问题。</p><p>通过<code>preempt_disable()</code>禁止内核抢占，这个函数可以调用任意次，每次调用都要有一个相应的<code>preempt_enable()</code>调用。当最后一次<code>preempt_enable()</code>调用后，内核抢占才重新启用。</p><h3 id="10-10-顺序和屏障"><a href="#10-10-顺序和屏障" class="headerlink" title="10.10 顺序和屏障"></a>10.10 顺序和屏障</h3><p>当处理多处理器或者硬件设备之间的同步问题时，可能需要程序代码中以指定的顺序发出读写内存的指令。在与硬件交互时也时常需要确保一个给定的读操作发生在其他读或者写操作之前，或者在多处理器中可能需要按写数据的顺序进行读取。但是编译器为提高效率可能会对读写进行重新排序。但可能重新排序读写的处理器提供了机器指令来确保顺序要求。同样可以使得编译器不对定点周围指令进行重新排序。这些确保顺序的指令称为屏障。</p><div class="table-container"><table><thead><tr><th style="text-align:center">屏障</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">rmb()</td><td style="text-align:center">阻止跨越屏障的载入动作发生重排序</td></tr><tr><td style="text-align:center">read_barrier-depends()</td><td style="text-align:center">阻止跨越屏障的具有数据依赖关系的载入动作重排序</td></tr><tr><td style="text-align:center">wmb()</td><td style="text-align:center">阻止跨越屏障的存储动作发生重排序</td></tr><tr><td style="text-align:center">mb()</td><td style="text-align:center">阻止跨越屏障的载入和存储动作发生重排序</td></tr><tr><td style="text-align:center">smp_rmb()</td><td style="text-align:center">在SMP上提供rmb()功能，在UP上提供barrier()功能</td></tr><tr><td style="text-align:center">smp_read_barrier-depends()</td><td style="text-align:center">在SMP上提供read_barrier-depends()功能，在UP上提供barrier()功能</td></tr><tr><td style="text-align:center">smp_wmb()</td><td style="text-align:center">在SMP上提供wmb()功能，在UP上提供barrier()功能</td></tr><tr><td style="text-align:center">smp_mb()</td><td style="text-align:center">在SMP上提供mb()功能，在UP上提供barrier()功能</td></tr><tr><td style="text-align:center">barrier()</td><td style="text-align:center">组织编译器跨屏障对载入或存储操作进行优化</td></tr></tbody></table></div><blockquote><p>注意：对于不同体系结构，屏障的实际效果差别很大。如果一个处理器不会执行乱序存储的话，wmb()函数实际什么都不会做。</p><p>SMP与UP</p><p>在中断处理程序中能避免并发访问的安全代码称作中断安全代码（interrupt-safe），在多对称处理的机器中能避免并发访问的安全代码称为SMP安全代码（SMP-safe），在内核抢占时能避免并发访问的安全代码称为抢占安全代码（preempt-safe）。</p><p>因为Linux内核可在编译时配置，所以可以针对指定机器进行内核剪裁，更重要的是，CONFIG_CMP没被设置时，不必要的代码就不会被编入针对单处理器的内核镜像中。这样可以使单处理器机器避免使用自旋锁带来的开销。CONFIG_PREEMPT这一选项也同样适用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux内核设计与实现ch10-内核同步方法&quot;&gt;&lt;a href=&quot;#Linux内核设计与实现ch10-内核同步方法&quot; class=&quot;headerlink&quot; title=&quot;Linux内核设计与实现ch10 内核同步方法&quot;&gt;&lt;/a&gt;Linux内核设计与实现ch10 内核同步方法&lt;/h1&gt;&lt;h3 id=&quot;10-1-原子操作&quot;&gt;&lt;a href=&quot;#10-1-原子操作&quot; class=&quot;headerlink&quot; title=&quot;10.1 原子操作&quot;&gt;&lt;/a&gt;10.1 原子操作&lt;/h3&gt;&lt;p&gt;原子操作可以保证命令以原子方式执行，不会被打断。内核提供了两组原子操作接口——一组针对整数进行操作，一组针对单独位进行操作。在Linux支持的所有体系结构上都实现了这两组接口。大多数体系结构都会提供支持原子操作的简单算数指令，而有些体系结构缺少简单的原子操作指令，但是也提供了锁存总线的指令。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux内核设计与实现" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="内核同步方法" scheme="http://yokeso.github.io/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/"/>
    
      <category term="Linux内核" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核设计与实现ch5-7 系统调用</title>
    <link href="http://yokeso.github.io/2023/06/10/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch5-ch7/"/>
    <id>http://yokeso.github.io/2023/06/10/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch5-ch7/</id>
    <published>2023-06-10T07:11:22.000Z</published>
    <updated>2023-07-26T11:08:08.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核设计与实现第五章—系统调用"><a href="#Linux内核设计与实现第五章—系统调用" class="headerlink" title="Linux内核设计与实现第五章—系统调用"></a>Linux内核设计与实现第五章—系统调用</h1><h3 id="5-1-与内核通讯"><a href="#5-1-与内核通讯" class="headerlink" title="5.1 与内核通讯"></a>5.1 与内核通讯</h3><p>中间层位于用户空间进程与硬件设备之间，由系统调用添加。该层的作用主要有三个</p><ul><li>为用户空间提供硬件的抽象接口，可以对用户屏蔽不同硬件之间的差异</li><li>保证了系统的稳定性与安全性，内核可以基于权限，用户类型等对需要进行的访问进行裁决，防止它做出对系统有危害的事情</li><li>为运行在虚拟内存中的进程提供统一接口</li></ul><p>系统调用是用户除了系统异常和陷入外访问内核的唯一手段和唯一合法入口。</p><span id="more"></span><h3 id="5-3-系统调用"><a href="#5-3-系统调用" class="headerlink" title="5.3 系统调用"></a>5.3 系统调用</h3><p>系统调用通常通过程序在C 库中的函数调用来进行。内核并没有规定这些调用要如何实现。只是希望最后的结果正确就可以了。</p><blockquote><p>系统调用的get_pid()在内核中被定义为sys_getpid()，这是Linux中所有系统调用都应该遵守的规则。例如bar()也实现为sys_bar()。</p></blockquote><h4 id="5-3-1-系统调用号"><a href="#5-3-1-系统调用号" class="headerlink" title="5.3.1 系统调用号"></a>5.3.1 系统调用号</h4><p>Linux中的每个系统都被分配了一个系统调用号。当用户空间的进程执行一个系统调用的时候，系统调用号就可以用来指明要执行哪个系统调用；进程不会提及系统调用的名称。</p><p>系统调用号相当重要，一旦分配后就不能有任何变更。否则编译好的应用程序就会崩溃。此外，如果一个系统调用被删除。它占用的系统调用号也不能被回收。否则一些其他已经编译的代码会调用这些系统调用，但实际上却获得了另外一个系统调用。为了处理系统调用被删除的情况，Linux有一个”未实现的“系统调用<code>sys_ni_syscall</code>函数。当无效的系统调用产生时，就会调用这个函数，并且只会返回<code>-ENOSYS</code>。</p><p>内核会产生一个记录所有已注册过的系统调用的列表。存储在<code>sys_call_table</code>中。每种体系结构中都明确定义了这个表。在x86-64中，这个表位于<code>/arch/i386/kernel/syscall_64.c</code>中，主要为每个有效的系统调用指定唯一的系统调用号。</p><h4 id="5-3-2-系统调用的性能"><a href="#5-3-2-系统调用的性能" class="headerlink" title="5.3.2 系统调用的性能"></a>5.3.2 系统调用的性能</h4><p>Linux系统调用比其他许多系统执行的要快。主要原因在于Linux的上下文切换时间很短。进出内核得益于此都变得简洁高效。另一个原因也有系统调用处理程序和每个系统调用本身都非常整洁的原因。</p><h3 id="5-4-系统调用处理程序"><a href="#5-4-系统调用处理程序" class="headerlink" title="5.4 系统调用处理程序"></a>5.4 系统调用处理程序</h3><p>由于内核驻留在受保护的地址空间上，所以进程无法（也不应该）直接调用内核空间中的函数。那么就需要有一种方式使得应用程序能够通知系统，告诉内核执行一个系统调用，并且希望系统切换到内核态。这样内核就可以代表用户程序在内核空间内执行系统调用。</p><p>通知内核的机制依靠软中断来实现。应用程序通过引发一个异常使系统切换到内核态，并且执行异常处理程序。这里的异常处理程序就是系统调用处理程序。</p><blockquote><p>x86的软中断的中断号为128。通过int $0x80来触发中断。这个系统处理程序称为system_call()</p></blockquote><h4 id="5-4-1-指定恰当的系统调用"><a href="#5-4-1-指定恰当的系统调用" class="headerlink" title="5.4.1 指定恰当的系统调用"></a>5.4.1 指定恰当的系统调用</h4><p>由于所有的系统中断陷入方式都相同。所以还需要通过系统调用号才能知道具体要执行什么系统调用。x86上的系统调用号使通过eax寄存器来传递给内核的。这个数据由应用程序在执行系统调用之前放入。这样系统调用一旦执行，就可以通过eax上的系统调用号来执行对应的系统调用。</p><blockquote><p>系统调用表项是以64位类型存放的。所以内核需要将给定的系统调用号乘四就能找到表中的位置。</p></blockquote><h4 id="5-4-2-传递参数"><a href="#5-4-2-传递参数" class="headerlink" title="5.4.2 传递参数"></a>5.4.2 传递参数</h4><p>系统调用的参数与常规函数调用时传参方式相同，前六个参数分别保存在寄存器%rdi、%rsi、%rdx、%rcx、%r8、%r9中，剩余的参数保存在栈上。</p><h3 id="5-5-系统调用的实现"><a href="#5-5-系统调用的实现" class="headerlink" title="5.5 系统调用的实现"></a>5.5 系统调用的实现</h3><blockquote><p>记住Linux的格言：提供机制而非策略</p></blockquote><h4 id="5-5-1-实现系统调用"><a href="#5-5-1-实现系统调用" class="headerlink" title="5.5.1 实现系统调用"></a>5.5.1 实现系统调用</h4><p>实现系统调用的时候需要注意以下几点</p><ul><li>决定系统调用需要做什么，Linux不提倡采用多用途的系统调用</li><li>参数、返回值和错误码都应该是什么，接口应该力求简洁，参数尽可能少</li><li>考虑向前兼容和未来发展（系统的可移植性，是否能向前兼容，是不是对函数做了不必要的限制）</li></ul><h4 id="5-5-2-参数验证"><a href="#5-5-2-参数验证" class="headerlink" title="5.5.2 参数验证"></a>5.5.2 参数验证</h4><p>为了系统的安全性与稳定性，系统调用必须仔细检查他们所有的参数是否合法有效。（比如进程的PID，IO的文件描述符等等）<strong>进程不应该让内核访问它无权访问的资源</strong>。</p><p>最重要的是检查用户提供的指针是否有效。在接受用户空间的指针之前，内核必须保证：</p><ul><li>指针指向的内存区域属于用户空间。进程绝不能哄骗内核去读内核空间数据</li><li>指针指向的内存区域属于进程的地址空间里。进程不能哄骗内核去读其他进程的数据</li><li>进程不能绕过内存访问的限制，应该与内存标记的读，写，执行相同</li></ul><p>内核提供了两种方法来完成必须的检查和内核空间与用户空间之间来回的内存拷贝。两种方法中必须经常有一个被使用。</p><ul><li><p>向用户空间写入数据的<code>copy_to_user()</code>。需要三个参数：进程空间中目的内存地址，内核空间的源地址，拷贝所需长度。</p></li><li><p>从用户空间读出数据的<code>copy_from_user()</code>。参数与上一个函数相同。</p></li></ul><p>执行失败时返回的是未能完成拷贝的字节数，成功返回0。出现错误时，系统调用返回标准<code>EFAULT</code></p><blockquote><p>要注意，这两个函数都可能会引起堵塞。比如包含用户数据的页被换出到硬盘上之后。此时进程会休眠，直到缺页处理将该页重新换入内存。</p></blockquote><p>最后一项检查是检查合法权限。内核提供了函数<code>capable()</code>来进行检查。例如<code>capable(CAP_SYS_NICE)</code>可以检查调用者是否有权修改其他进程的nice值。</p><blockquote><p>include/linux/capability.h中包含一份所有这些权能及其对应的权限列表。</p></blockquote><h3 id="5-6-系统调用上下文"><a href="#5-6-系统调用上下文" class="headerlink" title="5.6 系统调用上下文"></a>5.6 系统调用上下文</h3><p>由于内核可以被休眠可以被抢占。所以说系统调用也像用户空间的进程一样可以被其他进程抢占。在新的进程中一样可以执行新的系统调用。所以必须要小心来保证系统调用是可重入的。这也是对称多处理中同样要关心的问题。</p><p>系统调用返回至用户态的时候，控制权还在<code>system_call()</code>中。它最终会负责切换到用户空间，让用户进程继续执行下去。</p><h4 id="5-6-1-绑定一个系统调用的最后步骤"><a href="#5-6-1-绑定一个系统调用的最后步骤" class="headerlink" title="5.6.1 绑定一个系统调用的最后步骤"></a>5.6.1 绑定一个系统调用的最后步骤</h4><p>编写一个系统调用后，我们总需要将其注册成为一个正式的系统调用。这个步骤如下</p><ul><li>在系统调用表的最后增加一个表项，对每种支持该系统的硬件体系均需要做这样的操作。（一般位于entry.s中）</li><li>对于支持的各种体系结构，系统调用号必须定义在<code>&lt;asm/unistd.h&gt;</code>中。</li><li>系统调用只能被编译为内核映像而非模块。需要将它放入<code>kernel/</code>下的文件中。</li></ul><h4 id="5-6-2-从用户空间访问系统调用"><a href="#5-6-2-从用户空间访问系统调用" class="headerlink" title="5.6.2 从用户空间访问系统调用"></a>5.6.2 从用户空间访问系统调用</h4><p>通常来讲，系统调用依靠C库来支持，但如果仅仅写出系统调用，C库是不做支持的。</p><p>好在LInux本身提供了一组用来对系统调用进行访问的宏。它会设置好寄存器并调用陷入指令。这个宏是<code>_syscalln()</code>，这里的n的范围是0-6，用来表示需要传递给系统调用的参数个数。参数个数要按照次序来书写。以下以open()为例举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常来说open()的定义是这样的</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//不依靠库支持的时候就需要这么写</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> NR_open    5</span></span></span><br><span class="line"><span class="function">_<span class="title">syscall3</span><span class="params">(<span class="keyword">long</span>, open, <span class="keyword">const</span> <span class="keyword">char</span>, *filename, <span class="keyword">int</span>, flags, <span class="keyword">int</span>, mode)</span></span></span><br></pre></td></tr></table></figure><p>对于每个宏来说，都具有<code>2+2*n</code>个参数。第一个对应了系统调用的返回值类型，第二个是系统调用的名称。后面是按顺序的每个形参的类型和名称。<code>_NR_open</code>在<code>asm/unistd.h</code>中定义，为系统调用号</p><h4 id="5-6-3-为什么不通过系统调用的功能实现某些功能"><a href="#5-6-3-为什么不通过系统调用的功能实现某些功能" class="headerlink" title="5.6.3 为什么不通过系统调用的功能实现某些功能"></a>5.6.3 为什么不通过系统调用的功能实现某些功能</h4><p>新建系统调用的好处</p><ul><li>容易，使用方便</li><li>性能高</li></ul><p>但是需要面临如下问题：</p><ul><li>系统调用号由于其普遍适用性，需要内核处于开发版本时由官方分配</li><li>稳定内核中的系统调用会被固化，为了避免应用程序崩溃，它的接口不允许被改动</li><li>每个支持的体系结构均需要对系统调用进行注册</li><li>系统调用无法通过脚本或者文件系统中直接访问。</li><li>仅仅是为了信息交换，系统调用过于大材小用。</li></ul><p>所以说想要实现一个设备节点，作为系统调用的替代，需要实现<code>read()、write()</code>函数，使用<code>ioctl()</code>对特定的设置进行操作或者对特定信息进行检索。</p><ul><li>信号量这样的接口，可以用文件描述符来表示</li><li>将增加的信息作为文件放入sysfs的合适位置</li></ul><h1 id="Linux内核设计与实现第六章—内核数据结构"><a href="#Linux内核设计与实现第六章—内核数据结构" class="headerlink" title="Linux内核设计与实现第六章—内核数据结构"></a>Linux内核设计与实现第六章—内核数据结构</h1><p>这章由于比较基础。所以仅介绍与传统实现中不太相似的地方。其余的API referance请参考书上或者详见内核api文档</p><h3 id="6-1-链表"><a href="#6-1-链表" class="headerlink" title="6.1 链表"></a>6.1 链表</h3><p>Linux2.1的内核中，官方首次引入了内核链表的实现。自此内核中所有的链表都在官方链表中实现出来。该代码处于头文件<code>&lt;linux/types.h&gt;</code>中。它的实现方式与众不同。并非将数据结构塞入链表，而是将链表塞入数据结构。</p><p>其数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那具体怎么使用呢？这里举个小例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就构成了一个链表。虽然现在链表已经可用了，但是还不太方便。所幸在<code>&lt;linux/list.h&gt;</code>中还有一组API可供使用。他们都只接受<code>list_head</code>结构作为参数。所以为了从指针找到父结构中所包含的变量，我们可以使用<code>container_of()</code>宏来达到。所以内核中简单定义了一个函数来返回<code>list_head</code>的父类型结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_entry - get the struct for this entry</span></span><br><span class="line"><span class="comment"> * @ptr:        the &amp;struct list_head pointer.</span></span><br><span class="line"><span class="comment"> * @type:       the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:     the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line">        container_of(ptr, type, member)</span><br></pre></td></tr></table></figure><p>还有一个需要注意的地方是链表的遍历。内核中提供了几个宏来实现链表的遍历操作</p><p><code>list_for_each_entry(pos, head, member)</code>，pos是一个指向<code>list_head</code>的指针，可以看为<code>list_entry</code>的返回值，head是指向头节点的指针，也就是遍历开始位置。举一个实际的例子（来自inotify—内核文件系统更新通知机制）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct inotify_watch *<span class="title">inode_find_handle</span><span class="params">(struct inode *inode, struct inotify_handle *ih)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_watch</span> *<span class="title">watch</span>;</span></span><br><span class="line">    list_for_each_entry(watch, &amp;inode-&gt;inotify_watches, i_list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(watch-&gt;ih == ih)</span><br><span class="line">            <span class="keyword">return</span> watch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在这个遍历的同时是不能删除的。删除需要用另外一个api <code>list_for_each_entry_safe(pos, next, head, member)</code>.</p><h3 id="6-2-队列"><a href="#6-2-队列" class="headerlink" title="6.2 队列"></a>6.2 队列</h3><p>队列的操作位于<code>lib/kfifo.c</code>中,头文件在<code>include/linux/kfifo.h</code>中</p><h3 id="6-3-映射"><a href="#6-3-映射" class="headerlink" title="6.3 映射"></a>6.3 映射</h3><p>Linux提供了映射这种键到值的关系，映射支持三个操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Add(key, value)</span><br><span class="line">Remove(key)</span><br><span class="line">value = Lookup(key)</span><br></pre></td></tr></table></figure><p>与C++的map操作不同，Linux并非使用了自平衡二叉搜索树来进行实现，而是映射了一个唯一表示数(UID)到一个指针。</p><h3 id="6-4-红黑树"><a href="#6-4-红黑树" class="headerlink" title="6.4 红黑树"></a>6.4 红黑树</h3><p>红黑树是一种二叉自平衡树。也是Linux中主要的平衡二叉树结构。红黑树具有特殊的着色属性，红色/黑色。因遵守着下面几个特此那个，所以能维持半平衡结构。</p><ul><li>所有的节点要么红色，要么黑色</li><li>叶子节点都是黑色</li><li>叶子节点不包含数据</li><li>所有非叶子节点都有两个子节点</li><li>如果一个节点是红色的，那么他的子节点都是黑色的</li><li>在一个节点到其叶子节点的路径中，如果总是包含同样数目的黑色节点，则该路径相比其他路径是最短的。</li></ul><p>上述条件保证了最深的叶子节点深度不会大于两倍最浅叶子节点深度。所以黑红树总是半平衡的。</p><p>rbtree的实现没有提供搜索和插入例程，这些例程希望用户自己定义。</p><h1 id="Linux内核设计与实现第七章—中断和中断处理"><a href="#Linux内核设计与实现第七章—中断和中断处理" class="headerlink" title="Linux内核设计与实现第七章—中断和中断处理"></a>Linux内核设计与实现第七章—中断和中断处理</h1><h3 id="7-1-中断"><a href="#7-1-中断" class="headerlink" title="7.1 中断"></a>7.1 中断</h3><p>中断使得硬件得以发出给处理器。中断本质是一种特殊的电信号，由硬件设备发送给处理器，处理器接收到中断后，会向操作系统反应信号的到来，然后就由操作系统来处理这些数据。<strong>硬件设备生成中断的时候并不考虑与处理器的时钟同步，也就是说中断随时可能发生。</strong></p><p>不同设备对应的中断不同。每个中断都有唯一的一个数字标志，从而使得操作系统能够对中断加以区分，并且知道哪个硬件设备产生了哪个中断，这样操作系统才能给不同的中断提供对应的处理程序。</p><blockquote><p>中断值通常被称为中断请求（IRQ）线。每个IRQ线都会关联一个数值——-例如经典的PC机上IRQ0是时钟中断，IRQ1是键盘中断。但并非所有中断信号均如此严格定义。在PCI总线上的设备就是动态分配的。一些非PC的系统结构也存在动态分配中断的特性。特定的中断与特定的设备关联，并且内核要知道这些信息。</p></blockquote><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>讨论中断就不能不提起异常。异常与中断不同，在产生时就必须要考虑时钟同步。实际上，异常也常常被称为同步中断。在处理器执行到由于变成失误导致的错误指令，或者执行期间出现特殊情况（缺页）时，处理器就会产生一个异常。很多处理器处理异常和中断的手段类似，所以内核对他们的处理也很类似。</p><blockquote><p>第五章中通过软中断实现系统调用就是一种异常（系统调用处理程序的异常）。中断的工作方式与之类似，其差异只是在于中断由硬件而非软件引起。</p></blockquote><h3 id="7-2-中断处理程序"><a href="#7-2-中断处理程序" class="headerlink" title="7.2 中断处理程序"></a>7.2 中断处理程序</h3><p>在处理中断的时候，内核会执行一个函数。该函数名为中断处理程序<code>(interrupt handler)</code>，或者叫中断服务例程<code>(interrupt service routine, ISR)</code>。产生中断的每个设备都有一个相应的中断处理程序。这个程序是它设备驱动的一部分。</p><p>中断程序与普通的函数不同的方面在于，中断程序要按照特定的类型进行声明，以便内核能够以标准的方式传递处理信息。</p><blockquote><p>中断处理程序不是和特定设备关联，而是和特定中断关联的。如果一个设备可以产生多种不同的中断，那么该设备就对应多个中断处理程序，相应的，设备的驱动程序也就需要准备多个这样的函数。</p></blockquote><h3 id="7-3-上半部分与下半部分对比"><a href="#7-3-上半部分与下半部分对比" class="headerlink" title="7.3 上半部分与下半部分对比"></a>7.3 上半部分与下半部分对比</h3><p>中断程序的运行速度与其能完成的工作量是抵触的。所以为了分析到这两个矛盾的均衡点，我们将中断处理切分为两个部分：中断处理程序（top half），接收到中断后就开始执行。但只进行有严格时限的工作，例如对接受的中断进行应答或者复位硬件。能够稍微推迟的工作都会被推迟到下半部分去。此后在适当的时机，下半部分会被开中断执行。</p><blockquote><p>以网卡为例，网卡接收到来自网络的数据包时需要通知内核。为例优化网络吞吐量和传输周期，避免超时，网卡需要立即中断，并希望内核快速应答。这时中断开始执行，通知硬件拷贝网络数据包到内存，然后读取网卡更多的数据包。这些任务是很紧急的。因为网卡的缓冲区固定，所以拷贝工作一旦延迟，就会导致网卡缓存溢出，后续到来的报文只能丢弃。当网络数据包拷贝到内存上后，中断的任务也就完成了。这时可以将控制权交还给中断原来运行的程序。处理数据包的工作可以在下半部运行。（下半部在第八章详述）</p></blockquote><h3 id="7-4-注册中断处理程序"><a href="#7-4-注册中断处理程序" class="headerlink" title="7.4 注册中断处理程序"></a>7.4 注册中断处理程序</h3><p>驱动程序可以通过<code>request_irq()</code>函数注册一个中断处理程序（声明在<code>linux/interrupt.h</code>中）。并且激活给定的中断线，以处理中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __must_check</span><br><span class="line">request_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span><br></pre></td></tr></table></figure><p>第一个形参表示要分配的中断号。对于大多数设备来说，这个值或者是探测获取，或者通过编程动态决定。</p><p>第二个形参<code>irq_handler_t</code>是一个指针，指向实际的中断处理程序。只要操作系统接收到中断，该函数就被调用。<code>handler</code>的函数接受两个形参并具有返回值，我们将在后面讨论。</p><h4 id="7-4-1-中断处理程序标志"><a href="#7-4-1-中断处理程序标志" class="headerlink" title="7.4.1 中断处理程序标志"></a>7.4.1 中断处理程序标志</h4><p>第三个参数<code>flags</code>可以为0，或者为<code>interrupt.h</code>中的一个或多个标志位掩码。这些标志中最重要的是：</p><p>IRQF_DISABLED——该标志在设置后，要求内核在处理中断应用程序本身期间要禁止其他所有的中断 。多数中断进程不会设置该位</p><p>IRQF_SAMPLE_RANDOM——该标志表明设备产生的中断对内核墒池有贡献，内核墒池提供从各种事件导出的随机数。若指定该标志，则该设备的中断时间间隔就会作为墒填入到墒池。如果设备产生中断的速率不可预知，那么可以成为一个很好的墒源</p><p>IRQF_TIMER——该标志是特别为系统定时器中断处理准备的。</p><p>IRQF_SHARED——标志表明可以在多个中断处理程序之间共享中断线。在同一个给定线上注册的每个处理程序必须指定该标志，否则每条线上只能有一个处理程序。</p><p>第四个参数<code>name</code>是与中断相关设备的ASCII文本表示。</p><p>第五个参数<code>dev</code>用来共享中断线。当一个中断处理程序需要释放时，dev将提供唯一的标志信息<code>cookie</code>，以便从共享中断线的诸多中断处理程序中删除指定的那一个。无需共享时设为<code>NULL</code>即可。另外，内核每次调用中断处理程序时都会将这个指针传给它。这个指针是唯一的，能在中断处理程序中被用到。</p><p><code>request_irq()</code>成功执行会返回0，若返回非0值，则证明有错误发生。该种情况下，指定的中断处理程序不会被注册。该函数也可能会睡眠，<strong>所以不能在中断上下文或者其他不允许阻塞的代码中调用该函数。</strong></p><blockquote><p>在注册的过程中，内核需要在<code>/proc/irq</code>文件中创建一个与中断对应的选项。调用的是<code>proc_mkdir()</code>来实现。该函数调用<code>proc_create()</code>对新的profs项进行设置。而<code>proc_create()</code>会调用函数<code>kmalloc()</code>分配内存。而函数<code>kmalloc()</code>是可以睡眠的。这也就是<code>request_irq()</code>函数会导致堵塞的原因。</p></blockquote><h4 id="7-4-2-释放中断处理程序"><a href="#7-4-2-释放中断处理程序" class="headerlink" title="7.4.2 释放中断处理程序"></a>7.4.2 释放中断处理程序</h4><p>卸载驱动程序时需要同时卸载相应的中断处理程序，并释放中断线。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev)</span></span></span><br></pre></td></tr></table></figure><p>如果中断线没有共享，那么函数删除处理程序的同时会将中断线禁用。如果中断线共享，则仅删除<code>dev</code>对应的处理程序。而对于共享中断线，需要唯一信息来区分上面的多个处理程序，不管哪种情况下，如果<code>dev</code>非空，它都需要删除与其匹配的处理程序</p><h3 id="7-5-编写中断程序"><a href="#7-5-编写中断程序" class="headerlink" title="7.5 编写中断程序"></a>7.5 编写中断程序</h3><h4 id="7-5-1-共享的中断处理程序"><a href="#7-5-1-共享的中断处理程序" class="headerlink" title="7.5.1 共享的中断处理程序"></a>7.5.1 共享的中断处理程序</h4><p>共享的处理程序与非共享的处理程序在注册和运行方式上比较相似，其差异主要有三处：</p><ul><li><code>request_irq()</code>的参数<code>flags</code>必须设置为<code>IRQF_SHARED</code></li><li>对于每个注册的中断处理程序来说，dev参数必须唯一。指向任意结构设备指针就可以满足其要求：但通常会选择设备结构。</li><li>中断处理程序必须能够区分设备是否真的产生中断，这需要硬件以及处理程序中相关逻辑的支持。如果硬件不支持这一功能，中断处理程序会束手无策。它没办法知道是对应设备发出中断，还是共享中断线的其他设备发出中断。</li></ul><p>所有共享中断线的程序都必须满足以上要求。只要有一个设备没有按规则共享，那么中断线就无法共享。</p><h4 id="7-5-2-中断处理程序实例"><a href="#7-5-2-中断处理程序实例" class="headerlink" title="7.5.2 中断处理程序实例"></a>7.5.2 中断处理程序实例</h4><p>（参考价值不大，掠过）</p><h3 id="7-6-中断上下文"><a href="#7-6-中断上下文" class="headerlink" title="7.6 中断上下文"></a>7.6 中断上下文</h3><p>当执行一个中断时，内核处于中断上下文中，中断上下文与进程上下文不同。进程上下文可以睡眠，也可以调用调度程序。而中断上下文与进程没有什么瓜葛。与current宏不相关。因为没有后备进程，所以中断上下文不可以被睡眠。因此不能从中断上下文调用一些函数。</p><p>中断上下文具有比较严格的时间限制，因为它打断了其他代码（甚至可能是其他中断线的另一中断程序），所以中断上下文应迅速，简洁。尽量不要用循环去处理繁重的工作。这一点非常重要。因此要将下半部分分离，在更适合的情况下执行。</p><p>中断处理程序栈的设置是一个配置选项。从2.6内核开始，可以配置将内核栈的大小从两页减少到一页，以减轻内存压力。所以中断处理程序要尽量节省内核栈空间。</p><h3 id="7-7-中断处理机制的实现"><a href="#7-7-中断处理机制的实现" class="headerlink" title="7.7 中断处理机制的实现"></a>7.7 中断处理机制的实现</h3><p>中断处理十分依赖体系结构。当设备产生中断时，会通过总线将信号发送给中断控制器，如果中断总线时激活的，那么中断控制器就会将中断发送给处理器。（在大多体系结构中，这一工作就是在某一特定管脚发送一个电平信号。）处理器接受到中断信号后会立刻停止自己正在做的事情并且关闭中断系统，跳跃到中断处理程序的入口点开始执行代码。</p><p>对于每条中断线，处理器都会跳到对应的一个唯一位置，这样内核就能知道所接收中断的IRQ号了。初始入口点只是在栈中保存该中断号，并存放当前寄存器的值。然后内核调用函数<code>do_IRQ()</code>。从这里开始执行中断。这个函数的声明为<code>unsigned int do_IRQ(struct pt_regs regs)</code></p><p>因为C的调用惯例是将函数参数放在栈顶，因此<code>pt_regs</code>结构包含了原始寄存器。这些值是以前在汇编入口例程中保存在栈中的。中断的值也会得到保存。所以<code>do_IRQ()</code>可以将这些提取出来。</p><p>提取出中断号后，<code>do_IRQ()</code>对接受的中断进行应答，通过<code>mask_and_ack_8259A()</code>来完成的。然后调用<code>handle_irq_event()</code>来运行中断线所安装的中断处理程。具体流程看下面三个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">irqreturn_t</span> <span class="title">handle_irq_event</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">irqreturn_t</span> ret;</span><br><span class="line"></span><br><span class="line">        desc-&gt;istate &amp;= ~IRQS_PENDING;</span><br><span class="line">        irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">        raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line"></span><br><span class="line">        ret = handle_irq_event_percpu(desc);</span><br><span class="line"></span><br><span class="line">        raw_spin_lock(&amp;desc-&gt;lock);</span><br><span class="line">        irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">irqreturn_t</span> <span class="title">handle_irq_event_percpu</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">irqreturn_t</span> retval;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        retval = __handle_irq_event_percpu(desc, &amp;flags);</span><br><span class="line"></span><br><span class="line">        add_interrupt_randomness(desc-&gt;irq_data.irq, flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!noirqdebug)</span><br><span class="line">                note_interrupt(desc, retval);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">irqreturn_t</span> __handle_irq_event_percpu(struct irq_desc *desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">irqreturn_t</span> retval = IRQ_NONE;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> irq = desc-&gt;irq_data.irq;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">        record_irq_time(desc);</span><br><span class="line"></span><br><span class="line">        for_each_action_of_desc(desc, action) &#123;</span><br><span class="line">                <span class="keyword">irqreturn_t</span> res;</span><br><span class="line"></span><br><span class="line">                trace_irq_handler_entry(irq, action);</span><br><span class="line">                res = action-&gt;handler(irq, action-&gt;dev_id);</span><br><span class="line">                trace_irq_handler_exit(irq, action, res);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (WARN_ONCE(!irqs_disabled(),<span class="string">&quot;irq %u handler %pS enabled interrupts\n&quot;</span>,</span><br><span class="line">                              irq, action-&gt;handler))</span><br><span class="line">                        local_irq_disable();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">                <span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Catch drivers which return WAKE_THREAD but</span></span><br><span class="line"><span class="comment">                         * did not set up a thread function</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (unlikely(!action-&gt;thread_fn)) &#123;</span><br><span class="line">                                warn_no_thread(irq, action);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        __irq_wake_thread(desc, action);</span><br><span class="line">      </span><br><span class="line">                        <span class="comment">/* Fall through - to add to randomness */</span></span><br><span class="line">                <span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">                        *flags |= action-&gt;flags;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                retval |= res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在7.4.1中我们提到过，<code>IRQF_DISABLE</code>表示处理程序必须在中断禁止的情况下运行。因为处理器禁止中断，这里需要将他们打开。每个潜在的处理程序通过<code>for_each_action_of_desc</code>依次执行，如果这条线不是共享的，第一次执行后就会退出循环，否则所有的处理程序都要被执行。之后调用函数<code>add_interrupt_randomness</code>去处理循环中出现的flags。(这个函数主要适用了中断时间间隔为随机数产生器产生熵)。这个函数返回到<code>do_IRQ</code>函数中，函数清理工作并发挥到初始入口点，然后再从这个入口点跳到函数<code>ret_from_intr()</code>。</p><p><code>ret_from_intr()</code>例程类似于初始入口代码，使用汇编语言编写，例程检查重新调度是否正在挂起（也就是设置了<code>need_resched</code>）。如果重新调度正在挂起，并且内核正在返回用户空间（也就是用户进程被中断）。那么<code>schedule()</code>被调用。如果内核本身被中断，也就是内核在返回内核空间，只有当<code>preempt_count=0</code>时，<code>schedule()</code>才会被调用。否则抢占内核就是不安全的。</p><p>在<code>schedule()</code>返回后，如果没有挂起的工作，那么原来的寄存器就被恢复，内核恢复到曾经中断的点。</p><blockquote><p>在x86上，初始的汇编例程位于<code>arch/x86/kernel/entry_64.S</code>（32位位于<code>entry_32.S</code>），C方法位于<code>arch/x86/kernel/irq.c</code>其他所支持的接口与此类似。</p></blockquote><h3 id="7-8-proc-interrupts"><a href="#7-8-proc-interrupts" class="headerlink" title="7.8 /proc/interrupts"></a>7.8 /proc/interrupts</h3><p><code>procfs</code>是一个虚拟的文件系统，它只存在于内核的内存，安装在/proc目录，在<code>procfs</code>中读写文件都要调用内核函数，用于模拟真实文件中的读和写。下面来看看/proc/interrupts文件，这个文件中存放的是系统中与中断相关的信息。下面是本机输出的信息：</p><blockquote><p>CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       CPU8       CPU9       CPU10      CPU11</p><p>8:    0          0          0          0          0          0          0          0          0          0          0          0   IO-APIC   8-edge      rtc0<br>  9:          0          0          0          0          0          0          0          0          0          0          0          0   IO-APIC   9-fasteoi   acpi<br> 24:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 805306368-edge               virtio0-config<br> 25:         0          0          0        211          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 805306369-edge             virtio0-requests<br> 26:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 1073741824-edge             virtio1-config<br> 27:         0          0          0          0          0     284035          0          0          0          0          0          0  Hyper-V PCIe MSI 1073741825-edge       virtio1-requests<br> 28:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 1610612736-edge             virtio2-config<br> 29:         0          0          0          0          0          0          0    4381354          0          0          0          0  Hyper-V PCIe MSI 1610612737-edge      virtio2-requests<br> 30:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 1744830464-edge              virtio3-config<br> 31:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 1744830465-edge              virtio3-requests<br> 32:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI -2147483648-edge             virtio4-config<br> 33:         0          0          0          0          0          0          0          0          0          0          0          3  Hyper-V PCIe MSI -2147483647-edge             virtio4-requests<br> 34:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 1744830464-edge              virtio5-config<br> 35:         0          3          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 1744830465-edge              virtio5-requests<br> 36:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 268435456-edge                virtio6-config<br> 37:         0          0          0          3          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI 268435457-edge                 virtio6-requests<br> 38:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI -536870912-edge                 virtio7-config<br> 39:         0          0          0          0          0          0          0          0          0          0          0          0  Hyper-V PCIe MSI -536870911-edge                virtio7-requests<br>NMI:       0          0          0          0          0          0          0          0          0          0          0          0   Non-maskable interrupts<br>LOC:       0          0          0          0          0          0          0          0          0          0          0          0   Local timer interrupts<br>SPU:       0          0          0          0          0          0          0          0          0          0          0          0   Spurious interrupts<br>PMI:       0          0          0          0          0          0          0          0          0          0          0          0   Performance monitoring interrupts<br>IWI:        0          0          0          0          0          0          0          0          0          0          0          0   IRQ work interrupts<br>RTR:       0          0          0          0          0          0          0          0          0          0          0          0   APIC ICR read retries<br>RES:     238566     160419     826807      87772     133205     292473    1405401       4125     300538      17385    1331221     127239   Rescheduling interrupts<br>CAL:      16282        553        334        193        172        445        229        170        272        176        536        166   Function call interrupts<br>TLB:          0          0          0          0          0          0          0          0          0          0          0          0   TLB shootdowns<br>HYP:      85674       1242        304    1427827    2050789      13810      83381     167424      20897      93224      13809          0   Hypervisor callback interrupts<br>HRE:          0          0          0          0          0          0          0          0          0          0          0          0   Hyper-V reenlightenment interrupts<br>HVS:      98089       1939      67599     245456     408649     535351      67820      44652     991468       5533     956024       3248   Hyper-V stimer0 interrupts<br>ERR:          0<br>MIS:          0<br>PIN:          0          0          0          0          0          0          0          0          0          0          0          0   Posted-interrupt notification event<br>NPI:          0          0          0          0          0          0          0          0          0          0          0          0   Nested posted-interrupt event<br>PIW:          0          0          0          0          0          0          0          0          0          0          0          0   Posted-interrupt wakeup event</p></blockquote><p>第一列是中断线，第二列开始是每个CPU接受了中断数目的计数器，中断计数器后面标识了处理这个中断的中断控制器。最后一列则是产生中断的设备。这个名字是通过参数<code>devname</code>提供给函数<code>request_irq()</code>的。如果中断是共享的，则中断线上注册的所有设备都会列出来。</p><blockquote><p>procfs的代码位于fs/proc中，这些函数与体系结构相关。其中提供/proc/interrupts的函数叫做show_interrupts。</p></blockquote><h3 id="7-9-中断控制"><a href="#7-9-中断控制" class="headerlink" title="7.9 中断控制"></a>7.9 中断控制</h3><p>Linux内核提供了一组接口用于操作机器上的中断状态。这些接口提供了能够禁止当前处理器的中断系统或者屏蔽一整条中断线的能力。这些接口位于<code>&lt;asm/system.h&gt;</code>以及<code>&lt;asm/irq.h&gt;</code>中。</p><p>一般来说，中断控制系统归根结底是要提供同步。通过禁止中断来保证某个中断处理程序不会抢占当前代码。此外也可以用禁止中断来禁止内核抢占。但是这两方面都没有提供防止来自其他处理器的并发访问的保护机制。所以为了避免其他处理器访问共享数据，内核还需要获取某种锁，这种锁要提供本地以及其他中断程序的并发访问。</p><h4 id="7-9-1-禁止和激活中断"><a href="#7-9-1-禁止和激活中断" class="headerlink" title="7.9.1 禁止和激活中断"></a>7.9.1 禁止和激活中断</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br><span class="line">local_irq_enable();</span><br></pre></td></tr></table></figure><p>这两个函数通常使用对应体系的汇编函数实现。实际上基本上是对clear和set允许中断标志的汇编调用。在发出中断的处理器上它们将禁止和激活中断的传递。</p><p>如果在调用<code>local_irq_disable()</code>之前已经禁止了中断，那么无条件的禁止中断可能会带来风险。对于某些情况来说，更需要内核提供一种恢复中断的机制。也就是要将中断状态保存，在特定情况下将其恢复。幸运的是，内核中也提供了相应的方式来将内核恢复到原来的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_irq_save(flags);</span><br><span class="line">local_irq_restore(flags)</span><br></pre></td></tr></table></figure><p>上面这两种方法至少部分要使用宏的方式实现，所以在我们看到的形参是传值而非传址的。该参数包含具体体系结构的数据（也就是中断的状态）。flag值必须驻留在同一栈帧中。所以对<code>local_irq_save(flags)</code>和<code>local_irq_restore(flags)</code>的调用必须在统一函数中进行。</p><h4 id="7-9-2-禁止指定中断栈"><a href="#7-9-2-禁止指定中断栈" class="headerlink" title="7.9.2 禁止指定中断栈"></a>7.9.2 禁止指定中断栈</h4><p>有些情况下，我们并不需要禁止整个处理器上所有的中断，而是只需要禁用整个系统中的某一条中断线。（例如想在对中断状态操作之前禁止设备终端的传递）。为此，Linux提供了以下几种接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq_nosync</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchornize_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br></pre></td></tr></table></figure><p>前两个函数禁止中断控制器上指定的中断线，即禁止给定中断向系统中所有处理器的传递。另外，函数只有在当前正在执行的所有处理程序完成后，<code>disable_irq</code>才可以返回。所以说，调用者不仅要确保不再指定线上传递新的中断，同时还要确保所有已经开始执行的处理程序全部退出。而函数<code>disable_irq_nosync()</code>则不会等待当前中断处理程序执行完毕。</p><p>函数<code>synchornize_irq()</code>等待一个特定的中断处理程序的退出。如果该处理程序正在执行，那么该函数必须退出后才能返回。</p><p>对这些函数的调用可以嵌套。但在一条指定的中断线上，对<code>disable_irq</code>和<code>disable_irq_nosync</code>的每次调用，都要相应的调用一次<code>enable_irq()</code>。只有最后一次对<code>enable_irq()</code>的调用完成后，才真正重新激活了中断线。</p><p>这三个函数可以从中断或进程上下文中调用，而且不会睡眠，但如果从中断上下文调用的时候就要小心。防止处理程序的中断线在进行处理时被屏蔽。</p><blockquote><p>禁止中断线相当于禁止了线上所有设备的中断传递，因此，使用新设备的驱动程序应该倾向于不使用这些接口，特别是PCI总线，所有设备应该共享中断。所以根本不应该用这些接口。</p></blockquote><h4 id="7-9-3-中断系统的状态"><a href="#7-9-3-中断系统的状态" class="headerlink" title="7.9.3 中断系统的状态"></a>7.9.3 中断系统的状态</h4><p>Linux为了解中断系统的状态提供了几种接口：</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>irqs_disable()</td><td>本地处理器的中断系统被禁止时返回非0</td></tr><tr><td>in_interrupt()</td><td>内核处于任何形式的中断时返回非0（中断处理或者下半部都算）</td></tr><tr><td>in_irq()</td><td>内核确实在执行中断处理程序中时返回非零</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux内核设计与实现第五章—系统调用&quot;&gt;&lt;a href=&quot;#Linux内核设计与实现第五章—系统调用&quot; class=&quot;headerlink&quot; title=&quot;Linux内核设计与实现第五章—系统调用&quot;&gt;&lt;/a&gt;Linux内核设计与实现第五章—系统调用&lt;/h1&gt;&lt;h3 id=&quot;5-1-与内核通讯&quot;&gt;&lt;a href=&quot;#5-1-与内核通讯&quot; class=&quot;headerlink&quot; title=&quot;5.1 与内核通讯&quot;&gt;&lt;/a&gt;5.1 与内核通讯&lt;/h3&gt;&lt;p&gt;中间层位于用户空间进程与硬件设备之间，由系统调用添加。该层的作用主要有三个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为用户空间提供硬件的抽象接口，可以对用户屏蔽不同硬件之间的差异&lt;/li&gt;
&lt;li&gt;保证了系统的稳定性与安全性，内核可以基于权限，用户类型等对需要进行的访问进行裁决，防止它做出对系统有危害的事情&lt;/li&gt;
&lt;li&gt;为运行在虚拟内存中的进程提供统一接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统调用是用户除了系统异常和陷入外访问内核的唯一手段和唯一合法入口。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux内核设计与实现" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Linux内核" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="系统调用" scheme="http://yokeso.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核设计与实现ch4  进程调度</title>
    <link href="http://yokeso.github.io/2023/05/22/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch4/"/>
    <id>http://yokeso.github.io/2023/05/22/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch4/</id>
    <published>2023-05-22T07:11:22.000Z</published>
    <updated>2023-06-27T15:12:43.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核设计与实现第四章-进程调度"><a href="#Linux内核设计与实现第四章-进程调度" class="headerlink" title="Linux内核设计与实现第四章  进程调度"></a>Linux内核设计与实现第四章  进程调度</h1><p>进程调度程序可以被看做是一个在可运行态进程之间分配有限处理器时间资源的内核子系统。也是Linux多任务的基础。只有有了合理的调度，系统资源才能最大化的发挥作用。多进程才会有并发执行的效果。</p><span id="more"></span><h3 id="4-1-多任务"><a href="#4-1-多任务" class="headerlink" title="4.1 多任务"></a>4.1 多任务</h3><p>多任务系统可以分为两类：非抢占式多任务（<code>cooperative multitasking</code>），和抢占式多任务（<code>preemptive multitasking</code>）。</p><p>在抢占式的多任务模式下，由调度程序来决定什么时候停止一个进程的运行，以便其他程序能够得到执行的机会。也就是抢占。进程在被抢占之前的时间是预先设置好的，也就是我们通常说的时间片(<code>timeslice</code>)。</p><p>而相反的是，在非抢占式的多任务模式下，除非进程自己停止运行，否则将会一直执行。进程主动挂起自己的操作成为让步(<code>yielding</code>)。理想情况下，进程会做出让步，以便使每个可运行进程都享有足够的处理器时间。但这种方式缺点很多：调度程序无法对进程独占处理器的时间做出规定。这样就会导致进程独占处理器的时间超乎预料。而且一个决不让步的进程（hang住的进程）就能使得处理器崩溃。所以说Linux一开始就使用的是抢占式多任务。</p><h3 id="4-2-Linux的进程调度"><a href="#4-2-Linux的进程调度" class="headerlink" title="4.2 Linux的进程调度"></a>4.2 Linux的进程调度</h3><p>从内核版本2.5开始，进程调度采用了一种叫做O(1)调度程序的新程序。这个明明也是因为其算法行为来命名的。</p><p>O(1)算法虽然在数以十计的多处理器环境下表现了近乎完美的性能以及可扩展性，但是对于响应时间敏感的程序（交互进程）却存在不足。所以虽然在大服务器上工作负载很理想，但是在桌面系统下表现不佳。所以在2.6版本开发初期引入了一种新的进程调度算法，也就是反转楼梯最后期限调度算法（<code>Rotating Staircase Deadlilne scheduler</code> RSDL）。该算法吸取队列理论，引入了公平调度的概念。并且在2.6.23版本中替代了O(1)调度算法。被称为“完全公平调度算法”（CFS）</p><h3 id="4-3-策略"><a href="#4-3-策略" class="headerlink" title="4.3 策略"></a>4.3 策略</h3><h4 id="4-3-1-I-O消耗型和处理器消耗型的进程"><a href="#4-3-1-I-O消耗型和处理器消耗型的进程" class="headerlink" title="4.3.1 I/O消耗型和处理器消耗型的进程"></a>4.3.1 I/O消耗型和处理器消耗型的进程</h4><p>进程可以分为两种：I/O消耗型和处理器消耗型。</p><p>I/O消耗型进程指进程的大部分时间都在提交I/O请求或者等待I/O请求，因此进程经常处于可运行状态。但通常都是运行短短的一会，因为进程在等待更多的I/O请求时最后总会堵塞。例如GUI程序，即使不读取或者写入硬盘，大多数时间中也在等待来自鼠标或者键盘的用户交互操作。</p><p>处理器消耗型的进程把大多数时间都用在执行代码上。除非被抢占，否则通常一直不停运行。因为他们没有过多的I/O请求。但是，因为他们不属于I/O驱动的类型，所以从系统响应速度考虑，系统不应该让他们经常运行。所以对于这类的程序，策略调度往往是尽量降低他们的调度频率，从而延长其运行时间。处理器消耗型最极端的例子就是无线循环的执行。</p><p>但这种分类并非绝对的。所以调度策略通常要在这两个矛盾的目标中寻找平衡：进程响应时间短和最大系统利用率。为了满足需求，调度进程会使用一套复杂的算法来保证进程被公平对待。Linux主要对进程的响应做了优化，但是也没有忽略处理器消耗型的进程。</p><h4 id="4-3-2-进程优先级"><a href="#4-3-2-进程优先级" class="headerlink" title="4.3.2 进程优先级"></a>4.3.2 进程优先级</h4><p>调度算法中最基本的一类就是基于优先级的调度。其通常做法是优先级高的进程先运行，优先级低的进程后运行。相同优先级的进程按照轮转方式进行调度。在某些系统中，优先级高的进程使用的时间片也更长，调度程序总会选择时间片未用尽且优先级最高的进程运行。用户和操作系统都可以通过设置进程的优先级来影响系统的调度。</p><p>Linux采用了两种不同的优先级，第一种是nice值，其范围为-20——19，默认为0，越大的nice值代表着更低的优先级。也就是说，低nice值的进程可以获得更多的处理器时间。在Linux中，nice值代表时间片的比例。可以通过<code>ps-el</code>查看操作系统中的进程列表，其中标记着<code>NI</code>的就是进程对应的nice值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@fasii:~# ps -el</span><br><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0       1       0  0  80   0 - 42400 ep_pol ?        00:00:01 systemd</span><br><span class="line">1 S     0       2       0  0  80   0 -     0 kthrea ?        00:00:00 kthreadd</span><br><span class="line">1 I     0       3       2  0  60 -20 -     0 rescue ?        00:00:00 rcu_gp</span><br><span class="line">1 I     0       4       2  0  60 -20 -     0 rescue ?        00:00:00 rcu_par_gp</span><br><span class="line">1 I     0       6       2  0  60 -20 -     0 worker ?        00:00:00 kworker/0:0H-kblockd</span><br><span class="line">1 I     0       8       2  0  60 -20 -     0 rescue ?        00:00:00 mm_percpu_wq</span><br><span class="line">1 S     0       9       2  0  80   0 -     0 smpboo ?        00:00:00 ksoftirqd/0</span><br><span class="line">1 I     0      10       2  0  80   0 -     0 rcu_gp ?        00:00:01 rcu_sched</span><br><span class="line">1 S     0      11       2  0 -40   - -     0 smpboo ?        00:00:00 migration/0</span><br><span class="line">5 S     0      12       2  0   9   - -     0 smpboo ?        00:00:00 idle_inject/0</span><br><span class="line">1 I     0      13       2  0  80   0 -     0 worker ?        00:00:00 kworker/0:1-events_freezable</span><br><span class="line">1 S     0      14       2  0  80   0 -     0 smpboo ?        00:00:00 cpuhp/0</span><br></pre></td></tr></table></figure><p>第二种范围是实时优先级，其值是可以配置的，默认情况的范围是0-99，与nice意义恰好相反，越高的实时优先级代表进程的优先级也就越高。任何实时进程的优先级都高于普通进程的优先级。所以实时优先级和nice处于两个不同的范畴。Linux实时优先级参考了Unix的相关标准，可以通过命令<code>ps-el</code>查看，对应的实时优先级在<code>rtprio(PRI)</code>列下。进程对应列显示为-的代表其不是实时进程。</p><h4 id="4-3-3-时间片"><a href="#4-3-3-时间片" class="headerlink" title="4.3.3 时间片"></a>4.3.3 时间片</h4><p>时间片是一个能代表着进程在被抢占之前能够运行的时间的数值，调度策略必须规定一个默认的时间片，时间片过长会让人觉得系统无法并发执行程序，时间片过短则会明显增大进程切换带来的处理器耗时。这里也能显示出I/O消耗型程序和处理器消耗型的进程之间的矛盾：I/O消耗型不需要长时间片，但是处理器消耗型进程则希望越长越好。（时间片越长cache命中率更高）</p><p>Linux的CFS调度器没有直接将时间片分配到进程，而只是将从处理器的使用比划分给进程。这也就是说，进程所获得的处理器时间其实与系统负载密切相关。这个比例还会进一步受到nice值的影响。Linux中的CFS调度器的抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比当前进程小，则新进程立刻投入运行，抢占当前进程。否则，将推迟其运行。</p><h3 id="4-4-Linux调度算法"><a href="#4-4-Linux调度算法" class="headerlink" title="4.4 Linux调度算法"></a>4.4 Linux调度算法</h3><h4 id="4-4-1-调度器类"><a href="#4-4-1-调度器类" class="headerlink" title="4.4.1 调度器类"></a>4.4.1 调度器类</h4><p>Linux调度器是以模块方式提供的，这样的目的是允许不同类型的进程能够针对性的选择调度算法。</p><p>这种结构被称为调度器类（<code>scheduler classes</code>）。它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴内的进程。每个调度器都有一个优先级，基础的调度器代码定义在<code>kernel/sched.c</code>中，它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类会胜出，来执行下面要执行的程序。</p><p>完全公平调度（CFS）是针对普通进程的调度类，在Linux中称为<code>SCHED_NORMAL</code>，其具体实现在<code>kernel/sched/fair.c</code>中。</p><h4 id="4-4-2-Unix系统中的进程调度"><a href="#4-4-2-Unix系统中的进程调度" class="headerlink" title="4.4.2 Unix系统中的进程调度"></a>4.4.2 Unix系统中的进程调度</h4><p>在讨论公平调度算法之前，我们不妨先了解以下传统Unix系统的调度过程。在Unix系统上，优先级以nice值形式输出给用户空间，听起来很简单，但是却会导致许多反常问题。</p><ul><li>若将nice值映射到时间片，可能会导致进程无法切换最优运行。给定高nice值的进程往往是后台进程，多为计算密集型。而普通优先级的进程多为前台用户任务。针对时间片100ms来说，两个nice值为0的进程会分别获得50ms运行时间，但是两个nice值为19的进程却只会分别获得5ms的运行时间。这种时间片分法严重浪费了CPU资源。</li><li>第二个问题涉及相对nice值。假设我们有两个进程，nice值分别为0和1的时候两个时间片为100和95,相差不会很大，但是18和19的两个nice值就会导致两个时间片为5ms和10ms。处理器的时间差距在两倍以上。但是nice值通常使用相对值，也就是在原值上增加或者减少。</li><li>第三个问题是执行nice值到时间片的映射，就要能分配一个绝对时间片。在大多数系统中，时间片的要求是定时器节拍的整数倍。其次，连续的nice值映射到时间片，其差别范围在1ms~10ms之间。最后，时间片要随着定时器节拍改变。（具体见第11章）</li><li>第四个问题是基于优先级的调度器为了优化交互任务而唤醒相关进程的问题。为了能让进程尽快投入与逆行，对新唤醒的进程要提升其优先级。即使它的时间片用尽。这种情况确实能提升交互任务的性能。但是也会导致一些特殊的睡眠/唤醒用例一些优待。使得给定进程打破公平原则，损害其他进程的利益。</li></ul><p>上面的大多数问题均可以通过对传统的unix调度器进行改造来解决，比如：将nice值几何增加而非算数增加，采用新的度量机制将nice值到时间片的映射与定时器节拍隔离。但是这些解决方案都规避了问题的实质：分配绝对的时间片引发的固定的切换频率。所以CFS做了根本性的重新设计：完全摒弃时间片而分配给进程一个处理器的比重。这样来确保进程调度中具有恒定的公平性而且将切换频率置于不断变动中。</p><h4 id="4-4-3-公平调度"><a href="#4-4-3-公平调度" class="headerlink" title="4.4.3 公平调度"></a>4.4.3 公平调度</h4><p>CFS的出发点基于一个简单的概念：进程调度的效果应该如同一个理想中的完美多任务处理器：每个进程能获得1/n的处理器时间。同时，我们调度给这n个进程同样多的运行时间。</p><p>当然，上述理想并非现实：在一个处理器上无法同时运行多个进程。而且进程无限小的周期也是低效的。进程的换入换出的本身存在消耗，而且影响缓存的效率。CFS充分考虑了这些带来的额外消耗，允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。而不再采用给每个进程分配时间片的做法。CFS以所有可运行进程总数为基础，计算出一个进程应该运行多久，nice值则用来作为进程获得处理器运行比的权重。这样，每个进程都按其权重在全部可运行线程中所占比例的时间片来运行。为了准确计算时间片，CFS为完美多任务中的无限小调度周期的近似值设立了一个目标，称作目标延迟。越小的调度周期也就代表着越好的交互性，也就更接近完美多任务。代价就是频繁切换带来的高开销以及缓存换入换出带来的系统吞吐能力变差。</p><p>从上面式子中可以看到，当任务数量趋于无限时，他们各自所获得的处理器使用比和时间均将趋于0。其切换损耗也就越来越不可接受。为此，CFS引入了进程获得的时间片底线：最小粒度。其默认值为1ms。也就是说，无论存在多少个进程等待运行，每个进程最少也能获得1ms的运行时间。这样也就确保了消耗被限制在一定的范围内。</p><p>同样再来看nice值：比如设定nice值为5的进程是nice值为5的进程的1/3。以20ms的时间片为例，两个nice值为0和5进程能分配到的时间是15ms和5ms，两个nice值为10和15进程能分配到的时间也是15ms和5ms。可见，在CFS中，绝对的nice值不再影响调度决策，只有相对值才影响处理器时间的分配比例。</p><h3 id="4-5-Linux调度实现"><a href="#4-5-Linux调度实现" class="headerlink" title="4.5 Linux调度实现"></a>4.5 Linux调度实现</h3><p>Linux调度实现的相关代码位于<code>kernel/sched/fair.c</code>中，我们主要关注四部分：</p><ul><li>时间记账</li><li>进程选择</li><li>调度器入口</li><li>睡眠和唤醒</li></ul><h4 id="4-5-1-时间记账"><a href="#4-5-1-时间记账" class="headerlink" title="4.5.1 时间记账"></a>4.5.1 时间记账</h4><p>所有调度器都必须对进程运行时间记账。每次系统节拍发生时，当前运行的进程的时间片都会减少一个节拍周期。当该进程的时间片减少到0时，就会被另一个尚未减到零的时间片的可运行进程抢占</p><ol><li><h5 id="调度器实体结构"><a href="#调度器实体结构" class="headerlink" title="调度器实体结构"></a>调度器实体结构</h5></li></ol><p>CFS不再拥有时间片的概念，但是也必须维护每个进程的时间记账。以此来确保每个进程只在公平分配给它的处理器时间内运行。CFS使用调度器实体结构（<code>&lt;linux/sched.h&gt; 的 struct sched_entity</code>中定义）来追踪进程记账。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>     <span class="title">load</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>         <span class="title">run_node</span>;</span>                 <span class="comment">// 用于连接到运行队列的红黑树中</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>       <span class="title">group_node</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>           on_rq;                    <span class="comment">// 是否已经在运行队列中</span></span><br><span class="line">  u64                    exec_start;               <span class="comment">// 开始统计运行时间的时间点</span></span><br><span class="line">  u64                    sum_exec_runtime;         <span class="comment">// 总共运行的实际时间</span></span><br><span class="line">  u64                    vruntime;                 <span class="comment">// 虚拟运行时间(用于红黑树的键值对比)</span></span><br><span class="line">  u64                    prev_sum_exec_runtime;    <span class="comment">// 总共运行的虚拟运行时间</span></span><br><span class="line">  u64                    last_wakeup;</span><br><span class="line">  u64                    avg_overlap;</span><br><span class="line">  u64                    nr_migrations;</span><br><span class="line">  u64                    start_runtime;</span><br><span class="line">  u64                    avg_wakeup;</span><br><span class="line">    ... <span class="comment">/*这里省略了很多变量， 只有设置了CONFIG_SCHEDSTATS时才启用*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符<code>struct task_struct</code>中。</p><ol><li><h5 id="虚拟实时"><a href="#虚拟实时" class="headerlink" title="虚拟实时"></a>虚拟实时</h5></li></ol><p>在 <code>struct sched_entity</code>中，<code>vruntime</code>变量存放的是进程的虚拟运行时间，该运行时间的计算使经过了所有可运行进程总数的标准化的。也就是被加权了的运行时间。这里的虚拟运行时间以ns为单位，所以<code>vruntime</code>与定时器节拍不再相关。</p><p>在<code>/kernel/sched/fair.c</code>中的<code>update_curr()</code>函数实现了记账功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Update the current task&#x27;s runtime statistics.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_curr</span><span class="params">(struct cfs_rq *cfs_rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> =</span> cfs_rq-&gt;curr;</span><br><span class="line">        u64 now = rq_clock_task(rq_of(cfs_rq));</span><br><span class="line">        u64 delta_exec;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!curr))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*获取最后一次修改负载后当前任务占用的运行总时间*/</span></span><br><span class="line">        delta_exec = now - curr-&gt;exec_start;</span><br><span class="line">        <span class="keyword">if</span> (unlikely((s64)delta_exec &lt;= <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        curr-&gt;exec_start = now;</span><br><span class="line"></span><br><span class="line">        schedstat_set(curr-&gt;statistics.exec_max,</span><br><span class="line">                      max(delta_exec, curr-&gt;statistics.exec_max));</span><br><span class="line"></span><br><span class="line">        curr-&gt;sum_exec_runtime += delta_exec;</span><br><span class="line">        schedstat_add(cfs_rq-&gt;exec_clock, delta_exec);</span><br><span class="line"></span><br><span class="line">        curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);</span><br><span class="line">        update_min_vruntime(cfs_rq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entity_is_task(curr)) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curtask</span> =</span> task_of(curr);</span><br><span class="line"></span><br><span class="line">                trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);</span><br><span class="line">                cgroup_account_cputime(curtask, delta_exec);</span><br><span class="line">                account_group_exec_runtime(curtask, delta_exec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        account_cfs_rq_runtime(cfs_rq, delta_exec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>update_curr()</code>计算了当前进程的执行时间，根据当前可运行进程总数对运行时间进行加权计算，最终将上述的权重值与当前运行进程的<code>vruntime</code>相加。并将其存放在了变量<code>delta_exec</code>中。这个函数由系统定时器周期性调用，无论进程处于可运行态还是堵塞态，根据这种方式，<code>vruntime</code>都可以准确测量给定进程的运行时间。并且可以知道谁应该是下一个被运行的进程。</p><blockquote><p>由于我使用的内核为5.4版本的代码，并没有书中写的__update_curr()函数，新的内核将这两个函数统一为一个函数了。但其流程没有什么变化。故直接按新内核进行描述</p></blockquote><h4 id="4-5-2-进程选择"><a href="#4-5-2-进程选择" class="headerlink" title="4.5.2 进程选择"></a>4.5.2 进程选择</h4><p>为了均衡虚拟运行时间，CFS选择了一个比较简单的规则：当需要选择下一个运行进程时，它会挑选一个具有最小<code>vruntime</code>的进程。这一节主要就来讨论如何实现选择<code>vruntime</code>最小的进程的。</p><p>CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小的<code>vruntime</code>值的进程。在红黑树中，通过键值检索到对应节点的速度与整个树的结点规模成指数比关系。</p><ol><li>挑选下一个任务</li></ol><blockquote><p>这里书上的代码与5.4代码有很大不同。我这里以5.4代码为例进行了分析。对原书感兴趣可以参考原书相应章节。</p></blockquote><p>假设有一个黑红树存储了系统所有可运行进程，那么节点的键值就是可运行进程的虚拟化时间。CFS期望找到所有进程中<code>vruntime</code>最小的那个。实现这一过程的函数为<code>__pick_next_entity()</code>，定义在<code>kernel/sched/fair.c</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *__<span class="title">pick_next_entity</span>(<span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">next</span> =</span> rb_next(&amp;se-&gt;run_node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!next)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rb_entry(next, struct sched_entity, run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以看到，5.4内核中调用了<code>rb_next(&amp;se-&gt;run_node)</code>来选择下一个任务。那再来看看<code>rb_next</code>的实现（位于<code>tools/lib/rbtree.c</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rb_node *<span class="title">rb_next</span><span class="params">(<span class="keyword">const</span> struct rb_node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RB_EMPTY_NODE(node))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we have a right-hand child, go down and then left as far</span></span><br><span class="line"><span class="comment">         * as we can.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;rb_right) &#123;</span><br><span class="line">                node = node-&gt;rb_right;</span><br><span class="line">                <span class="keyword">while</span> (node-&gt;rb_left)</span><br><span class="line">                        node=node-&gt;rb_left;</span><br><span class="line">                <span class="keyword">return</span> (struct rb_node *)node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No right-hand children. Everything down and left is smaller than us,</span></span><br><span class="line"><span class="comment">         * so any &#x27;next&#x27; node must be in the general direction of our parent.</span></span><br><span class="line"><span class="comment">         * Go up the tree; any time the ancestor is a right-hand child of its</span></span><br><span class="line"><span class="comment">         * parent, keep going up. First time it&#x27;s a left-hand child of its</span></span><br><span class="line"><span class="comment">         * parent, said parent is our &#x27;next&#x27; node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> ((parent = rb_parent(node)) &amp;&amp; node == parent-&gt;rb_right)</span><br><span class="line">                node = parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>rb_next()</code>获取的结果可能有三种：</p><ul><li>如果节点为空节点，直接返回空</li><li>如果节点存在右孩子，那么返回右子树下的最左叶子节点</li><li>递归向上访问父节点，返回最后一个节点作为右孩子的父节点。</li></ul><p>这样也就实现了下一个节点的选取。也就是说，新的内核中寻找的是<code>vrantime</code>排序后相邻的右侧第一个（case2）或者相邻的左侧第一个（case 1）。这里就显示出了与原书的区别。原书中寻找的进程是<code>vrantime</code>最小的那个。也就是整颗黑红树的最左侧叶子节点。</p><ol><li>向树中加入进程</li></ol><p>向书中插入进程发生在进程变更为可运行状态时或者是通过fork第一次创建进程时，是通过<code>enqueue_entity()</code>函数实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">bool</span> renorm = !(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATED);</span><br><span class="line">        <span class="keyword">bool</span> curr = cfs_rq-&gt;curr == se;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we&#x27;re the current task, we must renormalise before calling</span></span><br><span class="line"><span class="comment">         * update_curr().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (renorm &amp;&amp; curr)</span><br><span class="line">                se-&gt;vruntime += cfs_rq-&gt;min_vruntime;</span><br><span class="line"></span><br><span class="line">        update_curr(cfs_rq);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Otherwise, renormalise after, such that we&#x27;re placed at the current</span></span><br><span class="line"><span class="comment">         * moment in time, instead of some random moment in the past. Being</span></span><br><span class="line"><span class="comment">         * placed in the past could significantly boost this task to the</span></span><br><span class="line"><span class="comment">         * fairness detriment of existing tasks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (renorm &amp;&amp; !curr)</span><br><span class="line">                se-&gt;vruntime += cfs_rq-&gt;min_vruntime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When enqueuing a sched_entity, we must:</span></span><br><span class="line"><span class="comment">         *   - Update loads to have both entity and cfs_rq synced with now.</span></span><br><span class="line"><span class="comment">         *   - Add its load to cfs_rq-&gt;runnable_avg</span></span><br><span class="line"><span class="comment">         *   - For group_entity, update its weight to reflect the new share of</span></span><br><span class="line"><span class="comment">         *     its group cfs_rq</span></span><br><span class="line"><span class="comment">         *   - Add its new weight to cfs_rq-&gt;load.weight</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        update_load_avg(cfs_rq, se, UPDATE_TG | DO_ATTACH);</span><br><span class="line">        update_cfs_group(se);</span><br><span class="line">        enqueue_runnable_load_avg(cfs_rq, se);</span><br><span class="line">        account_entity_enqueue(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ENQUEUE_WAKEUP)</span><br><span class="line">                place_entity(cfs_rq, se, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        check_schedstat_required();</span><br><span class="line">        update_stats_enqueue(cfs_rq, se, flags);</span><br><span class="line">        check_spread(cfs_rq, se);</span><br><span class="line">        <span class="keyword">if</span> (!curr)</span><br><span class="line">                __enqueue_entity(cfs_rq, se);</span><br><span class="line">        se-&gt;on_rq = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When bandwidth control is enabled, cfs might have been removed</span></span><br><span class="line"><span class="comment">         * because of a parent been throttled but cfs-&gt;nr_running &gt; 1. Try to</span></span><br><span class="line"><span class="comment">         * add it unconditionnally.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (cfs_rq-&gt;nr_running == <span class="number">1</span> || cfs_bandwidth_used())</span><br><span class="line">                list_add_leaf_cfs_rq(cfs_rq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cfs_rq-&gt;nr_running == <span class="number">1</span>)</span><br><span class="line">                check_enqueue_throttle(cfs_rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，函数最主要的调用是<code>__enqueue_entity</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Enqueue an entity into the rb-tree:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">link</span> =</span> &amp;cfs_rq-&gt;tasks_timeline.rb_root.rb_node;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">entry</span>;</span></span><br><span class="line">        <span class="keyword">bool</span> leftmost = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Find the right place in the rbtree:</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (*link) &#123;</span><br><span class="line">                parent = *link;</span><br><span class="line">                entry = rb_entry(parent, struct sched_entity, run_node);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * We dont care about collisions. Nodes with</span></span><br><span class="line"><span class="comment">                 * the same key stay together.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (entity_before(se, entry)) &#123;</span><br><span class="line">                        link = &amp;parent-&gt;rb_left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        link = &amp;parent-&gt;rb_right;</span><br><span class="line">                        leftmost = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rb_link_node(&amp;se-&gt;run_node, parent, link);</span><br><span class="line">        rb_insert_color_cached(&amp;se-&gt;run_node,</span><br><span class="line">                               &amp;cfs_rq-&gt;tasks_timeline, leftmost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述函数中，<code>while</code>循环遍历寻找适合的匹配键值。由于是平衡二叉树，所以右分支的值永远大于左分支。故而一旦需要向右走子树，<code>leftmost</code>就会置为false。推出循环后调用<code>rb_link_node</code>使得新插入的进程称为其子节点。最后函数<code>rb_insert_color_cached</code>更新树的自平衡属性。</p><ol><li>从树中删除进程</li></ol><p>删除动作发生在进程堵塞或者终止时，调用函数<code>dequeue_entity</code>来进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Update run-time statistics of the &#x27;current&#x27;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        update_curr(cfs_rq);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When dequeuing a sched_entity, we must:</span></span><br><span class="line"><span class="comment">         *   - Update loads to have both entity and cfs_rq synced with now.</span></span><br><span class="line"><span class="comment">         *   - Subtract its load from the cfs_rq-&gt;runnable_avg.</span></span><br><span class="line"><span class="comment">         *   - Subtract its previous weight from cfs_rq-&gt;load.weight.</span></span><br><span class="line"><span class="comment">         *   - For group entity, update its weight to reflect the new share</span></span><br><span class="line"><span class="comment">         *     of its group cfs_rq.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        update_load_avg(cfs_rq, se, UPDATE_TG);</span><br><span class="line">        dequeue_runnable_load_avg(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">        update_stats_dequeue(cfs_rq, se, flags);</span><br><span class="line"></span><br><span class="line">        clear_buddies(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (se != cfs_rq-&gt;curr)</span><br><span class="line">                __dequeue_entity(cfs_rq, se);</span><br><span class="line">        se-&gt;on_rq = <span class="number">0</span>;</span><br><span class="line">        account_entity_dequeue(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Normalize after update_curr(); which will also have moved</span></span><br><span class="line"><span class="comment">         * min_vruntime if @se is the one holding it back. But before doing</span></span><br><span class="line"><span class="comment">         * update_min_vruntime() again, which will discount @se&#x27;s position and</span></span><br><span class="line"><span class="comment">         * can move min_vruntime forward still more.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; DEQUEUE_SLEEP))</span><br><span class="line">                se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* return excess runtime on last dequeue */</span></span><br><span class="line">        return_cfs_rq_runtime(cfs_rq);</span><br><span class="line"></span><br><span class="line">        update_cfs_group(se);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Now advance min_vruntime if @se was the entity holding it back,</span></span><br><span class="line"><span class="comment">         * except when: DEQUEUE_SAVE &amp;&amp; !DEQUEUE_MOVE, in this case we&#x27;ll be</span></span><br><span class="line"><span class="comment">         * put back on, and if we advance min_vruntime, we&#x27;ll be placed back</span></span><br><span class="line"><span class="comment">         * further than we started -- ie. we&#x27;ll be penalized.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; (DEQUEUE_SAVE | DEQUEUE_MOVE)) != DEQUEUE_SAVE)</span><br><span class="line">                            update_min_vruntime(cfs_rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个工作实际是由<code>__dequeue_entity</code>完成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">        rb_erase_cached(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-3-调度器入口"><a href="#4-5-3-调度器入口" class="headerlink" title="4.5.3 调度器入口"></a>4.5.3 调度器入口</h4><p>这里后期内核的实现方式与书中过于不同，所以这部分参考的是<a href="https://zhuanlan.zhihu.com/p/363791563">linux调度子系统8 - schedule函数</a></p><p>进程调度的主要入口点是函数<code>schedule</code>，定义在<code>kernel/sched/core.c</code>中。其实现异常简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"></span><br><span class="line">        sched_submit_work(tsk);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                preempt_disable();</span><br><span class="line">                __schedule(<span class="literal">false</span>);</span><br><span class="line">                sched_preempt_enable_no_resched();</span><br><span class="line">        &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">        sched_update_worker(tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>schedule()</code>只是一个外包装，实际的操作还是<code>__shedule()</code>函数。<code>__shedule()</code>接受一个bool作为形参，false表示非抢占，自愿调度，true则相反。</p><p>在执行整个系统调度的过程中，需要关闭抢占，这也很好理解，内核的抢占本身也是为了执行调度，现在本身就已经在调度了，如果不关抢占，递归地执行进程调度怎么看都是一件没必要的事。当然，在调度过程完成之后，也就是 <code>__schedule</code> 返回之后，这个过程中可能会被设置抢占标志，这时候还是需要重新执行调度的。</p><p>在调用 <code>__schedule</code>时，实际上已经发生了进程切换。假设存在A，B两个进程， A进程调用<code>__schedule</code>返回的时候是A进程被调度回来的时候。也就是说，在<code>__schedule</code>执行期间，已经发生了从A到B的进程切换。所以<code>__schedule</code>函数的执行周期也就会达到几百毫秒甚至更长。</p><blockquote><p>因此，实际上，在当前进程中禁止的抢占，而使能抢占的 sched_preempt_enable_no_resched 函数却是在另一个进程上执行的.好在所有的进程都是通过 schedule() 进行进程切换的，也就保证了 disable 和 enable 总是成对的.</p></blockquote><p> <code>__schedule</code>的实现大概分为四个部分：针对当前进程处理、选择下一个需要执行的进程、执行切换以及收尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __sched notrace __schedule(<span class="keyword">bool</span> preempt)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *switch_count;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">        <span class="keyword">int</span> cpu;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//针对当前进程处理</span></span><br><span class="line">        cpu = smp_processor_id();</span><br><span class="line">        rq = cpu_rq(cpu);</span><br><span class="line">        prev = rq-&gt;curr;</span><br><span class="line"></span><br><span class="line">        schedule_debug(prev, preempt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">                hrtick_clear(rq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//disable local interrupt  防止中断的竞争行为</span></span><br><span class="line">        local_irq_disable();</span><br><span class="line">        rcu_note_context_switch(preempt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Make sure that signal_pending_state()-&gt;signal_pending() below</span></span><br><span class="line"><span class="comment">         * can&#x27;t be reordered with __set_current_state(TASK_INTERRUPTIBLE)</span></span><br><span class="line"><span class="comment">         * done by the caller to avoid the race with signal_wake_up().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The membarrier system call requires a full memory barrier</span></span><br><span class="line"><span class="comment">         * after coming from user-space, before storing to rq-&gt;curr.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rq_lock(rq, &amp;rf);</span><br><span class="line">        smp_mb__after_spinlock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Promote REQ to ACT */</span></span><br><span class="line">        rq-&gt;clock_update_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">        switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line">        <span class="keyword">if</span> (!preempt &amp;&amp; prev-&gt;state) &#123;</span><br><span class="line">                <span class="keyword">if</span> (signal_pending_state(prev-&gt;state, prev)) &#123;</span><br><span class="line">                        prev-&gt;state = TASK_RUNNING;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prev-&gt;in_iowait) &#123;</span><br><span class="line">                                atomic_inc(&amp;rq-&gt;nr_iowait);</span><br><span class="line">                                delayacct_blkio_start();</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//选择下一个需要执行的进程</span></span><br><span class="line">        next = pick_next_task(rq, prev, &amp;rf);</span><br><span class="line">        clear_tsk_need_resched(prev);</span><br><span class="line">        clear_preempt_need_resched();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行进程切换</span></span><br><span class="line">        <span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">                rq-&gt;nr_switches++;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * RCU users of rcu_dereference(rq-&gt;curr) may not see</span></span><br><span class="line"><span class="comment">                 * changes to task_struct made by pick_next_task().</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                RCU_INIT_POINTER(rq-&gt;curr, next);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The membarrier system call requires each architecture</span></span><br><span class="line"><span class="comment">                 * to have a full memory barrier after updating</span></span><br><span class="line"><span class="comment">                 * rq-&gt;curr, before returning to user-space.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * Here are the schemes providing that barrier on the</span></span><br><span class="line"><span class="comment">                 * various architectures:</span></span><br><span class="line"><span class="comment">                 * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.</span></span><br><span class="line"><span class="comment">                 *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.</span></span><br><span class="line"><span class="comment">                 * - finish_lock_switch() for weakly-ordered</span></span><br><span class="line"><span class="comment">                 *   architectures where spin_unlock is a full barrier,</span></span><br><span class="line"><span class="comment">                 * - switch_to() for arm64 (weakly-ordered, spin_unlock</span></span><br><span class="line"><span class="comment">                 *   is a RELEASE barrier),</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ++*switch_count;</span><br><span class="line"></span><br><span class="line">                trace_sched_switch(preempt, prev, next);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Also unlocks the rq: */</span></span><br><span class="line">                rq = context_switch(rq, prev, next, &amp;rf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line">                rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收尾</span></span><br><span class="line">        balance_callback(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="针对当前进程的处理"><a href="#针对当前进程的处理" class="headerlink" title="针对当前进程的处理"></a>针对当前进程的处理</h5><p>首先要注意的是这个代码<code>prev = rq-&gt;curr;</code>这里将当前运行的进程赋值为prev，然后后续中一直在执行prev中的进程。这与上文中描述的<code>__shedule()</code>的进程切换有关。 在<code>__shedule()</code>内部会进行一次进程调度，在调度前，这个prev是当前进程curr，而调度回来后，这个prev就是真正上次执行的进程。</p><p><code>if (!preempt &amp;&amp; prev-&gt;state)</code>这里主要是对自愿调度的处理。<code>preempt</code>代表是否资源让出。<code>prev-&gt;state</code>代表当前进程状态，0对应状态为<code>TASK_RUNNING</code>，正常情况下，进程自愿让出CPU会将进程设置为其他状态。</p><p>if模块中的代码直接引用知乎大佬的描述</p><blockquote><p>进入到 if 判断子代码块中，首先需要先检查该进程是否有未处理信号，如果有，就需要先处理信号，将当前进程的状态设置回 TASK_RUNNING.这种情况下，当前进程会重新参与调度，有很大概率选取到的下一个进程依旧是当前进程，从而不执行实际的进程切换.</p><p>如果没有未处理信号，就调用 deactivate_task() 将进程从队列中移除，实际上就是调用了 dequeue_task 函数，同时将进程的 on_rq 设置为 0，表示当前进程已经不在 CPU 上了(但实际上还在，只是提前设置了标志位)，对于工作队列的内核线程，需要进行一些特殊处理，毕竟这个内核线程关系到中断下半部的执行，这时候需要根据 workqueue 上的负载来确定是否需要唤醒其它的内核线程协助处理worker.</p><p>做完上述的处理之后，需要对进程的 nvcsw 或者 nivcsw 进行更新，这两个标志是调度相关的统计，如果是自愿调度，则选中nvcsw，否则选中 nivcsw，多出的 ‘i’ 表示 involuntarily.这里并没有操作，在后面选中了待运行进程且待运行进程不为 curr 的时候再对其进行加 1 操作。</p><p>最后，再考虑一个问题:如果进程没有设置为非 TASK_RUNNING 状态的情况下，直接调用 schedule() 函数，会怎么样?</p><p>当然，这和上面提到的关抢占然后调度的问题一样属于不正常的情况，对于这种情况的处理其实和检测到有未处理信号一样，调度器会照样选择下一个执行的进程，而且大概率会是当前进程.</p><p>理论上来说，cfs 调度器上运行的就是 vruntime 最小的进程，如果是这样，下一个被选择的进程几乎一定是当前进程.但是具体的实现来理论还是有些差别，其中包括:</p><ul><li>进程有一个最小执行时间的限制，可能当前进程的 vruntime 大于 leftmost，但是依旧在运行.</li><li>在周期性的调度检查中，并不是 curr-&gt;vruntime 大于 leftmost-&gt;vruntime 就立马调度，而是需要这两者的差值大于 curr 的 idle_time.可能当前进程的 vruntime 大于 leftmost，但是依旧在运行.</li><li>由于检查调度的粒度问题，进程已经超出理论应该运行的时间，但是没有出现检查是否需要调度的点.</li></ul><p>这三种情况都可能导致 leftmost-&gt;vruntime 小于 curr-&gt;vruntime，在这几种情况下执行调度，调度器就会选择到 leftmost，而不是继续执行当前进程了.</p></blockquote><h5 id="选择下一个需要执行的进程"><a href="#选择下一个需要执行的进程" class="headerlink" title="选择下一个需要执行的进程"></a>选择下一个需要执行的进程</h5><p>选择下一个进程的接口为<code>pick_next_task</code>函数，也是内核调度的核心接口，针对了所有的调度器类。其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> * Pick up the highest-prio task:</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">pick_next_task</span>(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, <span class="keyword">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Optimization: we know that if all tasks are in the fair class we can</span></span><br><span class="line"><span class="comment">         * call that function directly, but only if the @prev task wasn&#x27;t of a</span></span><br><span class="line"><span class="comment">         * higher scheduling class, because otherwise those loose the</span></span><br><span class="line"><span class="comment">         * opportunity to pull in more work from other CPUs.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (likely((prev-&gt;sched_class == &amp;idle_sched_class ||</span><br><span class="line">                    prev-&gt;sched_class == &amp;fair_sched_class) &amp;&amp;</span><br><span class="line">                   rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;                      <span class="comment">//注1</span></span><br><span class="line"></span><br><span class="line">                p = fair_sched_class.pick_next_task(rq, prev, rf);                 <span class="comment">//注2</span></span><br><span class="line">                <span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">                        <span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span></span><br><span class="line">                <span class="keyword">if</span> (unlikely(!p))</span><br><span class="line">                        p = idle_sched_class.pick_next_task(rq, prev, rf);  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We must do the balancing pass before put_next_task(), such</span></span><br><span class="line"><span class="comment">         * that when we release the rq-&gt;lock the task is in the same</span></span><br><span class="line"><span class="comment">         * state as before we took rq-&gt;lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * We can terminate the balance pass as soon as we know there is</span></span><br><span class="line"><span class="comment">         * a runnable task of @class priority or higher.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        for_class_range(class, prev-&gt;sched_class, &amp;idle_sched_class) &#123;          <span class="comment">//注3</span></span><br><span class="line">                <span class="keyword">if</span> (class-&gt;balance(rq, prev, rf))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        put_prev_task(rq, prev);</span><br><span class="line"></span><br><span class="line">        for_each_class(class) &#123;</span><br><span class="line">                p = class-&gt;pick_next_task(rq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (p)</span><br><span class="line">                         <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The idle class should always have a runnable task: */</span></span><br><span class="line">        BUG();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注1:在 pick_next_task 中，其实并不是想象中的直接按照调度器的优先级对所有调度器类进行遍历，而是假设下一个运行的进程属于 cfs 调度器类，毕竟，系统中绝大多数的进程都是由 cfs 调度器进行管理，这样做可以从整体上提高执行效率.</p><p>判断一个下一个进程是不是属于 cfs 调度器的方式是当前进程是不是属于 cfs 调度器类或者 idle 调度器类管理的进程，同时满足 rq-&gt;nr_running == rq-&gt;cfs.h_nr_running， 其中 rq-&gt;nr_running 表示当前 runqueue 上所有进程的数量，包括组调度中的递归统计，而 rq 的 root cfs_rq 的 h_nr_running 表示 root cfs_rq 上所有进程的数量，如果两者相等，自然就没有其它调度器的进程就绪.</p><p>注2<strong>:如果确定了下一个进程会在 cfs_rq 中选，就调用 cfs 调度器类的 pick_next_task 回调函数，这个我们在后面详细讨论</strong>.</p><p>注3:如果确定下一个进程不在 cfs_rq 中选，就需要依据优先级对所有的调度器类进行遍历，找到一个进程之后就返回该进程，由此可以看出，在系统的调度行为中，不同的调度器类拥有绝对的优先级区分，高优先级的调度器类并不会与低优先级的调度器类共享 CPU，而是独占(会有一些特殊情况，在具体实现中，实时进程会好心地让出那么一点 CPU 时间给非实时进程，这个时间可配置).</p><p>遍历调度器类的接口为 for_each_class，在多核架构中，最高优先级调度器类为 stop_sched_class，其次是 dl_sched_class，单核架构中，最高优先级调度器类为 dl_sched_class，接下来依次是 rt_sched_class-&gt;fair_sched_class-&gt;idle_sched_class. stop_sched_class 主要用来停止 CPU 的时候使用的，比如热插拔.其遍历过程也是通过调用对应调度器类的 pick_next_task 函数，如果该调度器有进程就绪就返回进程，否则返回 NULL，继续遍历下一个调度器类，至于其它调度器类的实现，暂不讨论.</p><p>在<code>pick_next_task_fair</code>里面主要就调用了前面说的<code>pick_next_entity()</code>也就回到了前面所描述的进程选择的位置。</p><h5 id="执行进程切换"><a href="#执行进程切换" class="headerlink" title="执行进程切换"></a>执行进程切换</h5><p>经过千辛万苦，终于选到了合适的进程，在选取了合适的待运行进程之后，就进入下一个环节:进程的切换.</p><p>如果是抢占调度，就需要先清除抢占标志。</p><p>然后，判断选出来的下一个进程是否是当前运行的进程，经过上面的源码分析，其实资源调度和抢占调度两种方式选到的待运行进程都可能是当前进程，这种情况下就不需要做什么处理，直接清理调度设置准备退出。</p><p>大部分情况下待运行进程都不会是 curr，这时候就需要进入到真正的切换流程，在切换之前，执行一些必要的计数统计和更新：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rq-&gt;nr_switches++;</span><br><span class="line">rq-&gt;curr = next;</span><br><span class="line">++*switch_count;   <span class="comment">// 这个变量是 curr-&gt;nivcsw 或者 curr-&gt;nvcsw</span></span><br></pre></td></tr></table></figure><p>然后执行切换函数：context_switch。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">schedule-&gt;__schedule-&gt;context_switch:</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *</span></span><br><span class="line"><span class="class"><span class="title">context_switch</span>(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>， <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>，</span></span><br><span class="line"><span class="class">           <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>， <span class="keyword">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>， *<span class="title">oldmm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换的准备工作，包括更新统计信息、设置 next-&gt;on_cpu 为 1 等。 </span></span><br><span class="line">    prepare_task_switch(rq， prev， next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取即将切换到的进程的 mm。</span></span><br><span class="line">    mm = next-&gt;mm;</span><br><span class="line">    <span class="comment">// 当前的 active_mm</span></span><br><span class="line">    oldmm = prev-&gt;active_mm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mm = NULL 表示下一个进程还是一个内核线程</span></span><br><span class="line">    <span class="keyword">if</span> (!mm) &#123;</span><br><span class="line">        <span class="comment">// 如果是内核线程，依旧不需要切换 mm，依旧保存 active_mm</span></span><br><span class="line">        next-&gt;active_mm = oldmm;</span><br><span class="line">        <span class="comment">// 相当于添加引用计数：atomic_inc(&amp;mm-&gt;mm_count);</span></span><br><span class="line">        mmgrab(oldmm);</span><br><span class="line">        enter_lazy_tlb(oldmm， next);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        switch_mm_irqs_off(oldmm， mm， next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev-&gt;mm) &#123;</span><br><span class="line">        prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">        rq-&gt;prev_mm = oldmm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rq_unpin_lock(rq， rf);</span><br><span class="line">    spin_release(&amp;rq-&gt;lock.dep_map， <span class="number">1</span>， _THIS_IP_);</span><br><span class="line"></span><br><span class="line">    switch_to(prev， next， prev);</span><br><span class="line">    barrier();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finish_task_switch(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从硬件上来说，CPU 为了加速数据的访问过程，大量地使用了缓存技术，包括指令、数据和 TLB 缓存，事实证明，缓存的使用给系统运行效率带来了巨大的提升。在多核架构中，缓存是 percpu 的，通常只有 L3 缓存的 global 的，因此，对于进程的切换而言，通常操作的都是本地 CPU 的缓存。</p><p>在 context_switch 中，一个比较重要的部分是用户空间内存映射的处理，即 mm 结构，整个用户空间的内存布局都是由一个 struct mm 的结构保存的，对于内核线程而言，并没有所谓的用户空间的概念，其 mm 为 NULL。</p><p>内核是统一的，并不像用户空间一样每个进程享有独立的空间，因此，从缓存的角度来看，对于内核部分和用户空间部分的处理是完全不一样的。对于指令和数据 cache 而言，会随着程序的执行逐渐被替换，用户空间的 cache 是必须要被 flush 的，而内核空间中的某些 cache 依旧可以利用在下一个进程。</p><p>重点在于 TLB 的缓存处理，TLB 中缓存了页表对应的虚拟地址到物理地址的映射，有了这一层缓存，对某片内存的重复访问只需要从缓存中取，而不需要重新执行翻译过程，当执行进程切换时，尽管每个进程虚拟空间都是一致的，但是其对应的物理地址通常是不相等的，因此需要将上个进程的 TLB 缓存清除，不然会影响下一个进程的执行。</p><p>但是实际情况却有一些优化空间，比如对于用户进程之间的互相切换，其用户空间的 TLB 缓存自然是要刷新，但是内核空间可以保留，因为内核中是共用的。同时，linux 中的内核线程和用户空间没有关系，假设存在这样的情况：用户进程 A 切换为内核线程 B，内核线程 B 运行完之后又切换回 A，这时候从 A 切换到 B 的时候如果清除了 TLB 缓存，在 B 切换回 A 的时候，TLB 又需要重新填充，实际上这种情况可以在切换到内核线程时保留用户空间的 TLB 缓存，如果又切换回 A 的时候就正好可以直接使用，提升了效率。</p><p>如果此时从 B 切换到其它内核线程 C，TLB 缓存依旧可以保留，直到切换到下一个用户进程，如果这个进程不是原本的 A，这时候才会把 TLB 清除，这就是我们经常听到的 “惰性 TLB”，这种 lazy operation 可以在很多地方可以看到，比如 fork 的执行，动态库的绑定，其核心思想就是直到资源在真正需要的时候才进行操作。</p><p>上面的源代码就是基于上述的逻辑，<strong>获取 next-&gt;mm</strong> ，这是待运行进程的 mm，<strong>同时获取 oldmm = prev-&gt;active_mm</strong>，如果当前进程是用户进程，oldmm 等于 NULL，因为切换到其它用户进程时 mm 是肯定需要替换的，而如果当前进程是内核线程，oldmm 就是上个进程保留的 mm，当然，上个进程也可能是内核线程，这里保存的就是上一个用户进程的 mm。</p><p>判断如果待运行进程的 mm 为空，即为内核线程，那么就不需要切换 mm 结构，相对应的 TLB 也不需要刷新，而如果待运行进程是用户进程，分两种情况：第一个是缓存的 mm 正好是下一个待运行进程，也就不需要做什么事，另一种情况就是当前进程不是缓存的 mm，那么就需要替换 mm，然后刷新 TLB，同时只需要刷新用户空间的 TLB，而不需要刷新内核 TLB。</p><h5 id="switch-to"><a href="#switch-to" class="headerlink" title="switch_to"></a>switch_to</h5><p>在处理完上下文环境之后，就来到了真正的进程切换操作了，具体操作自然是和硬件强相关的，被定义在 arch/ 下，同时操作的代码都是通过汇编实现的。</p><p>对于进程的实际切换，有两个点需要弄清楚：</p><p>第一点就是，<strong>switch_to 是进程的一个断点</strong>，也就是在 switch_to 中，会完成进程的切换，在 switch_to 之后的代码，实际上是在进程切换回来之后执行的。比如，从上面的代码来看，switch_to 后调用了 finish_task_switch，实际上，进程 A 在调用 switch_to 中切换到了进程 B，而紧接着执行的是 B 的 finish_task_switch，因此，在 B 中的 finish_task_switch 中做的一些调用清理工作，其实是针对进程 A 的。</p><p>第二点也就是基于第一点的延伸，switch_to 的调用为 switch_to(prev， next， prev)，函数需要传入三个参数，按理说，只需要两个参数，一个是当前进程，一个是 next，也就是待运行进程，为什么还需要第三个参数？</p><p>switch_to 中完成了进程的切换，switch_to 之后的代码实际上是进程切换回来执行的，那么，我们何从知道当前进程是从哪个进程切换过来的呢?所以，多出来的一个参数就是上次运行的进程，实际上是 last，比如由 A 切换到 B，对于 B 而言，多出来的一个参数保存的就是 A 的 task_struct.</p><p>在 arm 的实现中，switch_to 将会调用 __swtich_to：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(prev，next，last)                   \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                    \</span><br><span class="line">    __complete_pending_tlbi();                  \</span><br><span class="line">    last = __switch_to(prev，task_thread_info(prev)， task_thread_info(next));    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>通过 switch_to 的定义更能体现切换的过程，切换之后将会返回上次运行的进程。而 __switch_to 函数则被定义在 arch/arm/kernel/entry-armv.S 中。这部分汇编代码的实现为：</p><ul><li>将当前进程大部分通用寄存器保存到栈上，需要注意的是，这里并不是压栈，因为每个进程的内核栈的底部保存的是当前进程的 thread_info，在 arm 中，保存寄存器的地址为：thread_info-&gt;cpu_context，保存的通用寄存器的值为 r4 ~ r14，其中 lr 是 __switch_to 函数的返回值。</li><li>保存或者替换其它的寄存器值，比如线程本地存储 tls、浮点寄存器或者其它，这一部分是硬件强相关的，需要看硬件是否提供对应的功能。</li><li>r0 寄存器保持原样，传入的 r0 是第一个参数，表示当前进程，切换到另一个进程 B 之后，其返回值就是当前进程 A，按照 aapcs 规范，函数调用时返回值保存在 r0 中，也就是上一个运行的进程。</li><li>将 next 进程对应内核栈上保存的寄存器值恢复到寄存器中，也就完成了切换，r4~r13 是原样恢复，而 pc 指针则使用保存的 lr 寄存器，也就是新进程会从 __switch_to 函数返回处开始执行。</li></ul><h4 id="4-5-4-睡眠和唤醒"><a href="#4-5-4-睡眠和唤醒" class="headerlink" title="4.5.4 睡眠和唤醒"></a>4.5.4 睡眠和唤醒</h4><p>休眠（被堵塞）的进程处于一个特殊的不可执行状态。休眠的原因有很多，但是肯定都是为了等待一些事件的发生。无论哪种情况，内核的操作都相同：进程将自己的<code>task_struct</code>中的<code>state</code>设置为休眠状态，从可执行的红黑树中移除，放入等待队列，然后调用<code>schedule()</code>选择一个其他进程。而唤醒进程则刚好相反。</p><p>复习一下第三章的知识，休眠中存在两种进程相关的状态：<code>TASK_INTERRUPTABLE</code>以及<code>TASK_UNINTERRUPTIBLE</code>。他们的区别为后者会忽略信号，而前者在接受到信号后会唤醒并且进行响应。这两种状态的进程会位于同一个等待队列上，等待某些事件，不能够运行。</p><ol><li>等待队列</li></ol><p>按前面的描述我们知道，休眠通过等待队列来进行处理。这个队列在内核中的表示为<code>wake_queue_head_t</code>。等待队列的创建有两种形式：一是通过<code>DECLARE_WAITQUEUE()</code>静态创建，二是通过<code>init_waitqueue_head()</code>动态创建。进程将通过执行下面几个步骤将自己加入等待队列中：</p><ul><li>调用宏<code>DEFINE_WAIT</code>创建一个等待队列项</li><li>调用<code>add_wait_queue()</code>把自己加入到队列中。该队列会在满足进程等待条件时将其唤醒。（需要代码对等待队列执行<code>wake_up()</code>）</li><li>调用<code>prepare_to_wait()</code>方法将进程状态变更为<code>TASK_INTERRUPTABLE</code>或<code>TASK_UNINTERRUPTIBLE</code></li><li>如果状态被设置为<code>TASK_INTERRUPTABLE</code>，则信号唤醒进程（伪唤醒），因此检查并处理信号</li><li>进程再次被唤醒的时候，会再次检查条件是否为真。为真便退出循环；否则再次调用<code>schedule()</code>并一直重复检查。</li><li>条件满足后进程将自身设置为<code>TASK_RUNNING</code>并调用<code>finish_wait()</code>将自己移出等待队列</li></ul><p>如果进程在开始休眠之前就已经达成条件，则循环会退出，进程不会存在错误的进入休眠的倾向。</p><blockquote><p>需要注意，内核代码在循环体内通常要做一些其他任务。比如需要在调用<code>schedule()</code>之前释放锁，在之后进行重新获取，或者响应其他事件。</p></blockquote><ol><li>唤醒</li></ol><p>唤醒操作通过<code>wake_up()</code>进行。会唤醒指定等待队列的所有进程。它调用了函数<code>try_to_wake_up()</code>。该函数将进程设置为<code>TASK_RUNNING</code>状态。并调用<code>enqueue_task()</code>将进程放入红黑树中。若被唤醒的进程比当前进程优先级高，则要设置<code>need_resched</code>标志。促使等待条件达成的代码要负责随后调用<code>wake_up()</code>函数。</p><blockquote><p>由于存在虚假的唤醒，所以进程被唤醒也并不是因为它等待的条件达成了。所以才需要用循环处理来保证它等待的条件真正达成。</p></blockquote><h3 id="4-7-实时调度策略"><a href="#4-7-实时调度策略" class="headerlink" title="4.7 实时调度策略"></a>4.7 实时调度策略</h3><p>Linux提供了两种实时调度策略：<code>SCHED_FIFO</code>以及<code>SCHED_RR</code>。而普通非实时的调度策略是<code>SCHED_NORMAL</code>。协助调度类的框架，这些实时调度不完全被CFS来管理。而是被定义在<code>kernel/sched_rt.c</code>中的一个特殊调度器来管理。</p><p><code>SCHED_FIFO</code>使用先进先出的策略，任何处于<code>SCHED_FIFO</code>级的进程都会比<code>SCHED_NORMAL</code>级的进程更先得到调度。这个进程不受时间片限制，可以一直执行下去。只有更高优先级的<code>SCHED_FIFO</code>以及<code>SCHED_RR</code>进程到来才能抢占。如果存在两个相同级别的<code>SCHED_FIFO</code>进程，他们只会在另一方自愿让出内核时才能执行。</p><p><code>SCHED_RR</code>与前者大体相同。可以理解为带时间片的<code>SCHED_FIFO</code>。只是<code>SCHED_RR</code>的进程在耗尽时间片之后就不能继续执行了。</p><p>Linux给实时调度算法提供了一种软实时的工作方式。所谓的软实时，是指内核调度进程尽力使进程在它的限定时间到来之前运行，硬实时系统则是保证在一定条件下，可以满足任何调度的要求。</p><blockquote><p>在默认情况下，nice值从-20到+19对应的是从100到139的实时优先级范围。</p></blockquote><h3 id="4-8-与调度有关的系统调用"><a href="#4-8-与调度有关的系统调用" class="headerlink" title="4.8 与调度有关的系统调用"></a>4.8 与调度有关的系统调用</h3><div class="table-container"><table><thead><tr><th style="text-align:center">系统调用</th><th style="text-align:center">描   述</th></tr></thead><tbody><tr><td style="text-align:center">nice()</td><td style="text-align:center">设置系统的nice值</td></tr><tr><td style="text-align:center">sched_setscheduler()</td><td style="text-align:center">设置进程的调度策略</td></tr><tr><td style="text-align:center">sched_getscheduler()</td><td style="text-align:center">获取进程的调度策略</td></tr><tr><td style="text-align:center">sched_setparam()</td><td style="text-align:center">设置进程的实时优先级</td></tr><tr><td style="text-align:center">sched_getparam()</td><td style="text-align:center">获取进程的实时优先级</td></tr><tr><td style="text-align:center">sched_get_priority_max()</td><td style="text-align:center">获取实时优先级的最大值</td></tr><tr><td style="text-align:center">sched_get_priority_min()</td><td style="text-align:center">获取实时优先级的最小值</td></tr><tr><td style="text-align:center">sched_rr_get_interval()</td><td style="text-align:center">获取进程时间片值</td></tr><tr><td style="text-align:center">sched_setaffinity()</td><td style="text-align:center">设置进程处理器的亲和力</td></tr><tr><td style="text-align:center">sched_getaffinity()</td><td style="text-align:center">获取进程处理器的亲和力</td></tr><tr><td style="text-align:center">sched_yield()</td><td style="text-align:center">暂时让出处理器</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux内核设计与实现第四章-进程调度&quot;&gt;&lt;a href=&quot;#Linux内核设计与实现第四章-进程调度&quot; class=&quot;headerlink&quot; title=&quot;Linux内核设计与实现第四章  进程调度&quot;&gt;&lt;/a&gt;Linux内核设计与实现第四章  进程调度&lt;/h1&gt;&lt;p&gt;进程调度程序可以被看做是一个在可运行态进程之间分配有限处理器时间资源的内核子系统。也是Linux多任务的基础。只有有了合理的调度，系统资源才能最大化的发挥作用。多进程才会有并发执行的效果。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux内核设计与实现" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Linux内核" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="进程调度" scheme="http://yokeso.github.io/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核设计与实现ch1-ch3</title>
    <link href="http://yokeso.github.io/2023/05/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch1-ch3/"/>
    <id>http://yokeso.github.io/2023/05/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch1-ch3/</id>
    <published>2023-05-20T07:11:22.000Z</published>
    <updated>2023-06-27T15:12:15.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核设计与实现读书笔记"><a href="#Linux内核设计与实现读书笔记" class="headerlink" title="Linux内核设计与实现读书笔记"></a>Linux内核设计与实现读书笔记</h1><h2 id="第二章-从内核出发"><a href="#第二章-从内核出发" class="headerlink" title="第二章 从内核出发"></a>第二章 从内核出发</h2><h3 id="内核开发特点"><a href="#内核开发特点" class="headerlink" title="内核开发特点"></a>内核开发特点</h3><ul><li>不能访问c库也不能访问标准的c文件</li><li>必须使用GNU C</li><li>缺乏像用户空间一样的内存保护机制</li><li>难以执行浮点运算</li><li>给每个进程只有一个很小的定长堆栈</li><li>由于内核支持异步中断，抢占和SMP，因此要时刻注意同步和并发</li><li>要考虑可移植的重要性</li></ul><span id="more"></span><h4 id="无lib库或标准头文件"><a href="#无lib库或标准头文件" class="headerlink" title="无lib库或标准头文件"></a>无lib库或标准头文件</h4><ul><li><p>完整的C库太大而且过于低效</p></li><li><p>大部分常用的C库函数在内核中都已经实现</p><p>打印函数 <code>printk()</code>允许设置标志来设定优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_ERR <span class="string">&quot;this is an error&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意<code>EKRN_ERR</code>与要打印的消息之间没有逗号。优先级标志是预处理程序定义的描述型字符串，在编译时优先级标志要与打印的消息绑定在一起处理。</p></li></ul><h4 id="GNU-C"><a href="#GNU-C" class="headerlink" title="GNU C"></a>GNU C</h4><ul><li><p>内联函数：在调用位置进行展开以消除函数调用和返回带来的开销。但会占用更多的内存空间和指令缓存。所以内联函数通常长度较短，并且时间要求较高。定义时要用<code>static</code>关键字，并用<code>inline</code>限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wolf</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> tail_size)</span></span></span><br></pre></td></tr></table></figure><p>在内核中为例类型安全和易读性，优先使用内联函数而非复杂宏。</p></li><li><p>内联汇编：使用<code>asm()</code>嵌入汇编代码。内核混合使用C和汇编语言。在底层或执行时间要求严格的地方使用汇编。</p></li><li><p>分支声明：针对分支进行优化  <code>likely(), unlikely()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*认为error绝大多数时间为0*/</span></span><br><span class="line"><span class="keyword">if</span>(unlikely(error))&#123;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*认为success通常不会为0*/</span></span><br><span class="line"><span class="keyword">if</span>(likely(success))&#123;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="没有内存保护机制"><a href="#没有内存保护机制" class="headerlink" title="没有内存保护机制"></a>没有内存保护机制</h4><p>用户试图进行内存的非法访问时内核会发送SIGSEGV信号，并结束进程。但是内核自己非法访问内存就无法控制。内核中发生对的内存错误会导致oops。所以对内核开发要关注非法访问的风险。并且内存中内核不做分页处理。所以用一字节，物理内存就减少一字节。</p><h4 id="不要轻易在内核中使用浮点数"><a href="#不要轻易在内核中使用浮点数" class="headerlink" title="不要轻易在内核中使用浮点数"></a>不要轻易在内核中使用浮点数</h4><p>内核本身不能陷入，所以要人工保存以及恢复浮点寄存器，并且产生琐碎的事务。故除极少情况外，不在内核中使用浮点数操作。</p><h4 id="容积小而固定的栈"><a href="#容积小而固定的栈" class="headerlink" title="容积小而固定的栈"></a>容积小而固定的栈</h4><p>内核栈现在可以在编译时进行配置。从历史上来说大小是2页。32位机内核栈8KB，64位机是16KB</p><h4 id="同步和并发"><a href="#同步和并发" class="headerlink" title="同步和并发"></a>同步和并发</h4><p>内核的许多特性都要求能并发的访问共享数据。所以很容易产生竞争挑战。这就要有同步机制来保证不出现竞争。</p><ul><li>LInux是抢占多任务操作系统。内核的进程调度程序即兴对进程及逆行调度和重新调度。内核必须对这些任务进行同步。</li><li>Linux内核支持对称多处理器系统（SMP）所以若无适当保护，同时在多个处理器上执行的内核代码可能会访问共享的同一资源</li><li>若中断在代码访问资源时到来，中断处理程序会访问同一资源。</li><li>linux内核可以抢占，如果不加以保护，一段执行的代码会被另一段抢占，从而导致几段代码同时访问相同的资源。</li></ul><p>解决办法是自旋锁和信号量。</p><h4 id="可移植的重要性"><a href="#可移植的重要性" class="headerlink" title="可移植的重要性"></a>可移植的重要性</h4><p>大部分C代码应该与体系结构无关。因此要把体系结构相关的代码从内核代码树的特定目录中适当分离出来。</p><h2 id="第三章-进程管理"><a href="#第三章-进程管理" class="headerlink" title="第三章 进程管理"></a>第三章 进程管理</h2><h3 id="3-1-进程"><a href="#3-1-进程" class="headerlink" title="3.1 进程"></a>3.1 进程</h3><p>进程是正在执行的程序代码的实时结果。线程是具有独立计数器，进程栈和一组进程寄存器的进程中的活动对象。</p><p>Linux对进程和线程不做特殊区分，将线程认为是一种特殊进程。</p><h3 id="3-2-进程描述符及任务结构"><a href="#3-2-进程描述符及任务结构" class="headerlink" title="3.2 进程描述符及任务结构"></a>3.2 进程描述符及任务结构</h3><p>进程的列表存放在叫做任务队列的双向循环链表中，链表的每一项都叫做<code>task_struct</code>，是进程描述符的结构定义在<code>&lt;linux/shed.h&gt;</code>中。</p><p><code>task_struct</code>在32位机器上约1.7KB，其数据完整的描述了一个正在执行的程序：包括但不限于它打开的文件，进程的地址空间，挂起的信号，进程状态等。</p><h4 id="3-2-1-分配进程描述符"><a href="#3-2-1-分配进程描述符" class="headerlink" title="3.2.1  分配进程描述符"></a>3.2.1  分配进程描述符</h4><p>linux通过slab分配器分配<code>task_struct</code>结构，从而达到对象复用和缓存着色的目的。现在会在栈底（向下增长的栈）创建一个新的结构struct thread_info （位于<code>&lt;asm/thread_info.h&gt;</code>中，这个体系结构让汇编代码中计算其偏移量更加容易。分配于内核栈的尾端。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>   *<span class="title">task</span>;</span>      <span class="comment">//存放指向任何该任务实际task_struct的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>   *<span class="title">exec_domain</span>;</span></span><br><span class="line">__u32                flags;</span><br><span class="line">__u32                status;</span><br><span class="line">__u32                cpu;</span><br><span class="line"><span class="keyword">int</span>                  preempt_count;</span><br><span class="line"><span class="keyword">mm_sigment_t</span>         addr_limit;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line"><span class="keyword">void</span>                 *sysenter_return;</span><br><span class="line"><span class="keyword">int</span>                  uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch1-ch3/image-20220721133714278.png" alt="image-20220721133714278"></p><h4 id="3-2-2进程描述符的存放"><a href="#3-2-2进程描述符的存放" class="headerlink" title="3.2.2进程描述符的存放"></a>3.2.2进程描述符的存放</h4><p>内核通过PID来标识每个进程。PID为pid_t隐藏类型，实际就是int型。最大为32678。如果确实需要，可以修改/proc/sys/kernel/pid_max提高上限。</p><p>内核大部分的处理进程的代码都通过<code>task_struct</code>进行。因此通过<code>current</code>宏查找到当前正在运行进程的进程描述符的速度显得尤为重要。硬件体系结构不同，该宏的实现也不同。<strong>必须针对专门的硬件进行处理</strong>。有的用专门的寄存器存放指针，用于加快访问速度。而像x86则创建栈尾的<code>thread_info</code>结构，通过计算偏移量间接 查找。</p><h4 id="3-2-3-进程状态"><a href="#3-2-3-进程状态" class="headerlink" title="3.2.3 进程状态"></a>3.2.3 进程状态</h4><p>进程描述符中的state域描述了进程当前状态，系统中的每个进程必然处于五种状态的一种。</p><ul><li><code>TASK_RUNNING</code> (运行态)，进程是可执行的，或者正在执行，或者等待执行。</li><li><code>TASK_INTERRUPTIBLE</code>(可中断)，进程正在睡眠（阻塞），等待某些条件的达成，一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程会因为信号而被提前唤醒并随时投入运行。</li><li><code>TASK_UNINTERRUPTIBLE</code>(不可中断)，就算接收信号也不会唤醒。其余与可中断状态相同。这个状态通常在进程必须等待时不受干扰或者等待事件很快就会发生时出现。由于状态对信号不做响应，所以使用较少。</li><li><code>__TASK_TRACED</code>  进程被其他进程跟踪，例如通过ptraace对调试程序进行跟踪。</li><li><code>__TASK_STOPPED</code> 进行停止运行，没有投入运行也不能投入运行，接收到<code>SIGSTOP,SIGTSTP,SIGTTIN,SIG TTOU</code>等信号时出现。调试期间接收到任何信号也会使进程进入这种状态。</li></ul><p><img src="/2023/05/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch1-ch3/image-20220722133633885.png" alt="image-20220722133633885"></p><h4 id="3-2-4设置当前进程状态"><a href="#3-2-4设置当前进程状态" class="headerlink" title="3.2.4设置当前进程状态"></a>3.2.4设置当前进程状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_tasek_state(task,state);<span class="comment">/*将任务task对的状态设置未state*/</span></span><br></pre></td></tr></table></figure><p>函数将进程设置为指定的状态。必要的时候会设置内存屏障强制其他处理器重新排序（只有smp系统有必要）。否则其作用相当于以下语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;state = state;</span><br></pre></td></tr></table></figure><h4 id="3-2-6-进程家族树"><a href="#3-2-6-进程家族树" class="headerlink" title="3.2.6 进程家族树"></a>3.2.6 进程家族树</h4><p>所有进程都是PID为1的init进程的后代，内核在系统启动的最后阶段启动init进程。该进程会读取系统的初始化脚本并执行相关程序。最终完成整个启动过程。</p><p>每个进程必有一个父进程，可以有0或多个子进程。拥有相同父进程的两个进程称为兄弟。进程间的关系存放在进程描述符中。每个<code>task_struct</code>都包含一个指向父进程的<code>tast_struct</code>，称为<code>parent</code>指针。以及子进程表<code>childern</code>。所以获取父进程和子进程可以利用如下代码进行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">my_parient</span> =</span> current-&gt;parient;   <span class="comment">//获取父进程的描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_head</span> *<span class="title">list</span>;</span></span><br><span class="line">list_for_each(<span class="built_in">list</span>,&amp;current-&gt;childern)</span><br><span class="line">&#123;</span><br><span class="line">task = list_entry(<span class="built_in">list</span>,struct task_struct,sibling);  <span class="comment">//task指向当前的某个子进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过重复遍历所有进程的代价很大，所以没有充足的理由不要这样做。</strong></p><h3 id="3-3-进程创建"><a href="#3-3-进程创建" class="headerlink" title="3.3 进程创建"></a>3.3 进程创建</h3><p>Unix创建进程分为两步执行，<code>fork()</code>和<code>exec()</code>。首先fork()通过拷贝当前进程创建一个子进程。这个子进程和父进程的区别仅在于PID、PPID和某些资源统计量（比如挂起的信号）。<code>exec()</code>负责读取可执行文件并且将其载入地址空间运行。</p><blockquote><p>这里的exec主要指的是所有exec函数族的函数。内核实现了execve()函数。在此基础上还有execlp(),execle(),execv(),execvp()等。</p></blockquote><h4 id="3-3-1写时拷贝"><a href="#3-3-1写时拷贝" class="headerlink" title="3.3.1写时拷贝"></a>3.3.1写时拷贝</h4><p>Linux中的fork()函数并不直接把所有的资源复制给新创建的线程。而是采用了写时拷贝页实现。内核并不复制整个进程地址空间，而是让父进程和子进程共享一个拷贝。只有在需要写入的时候，数据才会被复制。</p><p><img src="/2023/05/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch1-ch3/image-20230426102500438.png" alt="image-20230426102500438"></p><p><img src="/2023/05/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch1-ch3/Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20230426102540176.png" alt="image-20230426102540176"></p><h4 id="3-4-线程在Linux中的实现"><a href="#3-4-线程在Linux中的实现" class="headerlink" title="3.4 线程在Linux中的实现"></a>3.4 线程在Linux中的实现</h4><p>从内核的角度来说并没有线程的概念。内核将线程视为一个与其他进程共享某些资源的进程。拥有隶属于自己的task_struct。这一点与其他内核的实现十分不同。其他系统中大多都实现了专门支持线程的机制。</p><p>而linux中将线程称为“轻量级进程”。也就是说，在Linux中线程只是一种进程间共享资源的手段。</p><blockquote><p>假设有一个包含四个线程的进程，通常会有一个包含指向四个不同线程的进程描述符。描述符描述地址空间以及打开文件这样的共享资源。但是在Linux中只会创建四个进程并分配四个普通的task_sturct接口。建立进程时指定他们共享某些资源。</p></blockquote><h5 id="3-4-1-创建线程"><a href="#3-4-1-创建线程" class="headerlink" title="3.4.1 创建线程"></a>3.4.1 创建线程</h5><p>创建线程的方法和进程创建类似，只是调用clone的时候需要传递标志来指明需要共享的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这行代码产生的结果和调用fork基本相同。只是根据线程的定义做出了改变，父子线程共享地址空间，文件资源系统，文件描述符以及信号处理顺序。</p><p>这里列举一些<code>clone()</code>函数中用到的参数以及他们的作用，这些包含在<code>&lt;linux/sched.h&gt;</code>中。</p><p><img src="/2023/05/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch1-ch3/image-20230507163229381.png" alt="image-20230507163229381"></p><p><img src="/2023/05/20/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0ch1-ch3/image-20230507163248756.png" alt="image-20230507163248756"></p><h5 id="3-4-2-内核线程"><a href="#3-4-2-内核线程" class="headerlink" title="3.4.2 内核线程"></a>3.4.2 内核线程</h5><p>内核线程和普通线程的区别主要在于内核线程没有独立的地址空间（指向地址空间的mm指针被设置为NULL）。内核线程只在内核空间中运行，从不切换到用户空间中去。和普通线程一样，内核线程可以被调度，也可以被抢占。</p><blockquote><p>内核线程在shell中可以使用<code>ps -ef</code>命令看到。</p></blockquote><p>内核线程只能由其他内核线程创建。内核通过<code>kthreadd</code>内核进程中衍生出所有新内核线程来自动处理这一点的。在<code>&lt;linux/kthread.h&gt;</code>中存在接口。所以，从现有内核线程中创建一个新的内核线程的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">kthread_create</span><span class="params">(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span>*data),</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">char</span> namefmt[],</span></span></span><br><span class="line"><span class="function"><span class="params">   ...)</span></span></span><br></pre></td></tr></table></figure><p>新创建的进程属于不可以运行的状态。所以需要通过调用<code>wake_up_process()</code>明确唤醒它。创建一个内核线程并运行，可以通过<code>kthread_run()</code>来达到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">kthread_run</span><span class="params">(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> namefmt[],</span></span></span><br><span class="line"><span class="function"><span class="params">...)</span></span></span><br></pre></td></tr></table></figure><p>这个函数是用宏来实现的。只是简单的调用了 <code>kthread_create()</code>和<code>wake_up_process()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> * kthread_run - create <span class="keyword">and</span> wake a thread.</span><br><span class="line"> * @threadfn: <span class="function">the function to run until <span class="title">signal_pending</span><span class="params">(current)</span>.</span></span><br><span class="line"> * @data: data ptr for @threadfn.</span><br><span class="line"> * @namefmt: <span class="built_in">printf</span>-style name <span class="keyword">for</span> the thread.</span><br><span class="line"> *</span><br><span class="line"> * Description: <span class="function">Convenient wrapper <span class="keyword">for</span> <span class="title">kthread_create</span><span class="params">()</span> followed by</span></span><br><span class="line"><span class="function"> * <span class="title">wake_up_process</span><span class="params">()</span>.  Returns the kthread <span class="keyword">or</span> <span class="title">ERR_PTR</span><span class="params">(-ENOMEM)</span>.</span></span><br><span class="line"> */</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kthread_run(threadfn, data, namefmt, ...)                          \</span></span><br><span class="line">(&#123;                                                                         \</span><br><span class="line">        struct task_struct *__k                                            \</span><br><span class="line">                = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR(__k))                                                  \</span><br><span class="line">                wake_up_process(__k);                                      \</span><br><span class="line">        __k;                                                               \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>内核线程启动后会一直运行。直到碰到两种停止条件的一种：</p><ul><li>调用<code>do_exit()</code>进行退出。</li><li>内核其他部分调用<code>kthread_stop()</code>。（传递进来的参数是<code>kthread_create</code>所返回的<code>task_struct</code>结构的地址。）</li></ul><h4 id="3-5-进程终结"><a href="#3-5-进程终结" class="headerlink" title="3.5 进程终结"></a>3.5 进程终结</h4><p>进程的终结发生在定义于<code>kernel/exit.c</code>中的<code>do_exit()</code>函数。这个函数需要进行以下操作：</p><ul><li>将<code>task_struct</code>中的标志成员设置为<code>PF_EXITING</code></li><li>调用<code>del_timer_sync()</code>删除任一内核定时器，根据返回的结果，确保没有定时器在排队，也没有定时器处理程序在运行。</li><li>如果BSD的记账功能是开启的，<code>do_exit()</code>调用<code>acct_update_integrals()</code>来输出记账信息。</li><li><p>调用<code>exit_mm()</code>函数释放进程占用的<code>mm_struct</code>，如果没有别的进程使用他们（即空间地址没有被共享），就彻底释放他们</p></li><li><p>调用<code>sem __exit()</code>函数，如果进程排队等候IPC信号，它则离开队列。</p></li><li>调用<code>exit_files()</code>和<code>exit_fs()</code>，以分别递减文件描述符、系统文件数据的引用计数。如果其中某个引用计数的数值降为零，那么就代表没有进程在使用相应的资源，此时可以释放。</li><li>把存放在<code>task_struct</code>的<code>exit_code</code>成员中的任务退出代码置为由<code>exit()</code>提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。退出代码存放在这里供父线程随时检索。</li><li>调用<code>exit_notify()</code>向父进程发送信号，给子进程重新找养父。养父为进程中的其他线程或者为<code>init</code>进程。并把进程状态（<code>task_struct-&gt;exit_state()</code>中）设置为<code>EXIT_ZOMBIE</code>。</li><li><code>do_exit()</code>调用<code>schedule()</code>切换到新的进程。（处于<code>EXIT_ZOMBIE</code>状态的进程不会再被调度，所以<code>do_exit()</code>永不返回）</li></ul><p>到此为止，与进程相关联的所有资源状态都被释放掉了。进程不可运行并处于<code>EXIT_ZOMBIE</code>状态。仍然占用着的是内核栈、<code>thread_info</code>结构以及<code>task_struct</code>结构。进程存在的唯一目的是向父进程提供信息，父进程检索到这些信息后，由进程持有的剩余内存被释放，归还给系统使用。</p><h5 id="3-5-1-删除进程描述符"><a href="#3-5-1-删除进程描述符" class="headerlink" title="3.5.1 删除进程描述符"></a>3.5.1 删除进程描述符</h5><p>从上一节中可以知道，为了保证系统有办法在子进程终结之后仍然能获取到进程的信息，所以进程的终结和进程描述符的删除被分开执行。</p><p><code>wait()</code>一族的函数都通过<code>wait4()</code>来实现的。其标准动作是挂起调用它的进程，直到其中一个子进程退出。函数会返回该子进程的PID。并且调用函数提供的指针会包含子函数退出时的代码。</p><p>释放进程描述符时，<code>release_task()</code>会被调用，并执行以下几点：</p><ul><li>调用<code>__exit_signal()</code>，该函数调用<code>_unhash_process()</code>后者调用<code>detach_pid()</code>从<code>pidhash</code>上删除该进程。同时要从任务列表中删除该进程。</li><li><code>__exit_signal()</code>释放目前僵死进程的所有剩余资源，并进行最终统计和记录</li><li>如果该进程是线程组最后一个进程。并且领头进程已经死掉，那么<code>release_task()</code>就要通知僵死进程的领头进程的父进程。</li><li><code>release_task()</code>调用<code>put_task_struct()</code>释放进程内核栈和<code>thread_info</code>结构所占的页。并释放<code>task_struct</code>所占用的slab高速缓存。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux内核设计与实现读书笔记&quot;&gt;&lt;a href=&quot;#Linux内核设计与实现读书笔记&quot; class=&quot;headerlink&quot; title=&quot;Linux内核设计与实现读书笔记&quot;&gt;&lt;/a&gt;Linux内核设计与实现读书笔记&lt;/h1&gt;&lt;h2 id=&quot;第二章-从内核出发&quot;&gt;&lt;a href=&quot;#第二章-从内核出发&quot; class=&quot;headerlink&quot; title=&quot;第二章 从内核出发&quot;&gt;&lt;/a&gt;第二章 从内核出发&lt;/h2&gt;&lt;h3 id=&quot;内核开发特点&quot;&gt;&lt;a href=&quot;#内核开发特点&quot; class=&quot;headerlink&quot; title=&quot;内核开发特点&quot;&gt;&lt;/a&gt;内核开发特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不能访问c库也不能访问标准的c文件&lt;/li&gt;
&lt;li&gt;必须使用GNU C&lt;/li&gt;
&lt;li&gt;缺乏像用户空间一样的内存保护机制&lt;/li&gt;
&lt;li&gt;难以执行浮点运算&lt;/li&gt;
&lt;li&gt;给每个进程只有一个很小的定长堆栈&lt;/li&gt;
&lt;li&gt;由于内核支持异步中断，抢占和SMP，因此要时刻注意同步和并发&lt;/li&gt;
&lt;li&gt;要考虑可移植的重要性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Linux内核设计与实现" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Linux内核" scheme="http://yokeso.github.io/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="进程" scheme="http://yokeso.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="ch1-ch3" scheme="http://yokeso.github.io/tags/ch1-ch3/"/>
    
  </entry>
  
  <entry>
    <title>Udev规则修改学习</title>
    <link href="http://yokeso.github.io/2023/03/12/Udev%E8%A7%84%E5%88%99%E4%BF%AE%E6%94%B9%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yokeso.github.io/2023/03/12/Udev%E8%A7%84%E5%88%99%E4%BF%AE%E6%94%B9%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-12T02:03:41.000Z</published>
    <updated>2023-05-16T16:07:39.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Udev规则修改学习"><a href="#Udev规则修改学习" class="headerlink" title="Udev规则修改学习"></a>Udev规则修改学习</h1><h2 id="0x01-udev简介"><a href="#0x01-udev简介" class="headerlink" title="0x01 udev简介"></a>0x01 udev简介</h2><p>udev的全称是Dynamic device management,也就是曾经的<code>devfs</code>的继任者。<code>udev</code>的主要目的是为动态<code>/dev</code>目录提供用户空间的解决方案，以及实现持久的设备命名。</p><span id="more"></span><p>在典型的linux系统上，<code>/dev</code>目录主要用于存储类似文件的设备节点，在这个目录下的每个节点都指向系统设备的一部分，这部分可能存在，也可能不存在。用户的应用程序就是通过使用这些设备节点来与系统的硬件进行交互的。这里引用中文文档中的一些原话</p><blockquote><p>最初的/dev目录只是用可能出现在系统中的每个设备填充。由于这个原因，/dev目录通常非常大。devfs提供了一种更易于管理的方法(值得注意的是，它只使用插入系统的硬件来填充/dev)，以及一些其他功能，但是系统被证明存在一些难以修复的问题。</p><p>udev是管理/dev目录的“新”方法，旨在清除以前/dev实现中的一些问题，并提供一个健壮的前进路径。为了创建和命名与系统中存在的设备相对应的/dev设备节点，udev依赖于sysfs提供的信息与用户提供的规则进行匹配。</p></blockquote><p>那说了这么多，udev的真正作用是什么呢？对于标准设备而言，udev很可能是一个永远触碰不到的东西。但是对于新的或者外来的设备而言，如果不进行配置修改，这些设备可能会导致无法访问。或者说linux本身会给这些设备分配不恰当的名字，所属或者权限来创建设备文件。包括RS-232串口以及音视频设备的属组或者权限都可以在udev中进行更改。</p><h2 id="0x02-规则文件和语义"><a href="#0x02-规则文件和语义" class="headerlink" title="0x02 规则文件和语义"></a>0x02 规则文件和语义</h2><h3 id="0x21-规则文件介绍"><a href="#0x21-规则文件介绍" class="headerlink" title="0x21 规则文件介绍"></a>0x21 规则文件介绍</h3><p>在决定如何命名设备以及执行哪些附加操作时，udev会读取一系列的规则文件。这些文件保存在<code>/etc/udev/rules.d</code>中。文件的后缀名均为<code>.rules</code>。</p><p>其中要注意的是<code>50-udev.rules</code>。这个文件中存放的是默认的udev存储规则，所以用户不应该将规则直接写入这个文件中。在这个文件中包含了一些示例以及一些证明<code>devfs</code>样式<code>/dev</code>布局的默认规则。</p><p><code>rules.d</code>中的文件按照此法顺序解析。所以在某些情况下，解析的规则非常重要。这里还是引用一下文档中的说法</p><blockquote><p>通常，您希望在缺省值之前解析您自己的规则，因此我建议您在/etc/udev/rules.d/10-local.rules上创建一个文件，并将所有规则写入该文件。</p></blockquote><p>在规则文件中，以<code>#</code>开头的行被视为注释。每隔一个非空行就是一个规则，规则之间不能跨越多行。</p><p>一个设备可以由多个规则机型匹配。udev在发现匹配规则时不会停止处理，会继续搜索并且尝试应用它所知道的每个规则。</p><h3 id="0x22-语法规则"><a href="#0x22-语法规则" class="headerlink" title="0x22 语法规则"></a>0x22 语法规则</h3><p>每个规则都由一系列的<code>key-value</code>对组成。这些对之间由都好分割。识别规则所适用设备的条件是键的匹配。一个规则至少要有一个匹配键和一个赋值键。</p><p>下面举一个简单的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KERNEL==&quot;hdb&quot;,NAME=&quot;my_spare_disk&quot;</span><br></pre></td></tr></table></figure><p>这里包括了一个匹配键和一个赋值键。匹配键使用的相等运算符进行匹配<code>==</code>（后续会进行详细介绍）。赋值键通过赋值运算符<code>=</code>进行值的赋予。</p><blockquote><p>注意udev不支持任何形式的行延续。不要在您的规则中插入任何换行符，因为这将导致udev将您的一个规则视为多个规则，并且不能按预期工作。</p></blockquote><h3 id="0x23-udev-key-value操作符"><a href="#0x23-udev-key-value操作符" class="headerlink" title="0x23 udev key/value操作符"></a>0x23 udev key/value操作符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">匹配或赋值</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:center">匹配</td><td style="text-align:center">相等比较</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">匹配</td><td style="text-align:center">不等比较</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">赋值</td><td style="text-align:center">分配一个特定的值给该键，他可以覆盖之前的赋值。</td></tr><tr><td style="text-align:center">+=</td><td style="text-align:center">赋值</td><td style="text-align:center">追加特定的值给已经存在的键</td></tr><tr><td style="text-align:center">:=      赋值       。</td><td style="text-align:center">赋值</td><td style="text-align:center">分配一个特定的值给该键，后面的规则不可能覆盖它</td></tr></tbody></table></div><h3 id="0x24-udev规则匹配键"><a href="#0x24-udev规则匹配键" class="headerlink" title="0x24 udev规则匹配键"></a>0x24 udev规则匹配键</h3><blockquote><p>ACTION： 事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。</p><p>KERNEL： 内核设备名称，例如：sda, cdrom。</p><p>DEVPATH：设备的 devpath 路径。</p><p>SUBSYSTEM： 设备的子系统名称，例如：sda 的子系统为 block。</p><p>BUS： 设备在 devpath 里的总线名称，例如：usb。</p><p>DRIVER： 设备在 devpath 里的设备驱动名称，例如：ide-cdrom。</p><p>ID： 设备在 devpath 里的识别号。</p><p>SYSFS{filename}： 设备的 devpath 路径下，设备的属性文件“filename”里的内容。</p><p>例如：SYSFS{model}==“ST936701SS”表示：如果设备的型号为 ST936701SS，则该设备匹配该 匹配键。</p><p>在一条规则中，可以设定最多五条 SYSFS 的 匹配键。</p><p>ENV{key}： 环境变量。在一条规则中，可以设定最多五条环境变量的 匹配键。</p><p>PROGRAM：调用外部命令。</p><p>RESULT： 外部命令 PROGRAM 的返回结果。</p></blockquote><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROGRAM==&quot;/lib/udev/scsi_id -g -s $devpath&quot;, RESULT==&quot;35000c50000a7ef67&quot;</span><br></pre></td></tr></table></figure><p>可以解释为调用外部命令 /lib/udev/scsi_id查询设备的 SCSI ID，如果返回结果为 35000c50000a7ef67，则该设备匹配该 匹配键。</p><h3 id="0x25-值和可替换操作符"><a href="#0x25-值和可替换操作符" class="headerlink" title="0x25 值和可替换操作符"></a>0x25 值和可替换操作符</h3><p>介绍完操作符以及键后，我们还要来介绍规则文件中的值。在udev中，用户可以直接定制udev规则文件的值，也可以引用下列操作替换符来进行。</p><blockquote><p>$kernel, %k：设备的内核设备名称，例如：sda、cdrom。</p><p>$number, %n：设备的内核号码，例如：sda3 的内核号码是 3。</p><p>$devpath, %p：设备的 devpath路径。</p><p>$id, %b：设备在 devpath里的 ID 号。</p><p>$sysfs{file}, %s{file}：设备的 sysfs里 file 的内容。其实就是设备的属性值。</p><p>例如：$sysfs{size} 表示该设备 ( 磁盘 ) 的大小。</p><p>$env{key}, %E{key}：一个环境变量的值。</p><p>$major, %M：设备的 major 号。</p><p>$minor %m：设备的 minor 号。</p><p>$result, %c：PROGRAM 返回的结果。</p><p>$parent, %P：父设备的设备文件名。</p><p>$root, %r：udev_root的值，默认是 /dev/。</p><p>$tempnode, %N：临时设备名。</p><p>%%：符号 % 本身。</p><p>$$：符号 $ 本身。</p></blockquote><h2 id="0x03-规则文件的编写"><a href="#0x03-规则文件的编写" class="headerlink" title="0x03 规则文件的编写"></a>0x03 规则文件的编写</h2><p>从上面的介绍和学习来说，可以见到udev的规则和语法都较为简单。只要有了匹配键和赋值键就能编写我们想要的规则文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KERNEL==&quot;tty&quot;, NAME=&quot;%k&quot;, GROUP=&quot;tty&quot;, MODE=&quot;0666&quot;, OPTIONS=&quot;last_rule&quot;</span><br></pre></td></tr></table></figure><p>该规则说明：如果有一个设备的内核设备名称为tty(KERNEL==”tty”)，那么设置新的权限为0600(MODE=”0666”)，所在的组是tty(GROUP=”tty”)。它也设置了一个特别的设备文件名:%K。在这里例子里，%k代表设备的内核名字。那也就意味着内核识别出这些设备是什么名字，就创建什么样的设备文件名。</p><p>在这里的关键就是<code>==</code>的匹配情况。那么对于一个设备怎么获取设备的属性呢？udevadm提供了一种方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">udevadm info -q path -n $(filepath) </span><br><span class="line">udevadm info -a -p $(filepath)</span><br></pre></td></tr></table></figure><p>其中<code>udevadm info -q path -n $(filepath)</code> 能够返回sysfs中的设备路径，将这一设备路径放入<code>udevadm info -a -p $(filepath)</code>的<code>filepath</code>中就能获得设备的结果信息。例子如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost samples]# udevadm info -q path -n /dev/nr0lun0</span><br><span class="line">/devices/virtual/block/nr0lun0</span><br><span class="line">[root@localhost samples]# udevadm info -a -p /devices/virtual/block/nr0lun0</span><br><span class="line"></span><br><span class="line">Udevadm info starts with the device specified by the devpath and then</span><br><span class="line">walks up the chain of parent devices. It prints for every device</span><br><span class="line">found, all possible attributes in the udev rules key format.</span><br><span class="line">A rule to match, can be composed by the attributes of the device</span><br><span class="line">and the attributes from one single parent device.</span><br><span class="line"></span><br><span class="line">  looking at device &#x27;/devices/virtual/block/nr0lun0&#x27;:</span><br><span class="line">    KERNEL==&quot;nr0lun0&quot;</span><br><span class="line">    SUBSYSTEM==&quot;block&quot;</span><br><span class="line">    DRIVER==&quot;&quot;</span><br><span class="line">    ATTR&#123;alignment_offset&#125;==&quot;0&quot;</span><br><span class="line">    ATTR&#123;capability&#125;==&quot;10&quot;</span><br><span class="line">    ATTR&#123;discard_alignment&#125;==&quot;0&quot;</span><br><span class="line">    ATTR&#123;ext_range&#125;==&quot;64&quot;</span><br><span class="line">    ATTR&#123;hidden&#125;==&quot;0&quot;</span><br><span class="line">    ATTR&#123;inflight&#125;==&quot;       0        0&quot;</span><br><span class="line">    ATTR&#123;range&#125;==&quot;64&quot;</span><br><span class="line">    ATTR&#123;removable&#125;==&quot;0&quot;</span><br><span class="line">    ATTR&#123;ro&#125;==&quot;0&quot;</span><br><span class="line">    ATTR&#123;size&#125;==&quot;15628107776&quot;</span><br><span class="line">    ATTR&#123;stat&#125;==&quot;    4457        0    47216      616     6364        0  8391544 11071107        0    21985 11071723        0        0        0        0 &quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样我们就可以通过信息去进行匹配。比如上面这个设备我们就可以匹配 <code>KERNEL==&quot;nr[0-9]lun0&quot;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Udev规则修改学习&quot;&gt;&lt;a href=&quot;#Udev规则修改学习&quot; class=&quot;headerlink&quot; title=&quot;Udev规则修改学习&quot;&gt;&lt;/a&gt;Udev规则修改学习&lt;/h1&gt;&lt;h2 id=&quot;0x01-udev简介&quot;&gt;&lt;a href=&quot;#0x01-udev简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 udev简介&quot;&gt;&lt;/a&gt;0x01 udev简介&lt;/h2&gt;&lt;p&gt;udev的全称是Dynamic device management,也就是曾经的&lt;code&gt;devfs&lt;/code&gt;的继任者。&lt;code&gt;udev&lt;/code&gt;的主要目的是为动态&lt;code&gt;/dev&lt;/code&gt;目录提供用户空间的解决方案，以及实现持久的设备命名。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Udev规则" scheme="http://yokeso.github.io/tags/Udev%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>linux驱动学习之驱动代码结构</title>
    <link href="http://yokeso.github.io/2023/03/05/linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yokeso.github.io/2023/03/05/linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-05T08:59:06.000Z</published>
    <updated>2023-06-27T15:18:18.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux驱动学习：驱动代码结构"><a href="#linux驱动学习：驱动代码结构" class="headerlink" title="linux驱动学习：驱动代码结构"></a>linux驱动学习：驱动代码结构</h1><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01.前言"></a>0x01.前言</h2><p>对刚开始接触Linux驱动代码的新人来说，最困难的是面对着一个项目无从下手。对于传统的单片机来说，许多操作需要做的只是向对应的寄存器中写入所需的数值。然而同样的代码到了linux驱动中，就需要许多的回调函数，指针和结构体。而且伴随着驱动操作的逐渐复杂化，面对着一个驱动中的诸多文件更是不知所云。所以对于初学者来说最重要的就是要了解：linux驱动代码究竟做了什么，linux驱动代码结构究竟是什么？</p><span id="more"></span><p>借用找教程时候看到的一段话：</p><blockquote><p>说易行难，很多新人、甚至工作1-2年的开发者刚接触Linux内核时，别说写了，看内核代码可能都是一脸懵逼：明明是C语言，但是就是看不懂是什么意思，除了根据函数名、函数参数、函数的返回值以及注释，了解整个函数的基本功能外，一旦分析其细节，你会发现，寸步难行，每一行代码似乎都深不可测，仿佛蕴含着极大的能量</p></blockquote><p>从我开始学习linux驱动的时候，这些问题就一直环绕着我。但是却没有在网上找到一篇全面的扫盲文章。现在我希望以初学者的身份来完善出一篇专门针对于入门小白的文章。希望这篇文章能帮助到需要入门linux驱动的人。</p><p>第二章简要介绍了一点基础性的知识，需要直接看内核代码结构的可以直接前往第三章观看。</p><h2 id="0x02-基础知识"><a href="#0x02-基础知识" class="headerlink" title="0x02.基础知识"></a>0x02.基础知识</h2><h3 id="0x21-设备驱动类型"><a href="#0x21-设备驱动类型" class="headerlink" title="0x21 设备驱动类型"></a>0x21 设备驱动类型</h3><p>学习Linux驱动，首先不得不提的就是linux系统本身。</p><p>Linux遵循着一切皆文件的守则，把所有的外部设备都看作是文件，可以使用与调用文件系统相同的方法来读写外部设备。但外部设备的种类千奇百怪，怎么才能让用户无差别使用这些设备呢？这就是驱动存在的意义：通过内部定义好的编程接口，对用户隐藏了设备的工作细节，从而可以使用户通过一套标准化调用来使用设备。</p><p>对于多种多样的设备类型，Linux做了一件艰难而又伟大的事情，把他们的驱动归结为三大类：字符设备驱动，块设备驱动以及网络设备驱动。</p><p><strong>字符设备</strong>：需要字节顺序读写的设备。不能随机读写。字符设备是面向流的设备。常见的如鼠标，键盘，led等。</p><p><strong>块设备驱动</strong>：可以从设备的任意位置读取一定长度的数据设备，比如硬盘，SD卡等设备均是块设备。</p><p><strong>网络设备</strong>：网络设备不会在<code>/dev</code>中列出，不是针对文件的操作，而是使用专门的网络接口实现。应用设备不能直接访问网络驱动程序。</p><p>三种设备在Linux中的位置可以用一张图片来描述。如图所示：</p><p><img src="/2023/03/05/linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/image-20230228174416669-1680624988488.png" alt="Linux系统结构图"></p><h3 id="0x22-Linux驱动编译和加载"><a href="#0x22-Linux驱动编译和加载" class="headerlink" title="0x22 Linux驱动编译和加载"></a>0x22 Linux驱动编译和加载</h3><p>linux设备驱动属于内核的一部分，所以编译加载的时候都需要内核的帮助。Linux内核的一个模块可以通过两种方式被编译和加载。</p><ul><li>直接编译进内核，同Linux启动的同时进行加载</li><li>单独编译成模块，需要的时候动态加载到内核中，不需要的时候进行卸载</li></ul><p>对于正常的C程序来说，需要有一个main函数来提供程序的入口。所以说很多初学者在看内核源码的时候最迷茫的就是寻找不到函数入口。</p><p>这是因为对于驱动程序来说，程序不是一直运行的。驱动程序运行在内核中的内核态。会在初始化完成之后不再运行，等待系统调用的时候再执行相应操作。也正是因为驱动程序属于内核的一部分。所以驱动程序不能用标准的C库，而要使用linux内核库进行开发。这也是开发C程序的人开始看内核代码时迷茫的原因之一。</p><p>驱动编译和加载的具体步骤在这里不作为详述内容。后续我会再写一篇文章来讲述这个具体步骤。（挖坑）</p><h2 id="0x03-驱动代码的结构"><a href="#0x03-驱动代码的结构" class="headerlink" title="0x03 驱动代码的结构"></a>0x03 驱动代码的结构</h2><h3 id="0x31-驱动的加载和卸载（入口函数）"><a href="#0x31-驱动的加载和卸载（入口函数）" class="headerlink" title="0x31 驱动的加载和卸载（入口函数）"></a>0x31 驱动的加载和卸载（入口函数）</h3><p>有了上面的这些信息，我们就可以来简单的了解以下Linux驱动的结构了。由于我个人最近在看NV的开源项目，所以直接用这个项目作为例子进行描述。</p><p>驱动最重要的就是要进行注册操作。注册操作使用的是<code>__init</code>宏，比如英伟达开放的某个仓库中的<code>nvfs-core.c</code>文件中的初始化函数就为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize nvfs driver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">nvfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><p>在初始化中最重要的是注册，注册中重要的是调用内核中的函数<code>register_chrdev()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pr_info(<span class="string">&quot;nvidia_fs: Initializing nvfs driver module\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">major_number = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;nvfs_dev_fops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (major_number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;nvidia_fs: failed to register a major number\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> major_number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面代码为例，注册函数注册了驱动的名称<code>DEVICE_NAME</code>，以及驱动的操作跳转表<code>nvfs_dev_fops</code>，操作跳转表是整个驱动的灵魂。我会在后续说明。</p><p>调用注册函数之后，还会再调用一些初始化函数，这个地方不同的驱动需要初始化的数据不尽相同，需要用户自行定义。</p><p>在NVIDIA的这个驱动中，由于需要注册多个设备，驱动中还调用了两个内核函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvfs_class = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line">nvfs_device[i] = device_create(nvfs_class, <span class="literal">NULL</span>, MKDEV(major_number, i), <span class="literal">NULL</span>, DEVICE_NAME<span class="string">&quot;%d&quot;</span>, i);</span><br></pre></td></tr></table></figure><p>他们的原型分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">linux<span class="number">-2.6</span><span class="number">.22</span>/include/linux/device.h</span><br><span class="line"><span class="function">struct class *<span class="title">class_create</span><span class="params">(struct <span class="keyword">module</span> *owner, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line">    class_create - create a struct class structure</span><br><span class="line">    @owner: pointer to the <span class="keyword">module</span> that is to <span class="string">&quot;own&quot;</span> <span class="keyword">this</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span></span></span><br><span class="line"><span class="class">    @<span class="title">name</span>:</span> pointer to a <span class="built_in">string</span> <span class="keyword">for</span> the name of <span class="keyword">this</span> class.</span><br><span class="line">        </span><br><span class="line">linux<span class="number">-2.6</span><span class="number">.22</span>/include/linux/device.h</span><br><span class="line"><span class="function">struct device *<span class="title">device_create</span><span class="params">(struct class *cls, </span></span></span><br><span class="line"><span class="function"><span class="params">                             struct device *parent, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">dev_t</span> devt, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">void</span> *drvdata, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    class_device_create - creates a <span class="class"><span class="keyword">class</span> <span class="title">device</span> <span class="title">and</span> <span class="title">registers</span> <span class="title">it</span> <span class="title">with</span> <span class="title">sysfs</span></span></span><br><span class="line"><span class="class">    @<span class="title">cls</span>:</span> pointer to the <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">that</span> <span class="title">this</span> <span class="title">device</span> <span class="title">should</span> <span class="title">be</span> <span class="title">registered</span> <span class="title">to</span>.</span></span><br><span class="line"><span class="class">    @<span class="title">parent</span>:</span> pointer to the parent <span class="class"><span class="keyword">struct</span> <span class="title">class_device</span> <span class="title">of</span> <span class="title">this</span> <span class="title">new</span> <span class="title">device</span>, <span class="title">if</span> <span class="title">any</span>.</span></span><br><span class="line"><span class="class">    @<span class="title">devt</span>:</span> the <span class="keyword">dev_t</span> <span class="keyword">for</span> the <span class="keyword">char</span> device to be added.</span><br><span class="line">    @device: a pointer to a <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">that</span> <span class="title">is</span> <span class="title">assiociated</span> <span class="title">with</span> <span class="title">this</span> <span class="keyword">class</span> <span class="title">device</span>.</span></span><br><span class="line"><span class="class">    @<span class="title">fmt</span>:</span> <span class="built_in">string</span> <span class="keyword">for</span> the <span class="class"><span class="keyword">class</span> <span class="title">device</span>&#x27;<span class="title">s</span> <span class="title">name</span></span></span><br></pre></td></tr></table></figure><p>通过两个函数原型以及描述可以看出，<code>class_create</code>的目的是创建一个驱动类，然后通过<code>device_create</code>函数为类创建一个或多个设备。</p><p>总结下来来看，入口<code>__init</code>函数的流程就清晰了很多。最后把整个函数放上来，帮助把流程捋顺。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize nvfs driver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">nvfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;nvidia_fs: Initializing nvfs driver module\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">major_number = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;nvfs_dev_fops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (major_number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;nvidia_fs: failed to register a major number\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> major_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;nvidia_fs: registered correctly with major number %d\n&quot;</span>,</span><br><span class="line">major_number);</span><br><span class="line"></span><br><span class="line">nvfs_class = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(nvfs_class)) &#123;</span><br><span class="line">unregister_chrdev(major_number, DEVICE_NAME);</span><br><span class="line">pr_err(<span class="string">&quot;nvidia_fs: Failed to register device class\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(nvfs_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nvfs_class-&gt;devnode = nvfs_devnode;</span><br><span class="line"></span><br><span class="line">nvfs_set_device_count(nvfs_max_devices);</span><br><span class="line"></span><br><span class="line">nvfs_curr_devices = nvfs_get_device_count();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nvfs_curr_devices; i++) &#123;</span><br><span class="line">nvfs_device[i] = device_create(nvfs_class, <span class="literal">NULL</span>,</span><br><span class="line">MKDEV(major_number, i),</span><br><span class="line"><span class="literal">NULL</span>, DEVICE_NAME<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(nvfs_device[i])) &#123;</span><br><span class="line">class_destroy(nvfs_class);</span><br><span class="line">unregister_chrdev(major_number, DEVICE_NAME);</span><br><span class="line">pr_err(<span class="string">&quot;nvidia_fs: Failed to create the device\n&quot;</span>);</span><br><span class="line">i -= <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Cleanup all the previous devices</span></span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize meta group data structures</span></span><br><span class="line">        nvfs_mgroup_init();</span><br><span class="line">atomic_set(&amp;nvfs_shutdown, <span class="number">0</span>);</span><br><span class="line">init_waitqueue_head(&amp;wq);</span><br><span class="line">nvfs_proc_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAULT_INJECTION</span></span><br><span class="line">nvfs_init_debugfs();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">nvfs_stat_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_DISCONTIG_ADDR</span></span><br><span class="line">nvfs_init_simulated_address();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">nvfs_fill_gpu2peer_distance_table_once();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">device_destroy(nvfs_class, MKDEV(major_number,i));</span><br><span class="line">i -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对驱动的入口函数有一个简要的了解之后，最好奇的应该是出口函数的书写方式。一般来说，出口函数和入口函数都会放在同一个文件的上下函数。现在就来看一下。</p><p>与入口函数相同，驱动的出口函数也会有宏标识<code>__exit</code>，并且执行了与注册函数几乎完全相反的操作。</p><p>正常来说除了用户自定义的注销函数之外，还需要调用<code>unregister_chrdev</code>函数进行注销，流程就结束了。</p><p>但是对于NV的这个驱动来说，由于他在注册的时候注册了多个设备，所以在注销的时候需要多两个步骤。也就是设备的注销以及类的注销。</p><p>由于注销函数很短，所以不做过多讲述。直接把整个函数贴过来留作查看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">nvfs_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">atomic_set(&amp;nvfs_shutdown, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">wait_event_interruptible_timeout(wq,</span><br><span class="line">(nvfs_count_ops() == <span class="number">0</span>),</span><br><span class="line">msecs_to_jiffies(NVFS_HOLD_TIME));</span><br><span class="line">nvfs_dbg(<span class="string">&quot;count_ops :%lu\n&quot;</span>, nvfs_count_ops());</span><br><span class="line">&#125; <span class="keyword">while</span> (nvfs_count_ops());</span><br><span class="line">nvfs_proc_cleanup();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAULT_INJECTION</span></span><br><span class="line">nvfs_free_debugfs();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">nvfs_stat_destroy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nvfs_curr_devices; i++) &#123;</span><br><span class="line">device_destroy(nvfs_class, MKDEV(major_number, i));</span><br><span class="line">&#125;</span><br><span class="line">class_destroy(nvfs_class);</span><br><span class="line">unregister_chrdev(major_number, DEVICE_NAME);</span><br><span class="line">pr_info(<span class="string">&quot;nvidia_fs: driver unloaded successfully\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，声明两个函数后还需要调用一下，调用函数通常在文件的结尾处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(nvfs_init);</span><br><span class="line">module_exit(nvfs_exit);</span><br></pre></td></tr></table></figure><p>这样程序的出入口环节就彻底结束了。</p><h3 id="0x32-驱动中的重要内核数据"><a href="#0x32-驱动中的重要内核数据" class="headerlink" title="0x32 驱动中的重要内核数据"></a>0x32 驱动中的重要内核数据</h3><p>大部分的基础性的驱动操作包括3个重要的内核数据结构，称为file_operations，file，和inode。</p><h4 id="file-operation"><a href="#file-operation" class="headerlink" title="file_operation"></a>file_operation</h4><p>在上一节的入口函数中，我们曾经提及过操作跳转表这个概念。当时是在驱动注册时调用的。现在就是揭开这部分神秘面纱的时候了。</p><p>操作跳转表这个概念其实是我个人的翻译，实际上来说这个是一个叫做<code>file_operation</code>的结构体。这个结构体是将系统调用以及驱动程序关联起来的重要数据结构。操作表中的每个成员都对应着一个函数的指针。而名称则对应着一个系统调用。（对于不支持的操作留作null.）通过这种绑定方式，当系统调用发生时，系统读取跳转表中与调用相应的函数的指针，然后将控制权转交给函数。这样就完成了Linux设备的驱动工作。NV的代码中结构体初始化如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">nvfs_dev_fops</span> =</span> &#123;</span><br><span class="line">.compat_ioctl = nvfs_ioctl,</span><br><span class="line">.unlocked_ioctl = nvfs_ioctl,</span><br><span class="line">.open = nvfs_open,</span><br><span class="line">.release = nvfs_close,</span><br><span class="line">        .mmap = nvfs_mgroup_mmap,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><ul><li>file 结构代表一个打开的文件，它的特点是一个文件可以对应多个file结构。它由内核再open时创建，并传递给在该文件上操作的所有函数，直到最后close函数，在文件的所有实例都被关闭之后，内核才释放这个数据结构。</li><li>在内核源代码中，指向 struct file 的指针通常比称为filp，file结构有以下几个重要的成员：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span>&#123;</span></span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> <span class="keyword">mode_t</span> fmode; <span class="comment">/*文件模式，如FMODE_READ，FMODE_WRITE*/</span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> ......</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> <span class="keyword">loff_t</span> f_pos; <span class="comment">/*loff_t 是一个64位的数，需要时，须强制转换为32位*/</span></span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> f_flags; <span class="comment">/*文件标志，如：O_NONBLOCK*/</span></span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> <span class="keyword">void</span> *private_data; <span class="comment">/*非常重要，用于存放转换后的设备描述结构指针*/</span></span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> .......</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><ul><li>内核用inode 结构在内部表示文件，它是实实在在的表示物理硬件上的某一个文件，且一个文件仅有一个inode与之对应，同样它有二个比较重要的成员：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>&#123;</span></span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> <span class="keyword">dev_t</span> i_rdev; <span class="comment">/*设备编号*/</span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">i_cdev</span>;</span> <span class="comment">/*cdev 是表示字符设备的内核的内部结构*/</span></span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> &#125;;</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> 可以从inode中获取主次设备号，使用下面二个宏：</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> <span class="comment">/*驱动工程师一般不关心这两个宏*/</span></span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">imajor</span><span class="params">(struct inode *inode)</span></span>;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">iminor</span><span class="params">(struct inode *inode)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="0x33-驱动中的模块参数组"><a href="#0x33-驱动中的模块参数组" class="headerlink" title="0x33 驱动中的模块参数组"></a>0x33 驱动中的模块参数组</h3><p>我们可以利用module_param(参数名、参数类型、参数读写属性) 为模块定义一个参数，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *string_test = “<span class="keyword">this</span> is a test”;</span><br><span class="line"><span class="keyword">static</span> num_test = <span class="number">1000</span>;</span><br><span class="line">module_param (num_test,<span class="keyword">int</span>,S_IRUGO);</span><br><span class="line">module_param (steing_test,charp,S_ITUGO);</span><br></pre></td></tr></table></figure><p>在装载模块时，用户可以给模块传递参数，形式为：<code>insmod 模块名 参数名=参数值</code>，如果不传递，则参数使用默认的参数值</p><p>参数的类型可以是：byte,short,ushort,int,uint,long,ulong,charp,bool；</p><p>权限：定义在<code>linux/stat.h</code>中，控制存取权限，<code>S_IRUGO</code>表示所有用户只读；</p><p>模块被加载后，在<code>sys/module/</code>下会出现以此模块命名的目录，当读写权限为零时：表示此参数不存在sysfs文件系统下的文件节点，当读写权限不为零时：此模块的目录下会存在<code>parameters</code>目录，包含一系列以参数名命名的文件节点，这些文件节点的权限值就是传入<code>module_param()</code>的参数读/写权限，而该文件的内容为参数的值。</p><p>除此之外，模块也可以拥有参数数组，形式为：<code>module_param_array(数组名、数组类型、数组长、参数读写权限等)</code>，当不需要保存实际的输入的数组元素的个数时，可以设置“数组长“为0。</p><p>运行insmod时，使用逗号分隔输入的数组元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MODULE_VERSION(TO_STR(MOD_VERS(NVFS_DRIVER_MAJOR_VERSION, NVFS_DRIVER_MINOR_VERSION, NVFS_DRIVER_PATCH_VERSION)));</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;NVIDIA GPUDirect Storage&quot;</span>);</span><br><span class="line">module_param_named(max_devices, nvfs_max_devices, uint, S_IWUSR | S_IRUGO);</span><br><span class="line">MODULE_PARM_DESC(nvfs_max_devices, <span class="string">&quot;number of character devices to expose&quot;</span>);</span><br><span class="line">module_param_named(dbg_enabled, nvfs_dbg_enabled, uint, S_IWUSR | S_IRUGO);</span><br><span class="line">MODULE_PARM_DESC(nvfs_dbg_enabled, <span class="string">&quot;enable debug tracing&quot;</span>);</span><br><span class="line">module_param_named(info_enabled, nvfs_info_enabled, uint, S_IWUSR | S_IRUGO);</span><br><span class="line">MODULE_PARM_DESC(nvfs_info_enabled, <span class="string">&quot;enable info tracing&quot;</span>);</span><br><span class="line">module_param_named(peer_stats_enabled, nvfs_peer_stats_enabled, uint, S_IWUSR | S_IRUGO);</span><br><span class="line">MODULE_PARM_DESC(nvfs_peer_stats_enabled, <span class="string">&quot;enable peer stats&quot;</span>);</span><br><span class="line">module_param_named(rw_stats_enabled, nvfs_rw_stats_enabled, uint, S_IWUSR | S_IRUGO);</span><br><span class="line">MODULE_PARM_DESC(nvfs_rw_stats_enabled, <span class="string">&quot;enable read-write stats&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;linux驱动学习：驱动代码结构&quot;&gt;&lt;a href=&quot;#linux驱动学习：驱动代码结构&quot; class=&quot;headerlink&quot; title=&quot;linux驱动学习：驱动代码结构&quot;&gt;&lt;/a&gt;linux驱动学习：驱动代码结构&lt;/h1&gt;&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01.前言&quot;&gt;&lt;/a&gt;0x01.前言&lt;/h2&gt;&lt;p&gt;对刚开始接触Linux驱动代码的新人来说，最困难的是面对着一个项目无从下手。对于传统的单片机来说，许多操作需要做的只是向对应的寄存器中写入所需的数值。然而同样的代码到了linux驱动中，就需要许多的回调函数，指针和结构体。而且伴随着驱动操作的逐渐复杂化，面对着一个驱动中的诸多文件更是不知所云。所以对于初学者来说最重要的就是要了解：linux驱动代码究竟做了什么，linux驱动代码结构究竟是什么？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux驱动" scheme="http://yokeso.github.io/tags/Linux%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="linux" scheme="http://yokeso.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式开发技巧汇总</title>
    <link href="http://yokeso.github.io/2022/10/12/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://yokeso.github.io/2022/10/12/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</id>
    <published>2022-10-12T02:03:41.000Z</published>
    <updated>2023-05-16T16:07:59.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式开发技巧汇总"><a href="#嵌入式开发技巧汇总" class="headerlink" title="嵌入式开发技巧汇总"></a>嵌入式开发技巧汇总</h1><h2 id="宏定义相关"><a href="#宏定义相关" class="headerlink" title="宏定义相关"></a>宏定义相关</h2><h3 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h3><h1 id="error-可以直接在编译器中打出error，用于必须的配置文件中使用。例如"><a href="#error-可以直接在编译器中打出error，用于必须的配置文件中使用。例如" class="headerlink" title="error 可以直接在编译器中打出error，用于必须的配置文件中使用。例如"></a>error 可以直接在编译器中打出error，用于必须的配置文件中使用。例如</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">error</span>  <span class="meta-string">&quot;please select device name&quot;</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="嵌入式中实现配置文件的方法（工程文件的方式）"><a href="#嵌入式中实现配置文件的方法（工程文件的方式）" class="headerlink" title="嵌入式中实现配置文件的方法（工程文件的方式）"></a>嵌入式中实现配置文件的方法（工程文件的方式）</h3><p>首先建立一个扩展名文件 DEVINFO.txt，扔进文件夹</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DEVINFO.txt</span></span><br><span class="line"><span class="comment">// 设备名，字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEV_NAME    DEFAULT</span></span><br><span class="line"><span class="comment">// 设备ID，U32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEV_ID      0</span></span><br></pre></td></tr></table></figure><p>在.h文件中声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//device.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DEVICE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DEVICE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEVINFO_FILENAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVINFO_FILENAME DEVINFO.txt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Device_printfMsg</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>就可以在.c文件中使用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//device.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;device.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STR(s)  #s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MollocDefineToStr(mal)  _STR(mal)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MollocDefineToStr(DEVINFO_FILENAME) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> devType[] = MollocDefineToStr(DEV_NAME);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> devID = DEV_ID;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> devDName[] = MollocDefineToStr(DEV_NAME) <span class="string">&quot;_&quot;</span> MollocDefineToStr(DEV_ID) <span class="string">&quot;.local&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Device_printfMsg</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Device: %s\r\n&quot;</span> , devType);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;DevID: %u\r\n&quot;</span> , devID);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;DomainName: %s\r\n&quot;</span> , devDName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在.c文件中最重要的是这样一句话</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MollocDefineToStr(DEVINFO_FILENAME) </span></span><br></pre></td></tr></table></figure><p>这句话在经过编译器编译后会变成  #include “DEVINFO.txt”。这种成组绑定，固定的配置信息很适合用这种方式耦合进不同的配置文件中去。</p><h3 id="一些比较奇特的宏"><a href="#一些比较奇特的宏" class="headerlink" title="一些比较奇特的宏"></a>一些比较奇特的宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __JOIN(x,y) x##y<span class="comment">// 连接标识符(非字符串连接成非字符串，字符串连接成字符串)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CHAR(x)   #@x<span class="comment">// 将参数转换成字符(x长度小于5，否则会溢出)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __S(x)   #x<span class="comment">// 将x变成字符串（如果x是宏也不展开）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ST(x)   _T(#x)<span class="comment">// 将x变成T字符串（如果x是宏也不展开）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _S(x)   __S(x)<span class="comment">// 将x变成字符串（如果x是宏，展开)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ST(x)   __ST(x)<span class="comment">// 将x变成字符串（如果x是宏，展开)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TO_STR(x, y) _S(x) <span class="meta-string">&quot;&quot;</span> _S(y)<span class="comment">// 将参数连接并转成字符串(遇宏则展开)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TO_STRT(x, y) _T( _S(x) <span class="meta-string">&quot;&quot;</span> _S(y) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">testStrMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ab = <span class="number">12</span>;</span><br><span class="line">    assert(__JOIN(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">12</span>); <span class="comment">// 常量连接组合</span></span><br><span class="line">    assert(__JOIN(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>) == <span class="string">&quot;ab&quot;</span>); <span class="comment">// 字符串连接</span></span><br><span class="line">    assert(__JOIN(a, b) == <span class="number">12</span>); <span class="comment">// 变量组合连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> a = __CHAR(<span class="number">65</span>);</span><br><span class="line">    assert(a == &#x27;65&#x27;);</span><br><span class="line">    assert(__CHAR(中国) == &#x27;中国&#x27;);</span><br><span class="line">    <span class="keyword">auto</span> cc = __CHAR(PNG);</span><br><span class="line">    assert(__CHAR(PNG) == <span class="number">0x504e47</span>);<span class="comment">// PNG 的 hex即是 0x504e47</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接转成字符串</span></span><br><span class="line">    assert(__S(<span class="number">65</span>) == <span class="string">&quot;65&quot;</span>);</span><br><span class="line">    assert(__ST(<span class="number">65</span>) == _T(<span class="string">&quot;65&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_s <span class="meta-string">&quot;a&quot;</span> </span></span><br><span class="line">    assert(__S(test) == <span class="string">&quot;test&quot;</span>); <span class="comment">// test是宏，但__S里有#，所以后续内容不展开</span></span><br><span class="line">    assert(__ST(test) == _T(<span class="string">&quot;test&quot;</span>)); <span class="comment">// test是宏，但__S里有#，所以后续内容不展开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宏展开转换成字符串</span></span><br><span class="line">    assert(_S(test) == <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    assert(_ST(test) == _T(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    assert(_TO_STRT(test, <span class="number">123</span>) == _T(<span class="string">&quot;a123&quot;</span>));</span><br><span class="line">    assert(_TO_STR(test, <span class="number">123</span>) == <span class="string">&quot;a123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宏嵌套效果</span></span><br><span class="line">    <span class="keyword">auto</span> b = _TO_STR(__S(test), <span class="number">123</span>);</span><br><span class="line">    assert(_TO_STR(__S(test), <span class="number">123</span>) == <span class="string">&quot;\&quot;test\&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> c = _TO_STR(_S(test), <span class="number">123</span>);</span><br><span class="line">    assert(_TO_STR(_S(test), <span class="number">123</span>) == <span class="string">&quot;\&quot;a\&quot;123&quot;</span>);  <span class="comment">//_S(test) 展开成了a</span></span><br><span class="line">    assert(_TO_STR(_S(test), _TO_STR(<span class="number">123</span>, <span class="number">456</span>)) == <span class="string">&quot;\&quot;a\&quot;\&quot;123\&quot; \&quot;\&quot; \&quot;456\&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="print是否输出设置"><a href="#print是否输出设置" class="headerlink" title="print是否输出设置"></a>print是否输出设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DEBUG_MSG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DEBUG_MSG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> _dbg_printf0(format)                   ((void)printf(format))</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> _dbg_printf1(format,p1)                ((void)printf(format,p1))</span></span><br><span class="line">  ……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> _dbg_printf0(format)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> _dbg_printf1(format,p1)</span></span><br><span class="line">  ……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样，只要在各个模块中引用这个文件就可以用统一的接口输出调试信息。在主配置文件中定义_DEBUG 所有的调试printf就是真实的printf，否则作为空语句无意义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DebugMsg.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Device_printfMsg</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  _dbg_printf0(<span class="string">&quot;Device_printfMsg called.\r\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Device: %s\r\n&quot;</span> , devType);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;DevID: %u\r\n&quot;</span> , devID);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;DomainName: %s\r\n&quot;</span> , devDName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;嵌入式开发技巧汇总&quot;&gt;&lt;a href=&quot;#嵌入式开发技巧汇总&quot; class=&quot;headerlink&quot; title=&quot;嵌入式开发技巧汇总&quot;&gt;&lt;/a&gt;嵌入式开发技巧汇总&lt;/h1&gt;&lt;h2 id=&quot;宏定义相关&quot;&gt;&lt;a href=&quot;#宏定义相关&quot; class=&quot;headerlink&quot; title=&quot;宏定义相关&quot;&gt;&lt;/a&gt;宏定义相关&lt;/h2&gt;&lt;h3 id=&quot;error&quot;&gt;&lt;a href=&quot;#error&quot; class=&quot;headerlink&quot; title=&quot;#error&quot;&gt;&lt;/a&gt;#error&lt;/h3&gt;&lt;h1 id=&quot;error-可以直接在编译器中打出error，用于必须的配置文件中使用。例如&quot;&gt;&lt;a href=&quot;#error-可以直接在编译器中打出error，用于必须的配置文件中使用。例如&quot; class=&quot;headerlink&quot; title=&quot;error 可以直接在编译器中打出error，用于必须的配置文件中使用。例如&quot;&gt;&lt;/a&gt;error 可以直接在编译器中打出error，用于必须的配置文件中使用。例如&lt;/h1&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;error&lt;/span&gt;  &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;please select device name&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="http://yokeso.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="技巧" scheme="http://yokeso.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>关系模型之关系演算</title>
    <link href="http://yokeso.github.io/2022/01/18/05%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/"/>
    <id>http://yokeso.github.io/2022/01/18/05%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:11:19.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关系模型之关系演算"><a href="#关系模型之关系演算" class="headerlink" title="关系模型之关系演算"></a>关系模型之关系演算</h1><h2 id="1-关系演算之元组演算"><a href="#1-关系演算之元组演算" class="headerlink" title="1.关系演算之元组演算"></a>1.关系演算之元组演算</h2><ul><li>关系演算以数理逻辑中的谓词演算为基础</li><li>是描述关系运算的另一种思维方式</li></ul><span id="more"></span><ul><li>关系演算根据谓词变量不同，分为关系元组演算和关系域演算</li><li>基本形式：${t|P(t)}$表示使用谓词P为真的元组t的集合<ul><li>t是元组变量</li><li>$t\in r$表示元组在关系r中</li><li>t[A]表示元组t的分量，即t在属性A上的值</li><li>P是与谓词逻辑相似的公式，P(t)表示以元组t为变量的公式</li><li>可以递归定义</li></ul></li></ul><p><img src="/2022/01/18/05%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/image-20210120162850304.png" alt="image-20210120162850304"></p><p><img src="/2022/01/18/05%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/image-20210120194242429.png" alt="image-20210120194242429"></p><h2 id="2-关系演算之关系域演算"><a href="#2-关系演算之关系域演算" class="headerlink" title="2.关系演算之关系域演算"></a>2.关系演算之关系域演算</h2><p>关系域演算公式：</p><p>关系域演算的基本形式：${<x_1,x_2,...,x_n>|p(x_1,x_2,…,x_n)}$</x_1,x_2,...,x_n></p><p>其中，$x_1$代表域变量或常量，P为以$x_1$为变量的公式公式P可以递归构造</p><ul><li><p>三种形式的原子公式</p><ul><li><p>$<x_1,x_2,...,x_n>\in R$。其中$x_i$代表域变量或常量，表示由域变量构成的$<x_1,x_2,...,x_n>$是属于关系R的</x_1,x_2,...,x_n></x_1,x_2,...,x_n></p></li><li><p>$x\theta y$。其中，域变量x与常量c之间满足比较关系$\theta$，$\theta$是比较运算符$&lt;,\leq,=,&lt;&gt;,&gt;,\geq$</p></li><li>$x\theta y$。其中，域变量x与常量y之间满足比较关系$\theta$，</li></ul></li><li><p>如果p是公式，那么$\lnot p$也是公式</p></li><li>如果P1,P2 是公式。那么$P1\and P2,P1\or P2$也是公式</li><li>如果P是公式，x是域变量，则$\exists (x)(P(x))$和$\forall (x)(P(x))$也是公式、</li><li>需要时可加括弧</li><li>上述运算符的优先次序自高至底为：括弧；$\theta；\exists; \forall;\lnot;\and;\or$</li><li>公式只限于以上形式</li></ul><h2 id="域演算与元组演算的区别"><a href="#域演算与元组演算的区别" class="headerlink" title="域演算与元组演算的区别"></a>域演算与元组演算的区别</h2><p>元组演算的基本形式：${t|p(t)}$</p><p>域演算的基本形式：${<x_1,x_2,...,x_n>|P(x_1,x_2,…,x_n)}$</x_1,x_2,...,x_n></p><p>元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后找到元组分组，然后再找到元组分量，进行谓词判断。</p><p>域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否满足谓词判断。</p><p>公式的运算符是相同的，之有其中的变量不同。</p><h2 id="域演算语言QBE"><a href="#域演算语言QBE" class="headerlink" title="域演算语言QBE"></a>域演算语言QBE</h2><p><img src="/2022/01/18/05%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/image-20210122184553797-1684253458546.png" alt="image-20210122184553797"></p><p>QBE操作框架由四个部分组成</p><ul><li>关系名区：用于书写欲待查询的关系名</li><li>属性名区：用于显示对应关系名区关系的所有属性名</li><li>操作命令区：用于书写查询操作的命令</li><li>查询条件区：用于书写查询条件</li></ul><p><img src="/2022/01/18/05%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/image-20210122190150563.png" alt="image-20210122190150563"></p><p>QBE操作命令</p><ul><li>Print或P．——显示输出命令</li><li>Delete或D．——删除操作</li><li>Insert或I．——插入操作</li><li>Update或Ｕ．——更新操作</li></ul><p>QBE的查询条件 —不同属性上的与条件</p><ul><li>QBE不同属性上的与条件可以写在同一行中</li></ul><p>QBE的查询条件—示例元素与投影</p><ul><li><p>条件$\theta$参量中的参量也可以是域参量,用任何一个值(不必是结果中的值)带有下划线表示,被称为示例元素.示例元素下划线上卖弄的值不起作用,被当做变量名用来对待,只用于占位或是链接条件.不带下划线的则是构成实际条件一部分的值</p></li><li><p>当不是显示出所有内容时,可在条件区对应要显示的列下面书写显示输出命令(投影运算).</p></li></ul><p>QBE的查询条件—用示例元素实现与运算和或运算</p><p><img src="/2022/01/18/05%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/image-20210122205710899.png" alt="image-20210122205710899"></p><h2 id="关系运算的安全性"><a href="#关系运算的安全性" class="headerlink" title="关系运算的安全性"></a>关系运算的安全性</h2><p><strong>不产生无限关系和无穷验证的运算被称为是安全的</strong></p><ul><li><p>关系代数是一种集合运算，是安全的</p><ul><li>集合本身是有限的，有限元素集合的有限次运算仍旧是有限的</li></ul></li><li><p>关系演算不一定是安全的</p><ul><li>例如${t|\lnot (R(t)),},{t|R(t)\or t[2]&gt;3}$可能表示无限关系</li><li>R(t)是有限的，但不在R(t)中的元素就可能是无限的</li><li>再例如：$(\exists u)(\omega (u))$，$(\forall u)(\omega (u))$</li><li>前者称为“假验证”，即验证所有元素是否都使得$\omega (u)$为false，后者被称为“真验证”，即验证所有元素是否都使得$\omega (u)$为true。检验所有元素就可能造成正无穷</li></ul></li><li><p>对关系演算需要施加约束条件，即任何一个公式都要在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性</p></li></ul><h3 id="安全约束有限集合DOM"><a href="#安全约束有限集合DOM" class="headerlink" title="安全约束有限集合DOM"></a>安全约束有限集合DOM</h3><ul><li>DOM$(\psi)$是一个有限集合，其中的每个符号要么是$\psi$中明显出现的符号，要么是出现在$\psi$ 中的某个关系R的某元组分量</li><li>DOM主要用于约束$\psi$中的一些谓词的计算范围，它不必是最小集合</li></ul><h3 id="元组安全演算表达式"><a href="#元组安全演算表达式" class="headerlink" title="元组安全演算表达式"></a>元组安全演算表达式</h3><p>满足下面三个条件的元组演算表达式${t|\psi(t)}$称为安全表达式</p><ul><li>只要t满足$\psi$，他的每个分量就是DOM$(\psi)$的一个成员</li><li>${t|\psi(t)}$中t的取值只能是DOM中的值，是有限的</li><li>对于$\psi$中形如$(\exists u)(\omega (u))$的子表达式，若u 满足w，则u的每个分量都是DOM(w)的成员</li><li>${t|\psi(t)}$中的每个$(\exists u)(\omega (u))$的子表达式，只需验证DOM中的元素是否有使$\omega (u)$为真的元素，已经明确其都不满足$\omega (u)$，无需验证</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关系模型之关系演算&quot;&gt;&lt;a href=&quot;#关系模型之关系演算&quot; class=&quot;headerlink&quot; title=&quot;关系模型之关系演算&quot;&gt;&lt;/a&gt;关系模型之关系演算&lt;/h1&gt;&lt;h2 id=&quot;1-关系演算之元组演算&quot;&gt;&lt;a href=&quot;#1-关系演算之元组演算&quot; class=&quot;headerlink&quot; title=&quot;1.关系演算之元组演算&quot;&gt;&lt;/a&gt;1.关系演算之元组演算&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关系演算以数理逻辑中的谓词演算为基础&lt;/li&gt;
&lt;li&gt;是描述关系运算的另一种思维方式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关系代数</title>
    <link href="http://yokeso.github.io/2022/01/18/04%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    <id>http://yokeso.github.io/2022/01/18/04%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:08:25.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="04-关系代数"><a href="#04-关系代数" class="headerlink" title="04 关系代数"></a>04 关系代数</h1><ul><li>基本操作：并、差、积、选择、投影（更名）</li><li>扩展操作：交、连接、除</li></ul><span id="more"></span><p>关系代数操作以一个或多个关系为输入，结果是一个新的关系</p><p>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性</p><h2 id="关系代数基本操作"><a href="#关系代数基本操作" class="headerlink" title="关系代数基本操作"></a>关系代数基本操作</h2><p>某些操作，如并、差、交等，需要满足“并相容性”</p><ul><li>两个关系的属性数目相同</li><li>两个关系对应位置的属性的域相同</li></ul><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><h6 id="并"><a href="#并" class="headerlink" title="并"></a>并</h6><ul><li>表示出现在关系R中或出现在关系S中的元组，</li></ul><ul><li>数学描述：$R\cup S={ t|t\in R \cup t \in S} $</li><li>并运算是将两个元组合并成一个关系，在合并时去掉重复的元组</li><li>$R\cup S$与$S\cup R$运算结果是同一个关系</li></ul><h6 id="差"><a href="#差" class="headerlink" title="差"></a>差</h6><ul><li>表示出现在关系R中但不出现在关系S中的元素构成</li><li>数学描述：$R-S={ t|t\in R \and t\not \in S}$</li><li>R-S和S-R不同</li></ul><h6 id="广义笛卡尔积"><a href="#广义笛卡尔积" class="headerlink" title="广义笛卡尔积"></a>广义笛卡尔积</h6><ul><li>表示关系R中的元组与关系S的元组进行所有可能的拼接（或串接）构成</li><li>数学描述： $R\times S={ <a_1,a_2,...,a_n,b_1,b_2...,b_m>|<a_1,a_2,...,a_n>\in R\and <b_1,b_2...,b_m>\in S}$</b_1,b_2...,b_m></a_1,a_2,...,a_n></a_1,a_2,...,a_n,b_1,b_2...,b_m></li></ul><h6 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h6><ul><li>从关系R中选择出属性包含在A中的列构成</li><li><p>数学描述：$\prod<em>{A</em>{i1},A<em>{i2},…,A</em>{ik}}(R)={<t[A_{i1}],t[A_{i2}],...,t[A_{ik}]>|t\in R}$</t[A_{i1}],t[A_{i2}],...,t[A_{ik}]></p><ul><li>设$R(A_1,A_2,…A_n)$</li><li>${A<em>1,A_2,…,A</em>{ik}}\subseteq{A_1,A_2,…,A_n}$</li><li>$t[A_i]$表示元组t中相应于属性$A_i$的分量</li><li>投影运算可以对原关系的列在投影后重新排列</li></ul></li><li><p>投影操作是从给定关系中选出某些列组成新的关系，而选择操作是从给定关系中选出某些行组成新的关系</p></li></ul><h2 id="关系代数之扩展操作"><a href="#关系代数之扩展操作" class="headerlink" title="关系代数之扩展操作"></a>关系代数之扩展操作</h2><h6 id="交"><a href="#交" class="headerlink" title="交"></a>交</h6><ul><li>假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作$R \and S$，由同时出现在关系R和关系S中的元组构成</li><li>数学描述：$R \cap S = {t|t\in R\cap t\in S}$,其中t是元组</li><li>$R\cap S$和$S\cap R $是同一个关系</li><li>交运算可以通过差运算实现：</li><li>$R\cap S =R-(R-S) = S-(S-R)$</li></ul><h6 id="theta-连接操作"><a href="#theta-连接操作" class="headerlink" title="$\theta$连接操作"></a>$\theta$连接操作</h6><ul><li>给定关系R和关系S，R与S的$\theta$连接运算结果也是一个关系，记做$R{\triangleright \triangleleft}_{A \theta B} S$,它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性B之间满足$\theta$的元组构成</li><li><p>数学描述：$R{\triangleright \triangleleft}<em>{A \theta B} S = \sigma</em>{ t[A]\theta s[B]}(R\times S)$</p><ul><li>设$R(A_1,A_2,…A_n)，A\in {A_1,A_2,…A_n}$</li><li>$S(B_1,B_2,…,B_m),B\in {B_1,B-2,…,B_m}$</li><li>t是关系R中的元组，s是关系中的元组</li><li>属性A和属性B具有可比性</li><li>$\theta$是比较运算符，$\theta \in { &gt;,\geq,&lt;,\leq,=,\not =}$</li></ul></li><li><p>在实际应用中，$\theta-$连接经常与投影，选择操作一起使用</p></li></ul><h6 id="等值连接操作"><a href="#等值连接操作" class="headerlink" title="等值连接操作"></a>等值连接操作</h6><ul><li>特殊的$\theta$连接操作（关系是等号）</li></ul><h6 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h6><ul><li><p>定义：由关系S和关系R的笛卡儿积中选择相同属性组B上值相等的元素组成</p></li><li><p>数学描述：$R{\triangleright \triangleleft}<em>{A \theta B} S = \sigma</em>{ t[B]= s[B]}(R\times S)$</p><ul><li><p>自然连接是一种特殊的等值连接</p></li><li><p>要求关系R和关系S必须由相同的属性组B（B可以为单一属性可以为多属性）</p></li><li><p>R，S属性相同，值必须相等才能连接，即</p><p>$R.B_1=S.B_1 and R.B_2=S.B_2…. and R.B_n=S.B_n$</p></li><li><p>要在结果中去除重复的属性列，（因为$R.B_i$恒等于$S.B_i$，所以只保留一列即可）</p></li></ul></li></ul><h2 id="关系代数之复杂扩展操作"><a href="#关系代数之复杂扩展操作" class="headerlink" title="关系代数之复杂扩展操作"></a>关系代数之复杂扩展操作</h2><h6 id="除操作"><a href="#除操作" class="headerlink" title="除操作"></a>除操作</h6><ul><li>用于求解“查询…全部的/所有的…”问题</li><li>前提条件：给定关系$R(A_1,A_2,…,A_n)$为n度关系，关系$S(B_1,B_2,…,B_n)$为m度关系，如果可以进行关系R与关系S的除运算，当且仅当：属性集${B_1,B_2,…,B_m}$是属性集${A_1,A_2,…,A_n}$的真子集，即$m&lt;n$</li><li>定义，关系R和关系S的除运算结果也是一个关系，记作$R\div S$分两部分定义<ul><li>$R\div S$的属性：在R中去掉S中的属性，剩余属性的个数是$R\div S$的属性个数</li><li>$R\div S$的元组：$R\div S$这个元组与S的元组组合后的每个元组必须存在于R中</li></ul></li></ul><p><img src="/2022/01/18/04%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/image-20210120101213747.png" alt="image-20210120101213747"></p><h6 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h6><ul><li>两个关系R与S进行连接时，如果关系R（或S）中的元组在S（或R）中找不到匹配的元组，则为了避免该元组信息丢失，从而将该元组与S（或R）中假定存在的全为空值的元组形成连接，放置在关系中，这种连接称为外连接</li><li>外连接=自然连接(或$\theta$连接)+失配的元组(与空元组形成的连接)</li><li>外连接的形式:左外连接,右外链接,全外连接<ul><li>左外连接=自然连接(或$\theta$连接)+左侧表中失配的元组</li><li>右外连接=自然连接(或$\theta$连接)+右侧表中失配的元组</li><li>全外连接=自然连接(或$\theta$连接)+两侧表中失配的元组</li></ul></li></ul><p><img src="/2022/01/18/04%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/image-20210120161645722.png" alt="image-20210120161645722"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;04-关系代数&quot;&gt;&lt;a href=&quot;#04-关系代数&quot; class=&quot;headerlink&quot; title=&quot;04 关系代数&quot;&gt;&lt;/a&gt;04 关系代数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基本操作：并、差、积、选择、投影（更名）&lt;/li&gt;
&lt;li&gt;扩展操作：交、连接、除&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库语言--SQL</title>
    <link href="http://yokeso.github.io/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/"/>
    <id>http://yokeso.github.io/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:12:41.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库语言——SQL"><a href="#数据库语言——SQL" class="headerlink" title="数据库语言——SQL"></a>数据库语言——SQL</h1><p>SQL语言主要由九个单词引导的操作语句来构成，但每种语句都能表达复杂的操作请求</p><span id="more"></span><ul><li><p>DDL语句引导词：Create (建立)，Alter（修改），Drop（撤销）</p><ul><li>模式的定义和删除，包括定义Database，Table，View，Index,完整性约束条件等，也包括定义对象（RowType行对象，Type列对象）</li></ul></li><li><p>DML语句引导词：Insert，Delete，Update，Select</p><ul><li>各种方式的更新与检索操作，如直接输入记录。或者从其他Table(由SubQuery建立)输入</li><li>各种复杂条件的检索，如链接查找，模糊查找，分组查找，嵌套查找等</li><li>各种聚集操作，求平均，求和,…等，分组聚集，分组过滤等</li></ul></li><li><p>DCL语句引导词：Grant，Revoke</p><ul><li>安全性控制：授权和撤销授权</li></ul></li></ul><p>交互式SQL-&gt;嵌入式SQL-&gt;动态式SQL</p><h2 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h2><p>建立数据库包括两件事：<strong>定义数据库和表（使用DDL）</strong>，向表中追加元素（使用DML）</p><p>DDL: Data Definition Language</p><ul><li>创建数据库（DB）-Create Database</li><li>创建DB中的Table(定义关系模式)—Create Table</li><li>定义Table及其各个属性的约束条件（定义完整性约束）</li><li>定义View(定义外模式及E-C映像)</li><li>定义Index、Tablespace…..等（定义物理存储参数</li><li>上述各种定义的撤销与修正</li></ul><h3 id="创建Database"><a href="#创建Database" class="headerlink" title="创建Database"></a>创建Database</h3><ul><li>数据库是若干具有相互关联关系的Table/Relation的集合</li><li>数据库可以看作是一个集中存放若干Table的大型文件</li><li>create database的简单语法形式  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名</span><br></pre></td></tr></table></figure><h3 id="创建Table"><a href="#创建Table" class="headerlink" title="创建Table"></a>创建Table</h3><p>简单语法形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(列名 数据类型 [<span class="keyword">Primary</span> key<span class="operator">|</span><span class="keyword">Unique</span>][<span class="keyword">Not</span> <span class="keyword">null</span>]</span><br><span class="line">[列名 数据类型 [<span class="keyword">Not</span> <span class="keyword">null</span>],...]);</span><br></pre></td></tr></table></figure><ul><li>“[ ]”表示其括起的内容可以省略，”|“表示其隔开的两项可取其一</li><li><strong>Primary key</strong>：主键约束。每个表只能创建一个主键约束。</li><li><strong>Unique</strong>：唯一性约束（候选键）。可以由多个唯一性约束</li><li><strong>Not null</strong>：非空约束。是指该列允许不允许有空值出现。如选择了Not null则表明不允许有空值出现</li></ul><h2 id="数据库追加元素"><a href="#数据库追加元素" class="headerlink" title="数据库追加元素"></a>数据库追加元素</h2><p>建立数据库包括两件事：定义数据库和表（使用DDL）<strong>，向表中追加元素（使用DML）</strong></p><p>DML:Data Manipulation Language</p><ul><li>向Table中追加新的元组：Insert</li><li>修改某些元组中的某些属性：Update</li><li>删除Table中的某些元组：Delete</li><li>对Table中的数据进行某种条件的检索：Select</li></ul><p>DML通常由用户或应用程序员使用，访问经授权的数据库</p><h3 id="Insert-向表中追加元组"><a href="#Insert-向表中追加元组" class="headerlink" title="Insert-向表中追加元组"></a>Insert-向表中追加元组</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">Into</span> 表名[(列名 [,列名]...)] </span><br><span class="line">       <span class="keyword">values</span> (值 [,值],...);</span><br></pre></td></tr></table></figure><ul><li>values后面值的排列，需与into子句后面的列名排列一致</li><li>若标名后的所有列名省略，则values后的值的排列，需与该表存储的列名排列一致</li></ul><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/image-20210123153337564.png" alt="image-20210123153337564"></p><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/image-20210124120838523.png" alt="image-20210124120838523"></p><h3 id="Delete-删除表中元组"><a href="#Delete-删除表中元组" class="headerlink" title="Delete-删除表中元组"></a>Delete-删除表中元组</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> 表名 [<span class="keyword">Where</span> 条件表达式]</span><br></pre></td></tr></table></figure><p>如果where条件省略，则删除所有的元素</p><h3 id="Update-更新表中元组"><a href="#Update-更新表中元组" class="headerlink" title="Update-更新表中元组"></a>Update-更新表中元组</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Update 表名</span><br><span class="line"><span class="keyword">Set</span> 列名<span class="operator">=</span>表达式<span class="operator">|</span>(子查询)</span><br><span class="line">    [[,列名<span class="operator">=</span>表达式<span class="operator">|</span>(子查询)]...]</span><br><span class="line">[<span class="keyword">Where</span> 条件表达式]; </span><br></pre></td></tr></table></figure><p>如果where 条件省略，则更新所有元组</p><h3 id="Select-检索信息"><a href="#Select-检索信息" class="headerlink" title="Select-检索信息"></a>Select-检索信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> 列名 [[，列名]...]</span><br><span class="line"><span class="keyword">From</span>   表名</span><br><span class="line">[<span class="keyword">Where</span> 检索条件];</span><br></pre></td></tr></table></figure><ul><li>语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示</li><li>相当于$\prod<em>{列名,…,列名}(\sigma</em>{检索条件}(表名))$</li><li>Select语句中的select….,from…,where…,等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。</li><li>检索条件用 and，or，not 来表达</li></ul><h4 id="结果唯一性问题"><a href="#结果唯一性问题" class="headerlink" title="结果唯一性问题"></a>结果唯一性问题</h4><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/image-20210123163053033.png" alt="image-20210123163053033"></p><h4 id="结果排序问题"><a href="#结果排序问题" class="headerlink" title="结果排序问题"></a>结果排序问题</h4><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/image-20210123171125801.png" alt="image-20210123171125801"></p><h4 id="模糊查询问题"><a href="#模糊查询问题" class="headerlink" title="模糊查询问题"></a>模糊查询问题</h4><p>比如检索只知道姓氏的学生，Select通过在检索条件中引入运算符like来表示</p><p>含有like运算符的表达式</p><p>​    列名 [not] like “字符串”</p><p>找出匹配给定字符串的字符串，其中给定字符串中可以出现%,__等字符，</p><p>匹配规则：</p><ul><li>%：匹配零个或多个字符</li><li>_：任意匹配单个字符</li><li>\：转义字符，用于去掉一些特殊字符的特定含义，使其被作为普通字符看待</li></ul><h4 id="多表联合查询"><a href="#多表联合查询" class="headerlink" title="多表联合查询"></a>多表联合查询</h4><p>多表联合检索可以通过链接运算来完成，而链接运算又可以通过广义笛卡儿积后再进行选择运算来实现。</p><p>Select的多表联合查询检索语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> 列名 [[,列名]...] </span><br><span class="line"><span class="keyword">From</span>   表名<span class="number">1</span>,表名<span class="number">2</span>,...</span><br><span class="line"><span class="keyword">Where</span>  检索条件;</span><br></pre></td></tr></table></figure><p>检索条件中要包括链接条件，通过不同的链接条件可以实现等值链接，不等值链接以及各种$\theta-$链接</p><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/image-20210124105502924.png" alt="image-20210124105502924"></p><h5 id="重名处理"><a href="#重名处理" class="headerlink" title="重名处理"></a>重名处理</h5><p>连接运算涉及到重名的问题时，如两个表的属性重名，连接的两个表重名（同一表的连接）等，因此需要使用别名以便区分</p><p>select中采用别名的方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> 列名 <span class="keyword">as</span> 列别名[[,列名 <span class="keyword">as</span> 列别名]...]</span><br><span class="line"><span class="keyword">From</span> 表名<span class="number">1</span> <span class="keyword">as</span> 表别名<span class="number">1</span>，表名<span class="number">2</span> <span class="keyword">as</span> 表别名<span class="number">2</span>,...</span><br><span class="line"><span class="keyword">Where</span> 检索条件</span><br></pre></td></tr></table></figure><ul><li>上述定义中的As可以忽略</li><li>当定义了别名之后，在检索条件中可以使用别名来限定属性 </li></ul><h2 id="修正数据库"><a href="#修正数据库" class="headerlink" title="修正数据库"></a>修正数据库</h2><p>修正数据库主要是修正表的定义</p><h5 id="表单修改"><a href="#表单修改" class="headerlink" title="表单修改"></a>表单修改</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename</span><br><span class="line">[add &#123;colname datatype,...&#125;]          增加新列</span><br><span class="line">[drop &#123;完整性约束名&#125;]                   删除完整性约束</span><br><span class="line">[modify &#123;colname datatype,...&#125;]       修改列定义</span><br></pre></td></tr></table></figure><h5 id="撤销基本表"><a href="#撤销基本表" class="headerlink" title="撤销基本表"></a>撤销基本表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名                       撤销表</span><br><span class="line"><span class="keyword">drop</span> database 数据库名                 撤销数据库</span><br></pre></td></tr></table></figure><p>注意:delete是删除表中的数据，drop是将整个表单删除</p><h2 id="数据库指定与关闭"><a href="#数据库指定与关闭" class="headerlink" title="数据库指定与关闭"></a>数据库指定与关闭</h2><h5 id="指定当前数据库"><a href="#指定当前数据库" class="headerlink" title="指定当前数据库"></a>指定当前数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名</span><br></pre></td></tr></table></figure><h5 id="关闭当前数据库"><a href="#关闭当前数据库" class="headerlink" title="关闭当前数据库"></a>关闭当前数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">close</span> 数据库名</span><br></pre></td></tr></table></figure><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><h4 id="为什么需要子查询"><a href="#为什么需要子查询" class="headerlink" title="为什么需要子查询"></a>为什么需要子查询</h4><p>很多情况需要下述条件的判断</p><ul><li><p>集合成员资格</p><ul><li>某一元素是否是某一个集合成员</li></ul></li><li><p>集合之间的比较</p><ul><li>某一集合是否包含另外一个集合等</li></ul></li><li><p>集合基数测试</p><ul><li>测试集合是否为空</li><li>测试集合是否存在重复元组</li></ul></li></ul><p>子查询：出现在Where子句中的Select语句被称为子查询(subquery)，子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合</p><p>三种类型的子查询：(NOT)IN-子查询;$\theta-Some/\theta-All$子查询；Exist子查询</p><h5 id="NOT-IN-子查询："><a href="#NOT-IN-子查询：" class="headerlink" title="(NOT)IN-子查询："></a>(NOT)IN-子查询：</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">not</span>] <span class="keyword">in</span> 子查询</span><br></pre></td></tr></table></figure><p>语法中，表达式最简单的形式就是列名或常数</p><p>语义：判断某一表达式的值是否在子查询的结果中</p><p>示例：列出选修了001号课程的学生的学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> S#,Sname <span class="keyword">From</span> Student</span><br><span class="line"><span class="keyword">Where</span> S# <span class="keyword">in</span> (<span class="keyword">Select</span> S# <span class="keyword">From</span> SC <span class="keyword">Where</span> C#<span class="operator">=</span>&quot;001&quot;)</span><br></pre></td></tr></table></figure><p>非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询</p><p>相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询</p><p>外层向内层传递的参量需要使用外层的表名或者表别名来限定</p><h5 id="theta-Some-theta-All-子查询"><a href="#theta-Some-theta-All-子查询" class="headerlink" title="$\theta-Some/\theta-All$子查询"></a>$\theta-Some/\theta-All$子查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表达式 theta <span class="keyword">some</span> (子查询)</span><br><span class="line">表达式 theta <span class="keyword">all</span> (子查询)</span><br></pre></td></tr></table></figure><p>语法中的$\theta$是比较运算符：&lt;,&gt;,&gt;=,&lt;=,&lt;&gt;,=</p><p>语义：将表达式的值与子查询结果进行比较</p><ul><li>如果表达式的值至少与子查询结果的一个值比较满足$\theta$关系，则“表达式 theta some (子查询)”的结果便为真</li><li>如果表达式的值与子查询的所有结果比较都满足$\theta$关系，则“表达式 theta all (子查询)”的结果便为真</li></ul><h5 id="Exist子查询"><a href="#Exist子查询" class="headerlink" title="Exist子查询"></a>Exist子查询</h5><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/image-20210124173533484.png" alt="image-20210124173533484"></p><h3 id="结果计算"><a href="#结果计算" class="headerlink" title="结果计算"></a>结果计算</h3><p>Select-from-where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表名在投影的同时直接进行一些运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> 列名<span class="operator">|</span>expr<span class="operator">|</span>agfunc(列名) [[,列名<span class="operator">|</span>expr<span class="operator">|</span>agfunc(列名)]...]</span><br><span class="line"><span class="keyword">From</span>   表名[,表名<span class="number">2.</span>..]</span><br><span class="line">[<span class="keyword">Where</span> 检索条件];</span><br></pre></td></tr></table></figure><ul><li>expr 可以是常量、列名、或由常量、列名、特殊函数及算数运算符构成的算数运算式。特殊函数的使用需结合各自DBMS的说明书</li><li>agfunc()是一些聚集函数</li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组放到一个组或一个集合中，同时处理多个组或聚合的聚集运算</p><p>分组基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> 列名<span class="operator">|</span>expr<span class="operator">|</span>agfunc(列名) [[,列名<span class="operator">|</span>expr<span class="operator">|</span>agfunc(列名)]...]</span><br><span class="line"><span class="keyword">From</span>   表名<span class="number">1</span>[,表名<span class="number">2.</span>..]</span><br><span class="line">[<span class="keyword">Where</span> 检索条件]</span><br><span class="line">[<span class="keyword">Group</span> <span class="keyword">by</span> 分组条件];</span><br></pre></td></tr></table></figure><p>分组条件可以是</p><p>列名1，列名2,…</p><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/image-20210124210211441.png" alt="image-20210124210211441"></p><h3 id="分组过滤"><a href="#分组过滤" class="headerlink" title="分组过滤"></a>分组过滤</h3><p>引入原因：Where子句是对每一元组进行条件过滤而不是对集合进行条件过滤</p><p><strong>分组过滤：</strong>对集合进行条件过滤，满足条件的集合留下，不满足的剔除</p><p>Having子句，又称分组过滤子句。需要有groupBy 子句支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> 列名<span class="operator">|</span>expr<span class="operator">|</span>agfunc(列名) [[,列名<span class="operator">|</span>expr<span class="operator">|</span>agfunc(列名)]...]</span><br><span class="line"><span class="keyword">From</span>   表名<span class="number">1</span>[,表名<span class="number">2.</span>..]</span><br><span class="line">[<span class="keyword">Where</span> 检索条件]</span><br><span class="line">[<span class="keyword">Group</span> <span class="keyword">by</span> 分组条件[<span class="keyword">Having</span> 分组过滤条件]];</span><br></pre></td></tr></table></figure><h3 id="并-交-差的处理"><a href="#并-交-差的处理" class="headerlink" title="并-交-差的处理"></a>并-交-差的处理</h3><p>并运算UNION，交运算INTERSECT，差运算EXCEPT。</p><p>基本语法形式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子查询 &#123;Union [ALL]|intersect[ALL]|Except[ALL] 子查询&#125;</span><br></pre></td></tr></table></figure><p>通常情况下自动删除重复元组：不带ALL。若要保留重复元组则要带ALL</p><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/image-20210124214232604.png" alt="image-20210124214232604"></p><h3 id="数据库视图"><a href="#数据库视图" class="headerlink" title="数据库视图"></a>数据库视图</h3><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20210126190548381.png" alt="image-20210126190548381"></p><p><img src="/2022/01/18/07%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL/Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20210126190607776.png" alt="image-20210126190607776"></p><p>SQL视图更新的可执行性</p><ul><li>如果视图的Select目标列包含聚集函数，则不能更新</li><li>如果视图的select子句使用了unique或distinct，则不能更新</li><li>如果视图中包括了group by子句，则不能更新</li><li>如果视图中包括经算数表达式算出来的列，则不能更新、</li><li>如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li></ul><p>对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择，投影操作的，并且包含了基本表的主键，则可以更新</p><h3 id="SQL-视图的撤销"><a href="#SQL-视图的撤销" class="headerlink" title="SQL-视图的撤销"></a>SQL-视图的撤销</h3><p>已经定义的视图可以撤销</p><h6 id="撤销视图"><a href="#撤销视图" class="headerlink" title="撤销视图"></a>撤销视图</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Drop</span> <span class="keyword">View</span> view_name</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库语言——SQL&quot;&gt;&lt;a href=&quot;#数据库语言——SQL&quot; class=&quot;headerlink&quot; title=&quot;数据库语言——SQL&quot;&gt;&lt;/a&gt;数据库语言——SQL&lt;/h1&gt;&lt;p&gt;SQL语言主要由九个单词引导的操作语句来构成，但每种语句都能表达复杂的操作请求&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库完整性概念及其分类</title>
    <link href="http://yokeso.github.io/2022/01/18/08%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB/"/>
    <id>http://yokeso.github.io/2022/01/18/08%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:13:30.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库完整性概念及其分类"><a href="#数据库完整性概念及其分类" class="headerlink" title="数据库完整性概念及其分类"></a>数据库完整性概念及其分类</h1><h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><p>数据库完整性是指DBMS应保证DB的一种特性——在仍任何情况下的正确性，有效性和一致性</p><span id="more"></span><ul><li>广义完整性：语义的完整性，并发控制。安全控制，DB故障恢复等</li><li>狭义完整性：专指语义的完整性，DBMS通常由专门的完整性管理机制与程序来处理语义完整i性问题</li></ul><h3 id="关系模型中的完整性要求："><a href="#关系模型中的完整性要求：" class="headerlink" title="关系模型中的完整性要求："></a>关系模型中的完整性要求：</h3><ul><li>实体完整性</li><li>参照完整性</li><li>用户自定义完整性</li></ul><p>引发数据库完整性问题的原因主要是因为不正当的数据库操作（比如输入错误，操作错误，程序处理失误等）</p><h3 id="数据库完整性的作用："><a href="#数据库完整性的作用：" class="headerlink" title="数据库完整性的作用："></a>数据库完整性的作用：</h3><ul><li><p>防止和避免数据库中不合理数据的出现</p></li><li><p>DBMS应尽可能地自动防止DB中语义不合理现象</p><ul><li>DBMS允许用户定义一些完整性约束规则（用SQL-DDL定义）</li><li>当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性</li></ul></li></ul><p><img src="/2022/01/18/08%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB/image-20210126211831403.png" alt="数据库完整性作用"></p><h3 id="完整性约束条件的一般形式"><a href="#完整性约束条件的一般形式" class="headerlink" title="完整性约束条件的一般形式"></a>完整性约束条件的一般形式</h3><p><strong>Integrity Constraint ::=(O,P,A,R)</strong></p><ul><li>O 数据集合：约束的对象</li><li>P 谓词条件：什么样的约束</li><li>A 触发条件： 什么时候检查</li><li>R 相应动作：不满足怎么办</li></ul><p><img src="/2022/01/18/08%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB/image-20210126212743875.png" alt="约束的一般形式"></p><h2 id="数据库完整性分类"><a href="#数据库完整性分类" class="headerlink" title="数据库完整性分类"></a>数据库完整性分类</h2><h3 id="域完整性约束条件"><a href="#域完整性约束条件" class="headerlink" title="域完整性约束条件"></a>域完整性约束条件</h3><ul><li>施加于某一列上，对给定列上所要更新的某一后选址是否可以接受进行约束条件判断，这是孤立进行的</li></ul><h3 id="关系完整性约束条件"><a href="#关系完整性约束条件" class="headerlink" title="关系完整性约束条件"></a>关系完整性约束条件</h3><ul><li>施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一关系中的若干元组和另一个关系中的若干元组之间联系是否可以接受进行约束条件判断</li></ul><h3 id="按约束来源分类"><a href="#按约束来源分类" class="headerlink" title="按约束来源分类"></a>按约束来源分类</h3><p>结构约束</p><ul><li>来自于模型的约束，例如函数依赖约束、主键约束（实体完整性）、外键约束（参照完整性）、只关心数值是否相等，是否允许空值等</li></ul><p>内容约束</p><ul><li>来自于用户的约束，如用户自定义完整性，关系元组或属性的取值范围。</li></ul><p><img src="/2022/01/18/08%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB/image-20210127122311851.png" alt="内容约束"></p><h3 id="按约束状态分类"><a href="#按约束状态分类" class="headerlink" title="按约束状态分类"></a>按约束状态分类</h3><p>静态约束</p><ul><li>要求DB在任一时候均应该满足的约束</li></ul><p>动态约束</p><ul><li>要求DB从一状态变为另一状态时必须完成的约束</li></ul><p><img src="/2022/01/18/08%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB/image-20210127122527453.png" alt="动态约束"></p><h2 id="SQL实现完整性"><a href="#SQL实现完整性" class="headerlink" title="SQL实现完整性"></a>SQL实现完整性</h2><h3 id="SQL支持以下几种约束"><a href="#SQL支持以下几种约束" class="headerlink" title="SQL支持以下几种约束"></a>SQL支持以下几种约束</h3><ul><li><p>静态约束</p><ul><li>列完整性-域完整性约束</li><li>表完整性-关系完整性约束</li></ul></li><li><p>动态约束</p><ul><li>触发器</li></ul></li></ul><p><img src="/2022/01/18/08%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB/image-20210127122742173.png" alt="SQL支持的约束"></p><h3 id="SQL实现约束方法-Creat-Table"><a href="#SQL实现约束方法-Creat-Table" class="headerlink" title="SQL实现约束方法-Creat Table"></a>SQL实现约束方法-Creat Table</h3><p>Creat Table 有三种功能:定义关系模式,定义完整性约束和定义物理存储特性</p><p>定义完整性约束条件</p><ul><li>列完整性</li><li>表完整性</li></ul><p><img src="/2022/01/18/08%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB/image-20210127123243248.png" alt="列约束和表约束"></p><h4 id="Col-constr列约束"><a href="#Col-constr列约束" class="headerlink" title="Col_constr列约束"></a>Col_constr列约束</h4><p>列约束是一种域约束类型,可以对单一列进行约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;NOT NULL|                         //列值非空</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span> constraintname]    <span class="operator">/</span><span class="operator">/</span>为约束命名.便于以后撤销</span><br><span class="line">         &#123;UNIQUE                   //列值是唯一</span><br><span class="line">          <span class="operator">|</span><span class="keyword">PRIMARY</span> KEY             <span class="operator">/</span><span class="operator">/</span>列为主键</span><br><span class="line">          <span class="operator">|</span><span class="keyword">CHECK</span>(search_cond)      <span class="operator">/</span><span class="operator">/</span>列值满足条件,条件只能使用当前列值</span><br><span class="line">          <span class="operator">|</span><span class="keyword">REFERENCES</span> tablename [(colname)]</span><br><span class="line">                [ON DELETE&#123;CASCADE|SET NULL&#125;]&#125;&#125;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>引用另一表tablename的列colname的值，如有<span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE或<span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>语句，则删除被引用表的某列值v时，要将本表该列值为v的记录删除或列值更新为<span class="keyword">null</span>;缺省为无操作。</span><br></pre></td></tr></table></figure><p>Col_constr 列约束:只能应用在单一列 上，其后面的约束如UNIQUE,PRIMARY KEY及search_cond 只能是单一列唯一、单一列为主键、和单一列相关</p><h4 id="table-constr表约束"><a href="#table-constr表约束" class="headerlink" title="table_constr表约束"></a>table_constr表约束</h4><p>表约束是一种关系型约束.对多列或多元组的值进行约束,列约束是其特例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> constraintname]              <span class="operator">/</span><span class="operator">/</span>为约束命名.便于以后撤销</span><br><span class="line">     &#123;UNIQUE  (colname &#123;.colname...&#125;)    //几列值合一起是唯一</span><br><span class="line">      |PRIMARY KEY (colname &#123;.colname...&#125;) //几列联合为主键</span><br><span class="line">      <span class="operator">|</span><span class="keyword">CHECK</span>(search_condition)      <span class="operator">/</span><span class="operator">/</span>元组多列值共同满足条件,</span><br><span class="line">  <span class="operator">/</span><span class="operator">/</span>条件中只能使用同一元组不同列当前值</span><br><span class="line">      |FOREIGN KEY (colname &#123;.colname...&#125;)</span><br><span class="line">           REFERENCES tablename [(colname &#123;.colname...&#125;)]</span><br><span class="line">            [ON DELETE CASCADE]&#125;&#125;</span><br><span class="line">       <span class="operator">/</span><span class="operator">/</span>引用另一表tablename的若干列键值作为外键</span><br></pre></td></tr></table></figure><h2 id="断言ASSERTION"><a href="#断言ASSERTION" class="headerlink" title="断言ASSERTION"></a>断言ASSERTION</h2><p>一个断言就是一个谓词表达式,它表达了希望数据库总能满足的条件.表约束和列约束就是一种特殊的断言</p><p>SQL提供了复杂条件表达的断言.其语法形式为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION <span class="operator">&lt;</span>assertion_name<span class="operator">&gt;</span> <span class="keyword">CHECK</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>当一个断言创建后,系统将检测其有效性,并在每一次更新中测试更新是否违背断言</p><p><strong>断言测试增加了数据库维护的负担,所以要小心的使用断言</strong></p><h2 id="触发器Trigger"><a href="#触发器Trigger" class="headerlink" title="触发器Trigger"></a>触发器Trigger</h2><ul><li>Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger</li><li>Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束)，是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。</li></ul><p>基本语法:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name BEFORE<span class="operator">|</span>AFTER</span><br><span class="line">    &#123;INSERT|DELETE|UPDATE [OF folname&#123;,colname...&#125;]&#125;</span><br><span class="line">    ON tablename [REFERENCING corr_name_def &#123;col_name_def&#125;]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span><span class="operator">|</span><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT]   <span class="operator">/</span><span class="operator">/</span>更新操作的每一条结果(前者),或者整个更新操作完成(后者)</span><br><span class="line">    [<span class="keyword">WHEN</span> (search_condition)]           <span class="operator">/</span><span class="operator">/</span>检查条件,如满足执行下面程序</span><br><span class="line">           &#123;statement                   //单行程序直接书写,多行程序要用下行方式</span><br><span class="line">           |BEGIN ATOMIC statement;(statement;..)END&#125;</span><br></pre></td></tr></table></figure><p>触发器Trigger意义:当某一时间发生时(Before|After),对事件产生的结果(或是每一元组,或者操作的所有元组),检查条件search_condition,如果满足条件,则执行后面程序段,条件或程序段中引用的变量可用corr_name_def来限定</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库完整性概念及其分类&quot;&gt;&lt;a href=&quot;#数据库完整性概念及其分类&quot; class=&quot;headerlink&quot; title=&quot;数据库完整性概念及其分类&quot;&gt;&lt;/a&gt;数据库完整性概念及其分类&lt;/h1&gt;&lt;h2 id=&quot;数据库完整性&quot;&gt;&lt;a href=&quot;#数据库完整性&quot; class=&quot;headerlink&quot; title=&quot;数据库完整性&quot;&gt;&lt;/a&gt;数据库完整性&lt;/h2&gt;&lt;p&gt;数据库完整性是指DBMS应保证DB的一种特性——在仍任何情况下的正确性，有效性和一致性&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库安全性</title>
    <link href="http://yokeso.github.io/2022/01/18/09%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://yokeso.github.io/2022/01/18/09%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:13:41.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h1><p>数据库安全性是指DBMS应保证数据库的一种特性:免受非法,非授权用户的使用,泄露,更改和破坏</p><span id="more"></span><h2 id="数据库安全性概念及分类"><a href="#数据库安全性概念及分类" class="headerlink" title="数据库安全性概念及分类"></a>数据库安全性概念及分类</h2><h3 id="DBMS的安全机制"><a href="#DBMS的安全机制" class="headerlink" title="DBMS的安全机制"></a>DBMS的安全机制</h3><p>自主安全性机制:存取控制</p><ul><li>通过权限在用户之间的传递,使用户自主管理数据库安全性</li></ul><p>强制安全性机制</p><ul><li>通过对数据和用户强制分类,使得不同类别用户能够访问不同类别的数据</li></ul><p>推断控制机制:</p><ul><li>防止通过历史信息,推断出不该被其知道的信息</li><li>防止通过统计信息(通常是聚集信息)推断出私密信息(个体信息)</li></ul><p>数据加密机制:</p><ul><li>通过加密解密实现的机制</li></ul><h3 id="DBA的责任与义务"><a href="#DBA的责任与义务" class="headerlink" title="DBA的责任与义务"></a>DBA的责任与义务</h3><p><img src="/2022/01/18/09%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20210127230423532.png" alt="image-20210127230423532"></p><h2 id="数据库自主安全性机制"><a href="#数据库自主安全性机制" class="headerlink" title="数据库自主安全性机制"></a>数据库自主安全性机制</h2><h3 id="自主安全性"><a href="#自主安全性" class="headerlink" title="自主安全性"></a>自主安全性</h3><p>通常情况下，自主安全性是通过授权机制来实现的</p><p>用户在使用数据库之前必须在DBA处获得一个账户，并由DBA授予该用户一定权限，该账户的用户依据其所拥有的权限对数据库进行操作，同时，该账户用户也可将其所拥有的权力转授给其他用户，由此实现权限在用户之间的控制和传播</p><ul><li>授权者 ：决定用户权力的人</li><li>授权：授予用户访问的权力</li></ul><h3 id="DBMS自动实现自主安全性"><a href="#DBMS自动实现自主安全性" class="headerlink" title="DBMS自动实现自主安全性"></a>DBMS自动实现自主安全性</h3><p>DBMS允许用户定义一些安全性控制规则</p><p>当由DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许</p><p><img src="/2022/01/18/09%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20210128094124876.png" alt="数据库自主安全性控制"></p><p>DBMS将权力和用户结合在一起，形成一个访问规则表，一句该规则表对数据库进行安全性控制</p><script type="math/tex; mode=display">AccesRule::=(S,O,t,P)</script><ul><li>S: 请求主题（用户）</li><li>O: 访问对象</li><li>t:  访问权力</li><li>P： 谓词</li></ul><p>{AccessRule} 通常放在数据字典或系统目录中，构成所有用户对DB的 访问权力</p><p>用户多时，可以按用户组建立访问规则</p><p>访问对象可大可小：属性/字段、记录/元组、关系、数据库</p><p>权力：包括创建、增、删、改、查等</p><p>谓词：拥有权力需满足的条件</p><h2 id="自主安全性实现方式"><a href="#自主安全性实现方式" class="headerlink" title="自主安全性实现方式"></a>自主安全性实现方式</h2><h3 id="1-存储矩阵"><a href="#1-存储矩阵" class="headerlink" title="1.存储矩阵"></a>1.存储矩阵</h3><p><img src="/2022/01/18/09%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20210128103155593.png" alt="存储矩阵"></p><h3 id="2-视图"><a href="#2-视图" class="headerlink" title="2.视图"></a>2.视图</h3><p>视图时安全性控制的重要手段</p><p>通过视图可以吸纳之用户对关系中某些数据项的存取，例如：</p><ul><li>视图1： Create  EmpV1 as select * from Employee</li><li>视图2： Create EmpV2 as select Pname ,D# from Employee</li></ul><p>通过视图可将数据访问对象与谓词结合起来，先视用户对关系中某些元组的存取，例如：</p><ul><li>视图1： Create EmpV3 as select * from Emplayee where P# =:UeerId</li><li>视图2： Create EmpV4 as select * from Employee where Head+:UserId</li></ul><p>用户定义视图后，视图便成为新的数据对象，参与到存储矩阵与能力表述中进行描述（可以递归使用）</p><h2 id="SQL实现数据库自主安全性"><a href="#SQL实现数据库自主安全性" class="headerlink" title="SQL实现数据库自主安全性"></a>SQL实现数据库自主安全性</h2><h3 id="SQL语言的用户与权力"><a href="#SQL语言的用户与权力" class="headerlink" title="SQL语言的用户与权力"></a>SQL语言的用户与权力</h3><p>SQL包括DDL，DML，和DCL。数据库安全性控制时属于DCL的范畴</p><p>授权机制——自主安全性；视图的使用</p><p>关系级别：DBA－程序员用户－关系级别（普通用户）</p><ul><li>级别一 Select 读级别</li><li><p>级别二 Modify ：更新</p><ul><li>insert：插入</li><li>UPdate：更新</li><li>Delete ：删除</li></ul></li><li><p>级别三 Create：创建</p><ul><li>Create  ：创建</li><li>ALter ：更新</li><li>Drop ：删除</li></ul></li></ul><p><strong>级别高的权力包含级别低的</strong></p><h3 id="授权命令"><a href="#授权命令" class="headerlink" title="授权命令"></a>授权命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT &#123;all PRIVILEGES|privilege &#123;,privilege&#125;&#125;</span><br><span class="line">   <span class="keyword">ON</span> [<span class="keyword">TABLE</span>] tablename<span class="operator">|</span>viewname</span><br><span class="line">   TO &#123;public|user-id&#123;,user-id&#125;&#125;</span><br><span class="line">   [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION]</span><br></pre></td></tr></table></figure><p>user-id：某一个用户账户，由DBA创建的合法账户</p><p>public：允许所有有效账户使用授予的权力</p><p>priviliege 是下面的权力</p><ul><li>SELECT|INSERT|UPDATE|DELETE|ALL PRIVIEDGES</li></ul><p>WITH GRANT OPTION 选项是允许被授权者传播这些权力</p><h3 id="收回授权"><a href="#收回授权" class="headerlink" title="收回授权"></a>收回授权</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &#123;all privilrges|priv&#123;,priv...&#125;&#125; ON tablename|viewname</span><br><span class="line">    FROM &#123;public|user&#123;,user...&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="安全性授权的其他简介"><a href="#安全性授权的其他简介" class="headerlink" title="安全性授权的其他简介"></a>安全性授权的其他简介</h2><h3 id="自主安全性的授权过程及其问题"><a href="#自主安全性的授权过程及其问题" class="headerlink" title="自主安全性的授权过程及其问题"></a>自主安全性的授权过程及其问题</h3><h4 id="授权过程"><a href="#授权过程" class="headerlink" title="授权过程"></a>授权过程</h4><ul><li>第一步：DBA创建DB为每个用户创建一个账户</li><li>第二步：DBA授予某用户账户级别权力</li><li>具有账户级别的用户可以创建基本表或者视图，他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问权力</li><li>拥有属主账户的用户可以将其中的一部分权力授予另外的用户，该用户也可将权力进一步授权给其他的用户</li></ul><h3 id="强制安全性"><a href="#强制安全性" class="headerlink" title="强制安全性"></a>强制安全性</h3><p>强制安全性通过对数据对象进行安全性分级</p><ul><li>绝密，机密，可信，无分类</li></ul><p>同时对用户进行上述的安全性分级从而实现不同级别用户访问不同级别数据的一种机制</p><h3 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h3><p><img src="/2022/01/18/09%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20210128112306745.png" alt="访问规则"></p><h3 id="强制安全性机制的实现"><a href="#强制安全性机制的实现" class="headerlink" title="强制安全性机制的实现"></a>强制安全性机制的实现</h3><p>DBMS引入强制安全性机制，可以通过扩展关系模式被来实现</p><p><img src="/2022/01/18/09%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20210128114145572.png" alt="强制安全性机制的实现"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库安全性&quot;&gt;&lt;a href=&quot;#数据库安全性&quot; class=&quot;headerlink&quot; title=&quot;数据库安全性&quot;&gt;&lt;/a&gt;数据库安全性&lt;/h1&gt;&lt;p&gt;数据库安全性是指DBMS应保证数据库的一种特性:免受非法,非授权用户的使用,泄露,更改和破坏&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式SQL</title>
    <link href="http://yokeso.github.io/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/"/>
    <id>http://yokeso.github.io/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:14:15.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式SQL语言"><a href="#嵌入式SQL语言" class="headerlink" title="嵌入式SQL语言"></a>嵌入式SQL语言</h1><h2 id="交互式SQL的局限"><a href="#交互式SQL的局限" class="headerlink" title="交互式SQL的局限"></a>交互式SQL的局限</h2><p>普通用户无法很好的书写SQL</p><p>复杂检索结果难以用一条交互式SQL完成，需要结合高级语言中的循环判断来完成</p><p>解决方法：高级语言+SQL</p><span id="more"></span><ul><li>既继承了高级语言的过程控制性</li><li>又结合SQL语言复杂结果的非过程性</li><li>同时为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作</li></ul><p>嵌入式SQL：</p><ul><li>将SQL嵌入到高级语言中，这种高级语言又称为宿主语言</li><li>嵌入在宿主语言的SQL与前面介绍的不太相同</li></ul><h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><p><img src="/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20210128130153443.png" alt="问题"></p><h2 id="变量声明与数据链接"><a href="#变量声明与数据链接" class="headerlink" title="变量声明与数据链接"></a>变量声明与数据链接</h2><h3 id="变量的声明与使用"><a href="#变量的声明与使用" class="headerlink" title="变量的声明与使用"></a>变量的声明与使用</h3><p>在嵌入式SQL语句中可以出现宿主原因呢语句所使用的变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">select</span> Sname,Sage <span class="keyword">into</span> :vSname,:vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname :specName</span><br></pre></td></tr></table></figure><p>需要特殊声明的变量：</p><p><img src="/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20210128130514167.png" alt="特殊声明"></p><p>变量声明和赋值中，要注意：</p><ul><li><p>宿主程序的字符串变量长度应比字符型字段的长度多一个。因宿主程序的字符串尾部多一个终止符为“\0”，而程序中用双引号描述</p></li><li><p>宿主程序变量类型与数据库字段之间有些是有差异的，有些DBMS可支持自动转换，有些不能。</p></li><li><p>声明的变量，可以在宿主程序中赋值，然后传递给SQL的where等子句中，使SQL语句能够按照指定的要求（可变化的进行检索）</p></li></ul><p><img src="/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20210128130919048.png" alt="动态赋值"></p><p>嵌入式比交互式SQL语句灵活了一些，只需要改变一下变量值，SQL语句便可以反复使用以检测出不同结果</p><h3 id="程序与数据库的连接和断开"><a href="#程序与数据库的连接和断开" class="headerlink" title="程序与数据库的连接和断开"></a>程序与数据库的连接和断开</h3><p>在嵌入式SQL执行前，首先要与数据库进行链接，不同的DBMS链接语句方式略有差异</p><p>同样在执行后需要断开链接</p><h3 id="SQL执行的提交与撤销"><a href="#SQL执行的提交与撤销" class="headerlink" title="SQL执行的提交与撤销"></a>SQL执行的提交与撤销</h3><p>SQL执行过程中必须有提交和撤销语句才能确认其操作结果</p><p><img src="/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/image-20210128131404635.png" alt="提交和撤销"></p><h2 id="事务的概念和特性"><a href="#事务的概念和特性" class="headerlink" title="事务的概念和特性"></a>事务的概念和特性</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>一个存取或或改变数据库内容的一次执行，或者说一条或多条SQL语句的一次执行被看作一个任务</p><p>事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为以一个整体进行操作和控制，以便数据库系统能够提供一致性状态转换保证</p><ul><li>事务一般是由应用程序员提出，因此有开始和结束，结束前需要提前提交或撤销。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span> Transaction</span><br><span class="line">     <span class="keyword">exec</span> <span class="keyword">sql</span> ...</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">exec</span> <span class="keyword">sql</span> ...</span><br><span class="line">     <span class="keyword">exec</span> <span class="keyword">sql</span> consit work<span class="operator">|</span><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">rollback</span> work</span><br><span class="line"><span class="keyword">End</span> Transaction</span><br></pre></td></tr></table></figure><p>在嵌入式SQL程序中，任何一条数据库操纵语句（如exec sql select等）都会引发一个新事物的开始，只要该程序当前没有正在处理的事务。而事务的结束时需要应用程序员通过commit或rollback确认的。因此Begin Transaction 和End Transaction两行语句是不需要的。</p><h3 id="事务的特性：ACID"><a href="#事务的特性：ACID" class="headerlink" title="事务的特性：ACID"></a>事务的特性：ACID</h3><ul><li>原子性Atomicity：DBMS能够保证事务的一组更新操作是原子不可分的，即对于DB而言，要么不做，要么全做</li><li>一致性Consistency：DBMS保证事务的操作状态时正确的，符合一致性的操作规则，它时由进一步隔离性来保证的</li><li>隔离性Isolation：DBMS保证并发执行的多个事务之间互相不受影响，例如两个事务T1和T2，即使并发执行，也相当于先执行了T1，再执行T2，或者先执行了T2，再执行T1。</li><li>持久性Durability：DBMS保证已提交的事务的影响是持久的，被撤销事务的影响是可恢复的</li></ul><h2 id="数据集与游标"><a href="#数据集与游标" class="headerlink" title="数据集与游标"></a>数据集与游标</h2><h3 id="单行结果与多行结果处理的差异"><a href="#单行结果与多行结果处理的差异" class="headerlink" title="单行结果与多行结果处理的差异"></a>单行结果与多行结果处理的差异</h3><p>单行结果可以直接传送到宿主程序的变量中</p><p>多行结果则需要使用游标</p><ul><li>游标是指向某检索记录集的指针</li><li><p>通过这个指针的移动，每次读一行，处理一行，直到结束</p></li><li><p>读一行的操作通过Fetch…into语句实现的，每一次Fetch，都先向下移动指针，然后读取</p></li><li>记录集有结束标识EOF，用来标记后面没有记录了</li></ul><p>游标的使用需要先定义，再打开（执行），一条接着一条处理，最后关闭</p><p><img src="/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/image-20210128164623447.png" alt="游标"></p><h3 id="可滚动游标"><a href="#可滚动游标" class="headerlink" title="可滚动游标"></a>可滚动游标</h3><p>标准的游标自开始向结束方向移动，每fetch一次，向结束方向移动一次，一条记录之恶能访问一次</p><p>可滚动游标使指针在记录集之间灵活移动，使每条记录可以被反复访问的一种游标。</p><p><img src="/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/image-20210128170114120.png" alt="可滚动游标"></p><h3 id="数据库记录的删除"><a href="#数据库记录的删除" class="headerlink" title="数据库记录的删除"></a>数据库记录的删除</h3><p>一种是查找删除（Delete语句），<strong>一种是定位删除（删除游标对应位置）</strong></p><p>EXEC SQL DELETE FROM tablename [corrname]</p><p>​            WHERE search_condition|<strong>WHERE CURRENT cursor_name</strong></p><h3 id="数据库记录的更新"><a href="#数据库记录的更新" class="headerlink" title="数据库记录的更新"></a>数据库记录的更新</h3><p>一种是查找更新（UPdate语句），<strong>一种是定位更新（更新游标对应位置）</strong></p><h2 id="状态捕获及其处理"><a href="#状态捕获及其处理" class="headerlink" title="状态捕获及其处理"></a>状态捕获及其处理</h2><p>状态，是SQL语句的执行状态，尤其指一些出错状态，有时程序需要知道这些状态并进行处理</p><p>嵌入式SQL中，状态捕获及其处理由三部分构成</p><ul><li><p>设置SQL通信去：一般在嵌入式SQL程序的开始处便设置</p><ul><li>exec sql include sqlca</li></ul></li><li><p>设置状态捕获语句 在嵌入式程序任何位置都可设置，可以多次设置，但是由作用域</p><ul><li>exec sql whenever sqlerror goto report_error</li></ul></li><li><p>状态处理语句：某一段程序以应对SQL操作的某种状态</p><ul><li>report_error:exec sql rollback</li></ul></li></ul><h3 id="SQL通信机制：SQLCA"><a href="#SQL通信机制：SQLCA" class="headerlink" title="SQL通信机制：SQLCA"></a>SQL通信机制：SQLCA</h3><p><img src="/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/image-20210128172220301.png" alt="SQLCA"></p><h4 id="状态捕获语句"><a href="#状态捕获语句" class="headerlink" title="状态捕获语句"></a>状态捕获语句</h4><p>exec sql whenever condition action;</p><p>Whenever语句是设置一个”条件陷阱，条件语句会由Exec SQL 语句所引起的对数据库系统的调用自动检查是否满足条件（condition）“</p><ul><li>SQLERROR：检测是否有SQL语句出错，并具体意义依赖于特定的DBMS</li><li>INOT　FOUND：执行某一SQL语句后，没有相应的结果记录出现</li><li>SQLWARNING：不是错误，但应该引起注意的条件</li></ul><p>如果满足condition,则要采取一些动作(由action指出)</p><ul><li>CONTINUE:忽略条件或错误，继续执行</li><li>GOTO标号:转移到标号所指示的语句，去进行相应的处理</li><li>STOP:终止程序运行、撤消当前的工作、断开数据库的连接</li><li>DO函数或CALL函数:调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行</li></ul><p>Whenever语句的范围是其后所有的Exec SQL语句，一直到程序中出现另外一条相同条件的Whenever为止，后面的覆盖前面的</p><p><img src="/2022/01/18/10%20%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/image-20210128173336071.png" alt="image-20210128173336071"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;嵌入式SQL语言&quot;&gt;&lt;a href=&quot;#嵌入式SQL语言&quot; class=&quot;headerlink&quot; title=&quot;嵌入式SQL语言&quot;&gt;&lt;/a&gt;嵌入式SQL语言&lt;/h1&gt;&lt;h2 id=&quot;交互式SQL的局限&quot;&gt;&lt;a href=&quot;#交互式SQL的局限&quot; class=&quot;headerlink&quot; title=&quot;交互式SQL的局限&quot;&gt;&lt;/a&gt;交互式SQL的局限&lt;/h2&gt;&lt;p&gt;普通用户无法很好的书写SQL&lt;/p&gt;
&lt;p&gt;复杂检索结果难以用一条交互式SQL完成，需要结合高级语言中的循环判断来完成&lt;/p&gt;
&lt;p&gt;解决方法：高级语言+SQL&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>动态SQL的概念</title>
    <link href="http://yokeso.github.io/2022/01/18/11%20%E5%8A%A8%E6%80%81SQL%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://yokeso.github.io/2022/01/18/11%20%E5%8A%A8%E6%80%81SQL%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:14:31.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态SQL的概念"><a href="#动态SQL的概念" class="headerlink" title="动态SQL的概念"></a>动态SQL的概念</h1><p>动态SQL是相对与静态SQL而言的</p><p>静态SQL特点是SQL语句已经按要求写好，只需要将一些参数通过变量传送给嵌入式SQL语句即可</p><p>动态SQL则是在程序中动态构造，形成一个字符串，再交给DBMS执行，交给DBMS执行的时候仍旧可以传递变量</p><span id="more"></span><h2 id="数据字典与SQLDA"><a href="#数据字典与SQLDA" class="headerlink" title="数据字典与SQLDA"></a>数据字典与SQLDA</h2><p>数据字典又称为系统目录，是系统维护的一些表或视图的集合，者写表或驶入存储了数据中各类对象的定义信息，这些对象包括Create语句定义的表，列，索引，视图，权限，约束等，这些信息又称为数据库的元数据——关于数据的数据</p><p>不同DBMS术语不一样：数据字典、目录表、系统目录、系统视图</p><p>不同DBMS中系统目录存储方式可能是不同的，但会有一些信息对DBA公开。这些公开的信息，DBA可以使用一些特殊的SQL来检索</p><h3 id="数据字典的内容构成"><a href="#数据字典的内容构成" class="headerlink" title="数据字典的内容构成"></a>数据字典的内容构成</h3><p>数据字典通常存储的是数据库和表的元数据，即模式本身信息</p><ul><li><p>与关系相关信息</p><ul><li>关系名字</li><li>每个视图的属性名及其类型</li><li>视图的名字及其定义</li><li>完整性约束</li></ul></li><li><p>用户与账户信息，包括密码</p></li><li>统计与描述性数据：如每个关系中元组的数目</li><li><p>物理文件组织信息</p><ul><li>关系是如何存储的（顺序/无序/散列等）</li><li>关系的物理位置</li></ul></li><li><p>索引相关信息</p></li></ul><h3 id="数据字典的结构"><a href="#数据字典的结构" class="headerlink" title="数据字典的结构"></a>数据字典的结构</h3><ul><li>也是存储在磁盘上的关系</li><li>专门为内存高雄啊访问设计的特定的数据结构</li></ul><p>可能的字典数据结构</p><h4 id="X-Open标准系统目录"><a href="#X-Open标准系统目录" class="headerlink" title="X/Open标准系统目录"></a>X/Open标准系统目录</h4><p><img src="/2022/01/18/11%20%E5%8A%A8%E6%80%81SQL%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210129135827140.png" alt="X/Open标准系统目录"></p><h4 id="Oracle的用户字典"><a href="#Oracle的用户字典" class="headerlink" title="Oracle的用户字典"></a>Oracle的用户字典</h4><p><img src="/2022/01/18/11%20%E5%8A%A8%E6%80%81SQL%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210129140029952.png" alt="Oracle"></p><h3 id="SQLDA"><a href="#SQLDA" class="headerlink" title="SQLDA"></a>SQLDA</h3><p>SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等</p><p>通过读取SQLDA信息可以进行更为复杂的动态SQL处理</p><p>不同的DBMS提供的SQLDA格式并不是一致的</p><h3 id="ODBC"><a href="#ODBC" class="headerlink" title="ODBC"></a>ODBC</h3><p>ODBC是一种不同语言的应用程序与不同数据库服务器之间的通讯标准</p><p>是一组API，支持应用程序与数据库服务器的交互</p><p>应用程序通过调用ODBC　API，实现</p><ul><li>与数据服务器的链接</li><li>向数据库服务器发送SQL命令</li><li>一条一条的提取数据库检索结果中的元组传递给应用程序的变量</li></ul><p>具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便数据库与应用程序的链接</p><p>ODBC可以配合很多高级语言使用</p><h4 id="应用程序如何通过ODBC链接一个数据库服务器"><a href="#应用程序如何通过ODBC链接一个数据库服务器" class="headerlink" title="应用程序如何通过ODBC链接一个数据库服务器"></a>应用程序如何通过ODBC链接一个数据库服务器</h4><p><img src="/2022/01/18/11%20%E5%8A%A8%E6%80%81SQL%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210129142339170.png" alt="image-20210129142339170"></p><p><img src="/2022/01/18/11%20%E5%8A%A8%E6%80%81SQL%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210129143822120.png" alt="ODBC其他功能"></p><h4 id="JDBC——JAVA版的ODBC"><a href="#JDBC——JAVA版的ODBC" class="headerlink" title="JDBC——JAVA版的ODBC"></a>JDBC——JAVA版的ODBC</h4><p><img src="/2022/01/18/11%20%E5%8A%A8%E6%80%81SQL%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210129143945524.png" alt="JDBC功能"></p><p><img src="/2022/01/18/11%20%E5%8A%A8%E6%80%81SQL%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210129144009838.png" alt="image-20210129144009838"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态SQL的概念&quot;&gt;&lt;a href=&quot;#动态SQL的概念&quot; class=&quot;headerlink&quot; title=&quot;动态SQL的概念&quot;&gt;&lt;/a&gt;动态SQL的概念&lt;/h1&gt;&lt;p&gt;动态SQL是相对与静态SQL而言的&lt;/p&gt;
&lt;p&gt;静态SQL特点是SQL语句已经按要求写好，只需要将一些参数通过变量传送给嵌入式SQL语句即可&lt;/p&gt;
&lt;p&gt;动态SQL则是在程序中动态构造，形成一个字符串，再交给DBMS执行，交给DBMS执行的时候仍旧可以传递变量&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据建模与数据库设计</title>
    <link href="http://yokeso.github.io/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yokeso.github.io/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:14:45.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据建模与数据库设计"><a href="#数据建模与数据库设计" class="headerlink" title="数据建模与数据库设计"></a>数据建模与数据库设计</h1><h2 id="数据模型与概念模型"><a href="#数据模型与概念模型" class="headerlink" title="数据模型与概念模型"></a>数据模型与概念模型</h2><p>表达计算机世界的模型乘坐数据模型；表达信息世界的模型称为该奶奶数据模型，简称概念模型，信息世界是对现实世界的理解与抽象</p><span id="more"></span><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20210129224502779.png" alt="image-20210129224502779"></p><h2 id="实体与实例"><a href="#实体与实例" class="headerlink" title="实体与实例"></a>实体与实例</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>实体：客观存在并可相互区分的事务</p><p>实体有类（实体，实体的型）和个体（实体的实例。实体的值）的概念</p><p>实体用<strong>属性</strong>来刻画  <strong>属性</strong>是实体具有的某一方面的特性</p><h5 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h5><ul><li><strong>单一属性和复合属性</strong>，在关系模型中，复合属性一定要转化为单一属性（关系中的1范式）</li><li><strong>单值属性和多值属性</strong>：每个实例的该属性值是一个还是多个</li><li><strong>可空值属性和非空值属性</strong></li><li><strong>导出属性</strong>（由其他属性通过计算得到）</li></ul><p>属性最重要的特点的<strong>关键字/码</strong>，表示实体中能够哟弄个其值唯一区分开每一实例的属性或属性组合</p><p>实体之间是有<strong>联系</strong>的，<strong>联系</strong>是指一个实体的实例和其他实体实例之间所可能发生的联系。</p><p><strong>角色</strong>：实体在联系中的作用</p><p>实体之间的联系可以有很多种类</p><h5 id="二元联系"><a href="#二元联系" class="headerlink" title="二元联系"></a>二元联系</h5><p>一对一，一对多，多对多</p><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210130103226008.png" alt="二元联系"></p><p>联系的<strong>基数</strong>：实体实例之间联系的数量，即一个实体的实例通过一个联系能与另一实体中相关联的实例的数目</p><p>进一步，联系的基数还要区分0个，1个，不定数目的多个还是固定数目的多个（即每个实体的实例而言是否必须存在）</p><p>通常以实体参与联系的最小基数和最大基数来标记（MInCard..MaxCard）</p><ul><li><strong>书架</strong>参与<strong>存放图书</strong>联系的基数为(0..m)，而图书参与此联系的基数为（1..1）</li><li>一个书架可以存放0或多本图书，但一本图书只能存放在一个书架</li></ul><p>完全参与联系，即该端实例至少有一个参与到联系中，最小基数为1（1..m）;</p><p>部分参与联系：即该端实例可以不参与联系，最小基数为0（0..m）</p><h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><h3 id="E-R模型表达方法之chen方法"><a href="#E-R模型表达方法之chen方法" class="headerlink" title="E-R模型表达方法之chen方法"></a>E-R模型表达方法之chen方法</h3><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210130105208413.png" alt="chen方法"></p><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210130105355140.png" alt="联系的区分"> </p><h3 id="E-R模型表达方法之Crow’s-foot方法"><a href="#E-R模型表达方法之Crow’s-foot方法" class="headerlink" title="E-R模型表达方法之Crow’s foot方法"></a>E-R模型表达方法之Crow’s foot方法</h3><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210130173504426.png" alt="Crow&#39;s foot"></p><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210130173548589.png" alt="联系"></p><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210130173630366.png" alt="联系的基数表示"></p><h2 id="数据库设计的抽象"><a href="#数据库设计的抽象" class="headerlink" title="数据库设计的抽象"></a>数据库设计的抽象</h2><p>型与值</p><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210130190431385.png" alt="不同层次的抽象"></p><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210130190629696.png" alt="数据模型与概念模型"></p><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210130191305331.png" alt="分层级抽象"></p><h2 id="建模的不同层次：模型与元模型，模型（型）与实例（值）"><a href="#建模的不同层次：模型与元模型，模型（型）与实例（值）" class="headerlink" title="建模的不同层次：模型与元模型，模型（型）与实例（值）"></a>建模的不同层次：模型与元模型，模型（型）与实例（值）</h2><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210131094716351.png" alt="建模层次"></p><h2 id="IDEF1x"><a href="#IDEF1x" class="headerlink" title="IDEF1x"></a>IDEF1x</h2><h4 id="实体-1"><a href="#实体-1" class="headerlink" title="实体"></a>实体</h4><p>实体表示现实和抽象事物的集合，这些事物必须具有相同的属性和特征。这个集合的一个元素就是该实体的一个实例</p><ul><li>实体分为独立实体和从属实体</li><li>在扩展E-R图中，<strong>独立实体</strong>又称为强实体，<strong>从属实体</strong>又称弱实体</li></ul><p>独立实体：一个实体的实例都被唯一的标识而不决定与它与其他实体的联系</p><p>从属实体：一个实体的实例唯一标识需要依赖于该实体与其他实体之间的联系</p><p>从属实体需要从其他实体继承属性作为关键字的一部分</p><h3 id="关于实体的规则"><a href="#关于实体的规则" class="headerlink" title="关于实体的规则"></a>关于实体的规则</h3><p>关于实体的规则：工程化要求</p><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210131103736957.png" alt="实体规则"></p><h3 id="标定联系与非标定联系"><a href="#标定联系与非标定联系" class="headerlink" title="标定联系与非标定联系"></a>标定联系与非标定联系</h3><p>子实体的实例能够被唯一标识而无需依赖与其实体的联系，父实体的主关键字不视子实体的主关键字</p><p><img src="/2022/01/18/12%E3%80%80%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20210131110031592.png" alt="image-20210131110031592"></p><h3 id="分类联系"><a href="#分类联系" class="headerlink" title="分类联系"></a>分类联系</h3><p>分类联系：一个实体实例是由一个一般实体实例及多个分类实体实例构成的</p><ul><li>一个一般实体是若干具体实体（分类实体）的类</li><li>分类实体与一般实体具有相同的主关键字</li><li>不同分类实体除具有一啊不能是实体特征外，各自还可能具有不同的属性特征</li></ul><h3 id="具体化"><a href="#具体化" class="headerlink" title="具体化"></a>具体化</h3><p>实体的实例集中，某些实例子集具有区别于该实例集内其他实例的特性，可以根据这些差异特性对该实例进行分组，这一分组的过程称为具体化</p><p>自顶向下，逐步求精</p><h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><p>若干个实体根据共有的性质，可以合成一个较高层的实体</p><p><strong>泛化和具体化在E-R图中用标记为ISa的三角形标识</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据建模与数据库设计&quot;&gt;&lt;a href=&quot;#数据建模与数据库设计&quot; class=&quot;headerlink&quot; title=&quot;数据建模与数据库设计&quot;&gt;&lt;/a&gt;数据建模与数据库设计&lt;/h1&gt;&lt;h2 id=&quot;数据模型与概念模型&quot;&gt;&lt;a href=&quot;#数据模型与概念模型&quot; class=&quot;headerlink&quot; title=&quot;数据模型与概念模型&quot;&gt;&lt;/a&gt;数据模型与概念模型&lt;/h2&gt;&lt;p&gt;表达计算机世界的模型乘坐数据模型；表达信息世界的模型称为该奶奶数据模型，简称概念模型，信息世界是对现实世界的理解与抽象&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>依赖关系</title>
    <link href="http://yokeso.github.io/2022/01/18/13%20%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"/>
    <id>http://yokeso.github.io/2022/01/18/13%20%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:14:55.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>函数依赖的定义：设R(U)是属性集合</p><script type="math/tex; mode=display">U=\{A_1,A_2...A_n\}</script><p>上的一个关系模式，X，Y是U上两个子集，若对R(U)的任意一个可能的关系r，r中不可能有两个元组满足在X中的属性值相等而在Y中的属性值不等，则称“X函数决定Y”或“Y函数依赖于X”记作X-&gt;Y </p><span id="more"></span><h3 id="函数依赖的特性"><a href="#函数依赖的特性" class="headerlink" title="函数依赖的特性"></a>函数依赖的特性</h3><p><img src="/2022/01/18/13%20%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image-20210202151717689.png" alt></p><h3 id="完全函数依赖与传递函数依赖"><a href="#完全函数依赖与传递函数依赖" class="headerlink" title="完全函数依赖与传递函数依赖"></a>完全函数依赖与传递函数依赖</h3><p><img src="/2022/01/18/13%20%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image-20210202155400640.png" alt="image-20210202155400640"></p><p><img src="/2022/01/18/13%20%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image-20210202155942263.png" alt="image-20210202155942263"></p><h3 id="函数相关的几个重要概念"><a href="#函数相关的几个重要概念" class="headerlink" title="函数相关的几个重要概念"></a>函数相关的几个重要概念</h3><p>候选键</p><p><img src="/2022/01/18/13%20%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image-20210202160300991.png" alt="image-20210202160300991"></p><p>外来键</p><p><img src="/2022/01/18/13%20%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image-20210202160436387.png" alt="image-20210202160436387"></p><p>闭包</p><p>被F逻辑蕴含的所有函数依赖的集合称为F的闭包，记作F’</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;依赖关系&quot;&gt;&lt;a href=&quot;#依赖关系&quot; class=&quot;headerlink&quot; title=&quot;依赖关系&quot;&gt;&lt;/a&gt;依赖关系&lt;/h1&gt;&lt;h2 id=&quot;函数依赖&quot;&gt;&lt;a href=&quot;#函数依赖&quot; class=&quot;headerlink&quot; title=&quot;函数依赖&quot;&gt;&lt;/a&gt;函数依赖&lt;/h2&gt;&lt;p&gt;函数依赖的定义：设R(U)是属性集合&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
U=\{A_1,A_2...A_n\}&lt;/script&gt;&lt;p&gt;上的一个关系模式，X，Y是U上两个子集，若对R(U)的任意一个可能的关系r，r中不可能有两个元组满足在X中的属性值相等而在Y中的属性值不等，则称“X函数决定Y”或“Y函数依赖于X”记作X-&amp;gt;Y &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库模型</title>
    <link href="http://yokeso.github.io/2022/01/18/2.%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yokeso.github.io/2022/01/18/2.%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:08:15.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-关系数据库模型"><a href="#2-关系数据库模型" class="headerlink" title="[2] 关系数据库模型"></a>[2] 关系数据库模型</h1><h2 id="2-1什么是关系"><a href="#2-1什么是关系" class="headerlink" title="2.1什么是关系"></a>2.1什么是关系</h2><h3 id="1-什么是表"><a href="#1-什么是表" class="headerlink" title="1.什么是表"></a>1.什么是表</h3><span id="more"></span><p><img src="/2022/01/18/2.%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9E%8B/image-20210118152305959.png" alt="image-20210118152305959" style="zoom:50%;"></p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>域：列的取值范围，是一组值的集合，这组值具有相同的数据类型</p><ul><li>如：整数的集合，字符串的集合</li><li>集合中的元素的个数叫做域的<strong>基数</strong></li></ul><h3 id="笛卡儿积"><a href="#笛卡儿积" class="headerlink" title="笛卡儿积"></a>笛卡儿积</h3><ul><li><p>一组域D1，D2…Dn的笛卡尔积的笛卡尔积为：</p><script type="math/tex; mode=display">D_1\times D_2\times.....\times D_n=\{ (d_1,d_2,....,d_n)|d_i\in D_i,i=1,....n\}</script></li><li><p>笛卡尔积的每个元素$(d_1,d_2,….d_n)$称作一个n-元组</p></li><li><p>元组$(d_1,d_2,….d_n)$的每一个值$d_i$叫做一个分量</p></li><li>元组$(d_1,d_2,….d_n)$是从每个域任取一个值形成的组合，笛卡尔积是所有这种可能组合的集合，即笛卡儿积是由n个域形成的所有可能的n-元组的集合</li><li>若$D_i$的奇数为$m_i$则笛卡尔积的奇数即元组个数即为：$m_1 \times m_2 \times… \times m_n$</li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>关系：一组域D1，D2…Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的元组被称为一个关系</p><ul><li>理论上，关系的任两个元组不能完全相同，现实应用中，表(Table)可能并不完全遵守此特性</li><li>关系可用$R(A_1:D_1,A_2:D_2,….A_n:D_n,)$表示，可简记为$R(A_1,A_2,….A_n,)$,这种描述又称为<strong>关系模式</strong>或表标题<ul><li>其中R是关系的名字，$A_i$是属性，$D_i$是属性对应的域，n是关系的<strong>度</strong>或<strong>目</strong>，关系中的元组的数目称为关系的<strong>基数</strong></li></ul></li></ul><h5 id="关系的特性："><a href="#关系的特性：" class="headerlink" title="关系的特性："></a>关系的特性：</h5><ul><li>每一列中的分量来自同一域，是同一类型的数据</li><li>不同的列可以来自同一个域，其中的每一个列为一个属性，不同的属性要基于不同的属性名</li><li>行列的互换性（区分不是靠位置而是靠值）</li><li>理论上关系的任意两个元组不能完全相同</li><li>关系第一范式：属性不可再分</li></ul><h3 id="候选键（candidate-key-）"><a href="#候选键（candidate-key-）" class="headerlink" title="候选键（candidate key ）"></a>候选键（candidate key ）</h3><ul><li><p>一个<strong>属性组</strong>， 其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具备这一性质了，这样的属性组称为<strong>候选键</strong></p></li><li><p>有时关系中有很多组候选码</p></li></ul><h3 id="主键（primany-key）"><a href="#主键（primany-key）" class="headerlink" title="主键（primany key）"></a>主键（primany key）</h3><p>有多个候选码时，可以选一个作为主码/主键</p><p>DBMS以主码为主要线索管理关系中的各个元组</p><h3 id="主属性与非主属性"><a href="#主属性与非主属性" class="headerlink" title="主属性与非主属性"></a>主属性与非主属性</h3><p>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><ul><li><p>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选 码相对应，则称这个属性组为R的外码或外键</p></li><li><p>两个关系是靠外码连接起来的</p></li></ul><h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><p><strong>实体完整性</strong></p><ul><li>关系中主码的属性值不能为空（空值：不知道或无意义的值）</li><li>其他情况下存在空值需要特殊处理，需要特别注意</li></ul><p><strong>参照完整性</strong></p><ul><li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的 Fk值或者等于R2 中某个元组的Pk 值， 或者为空值</li></ul><p><strong>用户自定义完整性</strong></p><ul><li>如S#要求是10位整数</li><li>性别只能是男/女</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2-关系数据库模型&quot;&gt;&lt;a href=&quot;#2-关系数据库模型&quot; class=&quot;headerlink&quot; title=&quot;[2] 关系数据库模型&quot;&gt;&lt;/a&gt;[2] 关系数据库模型&lt;/h1&gt;&lt;h2 id=&quot;2-1什么是关系&quot;&gt;&lt;a href=&quot;#2-1什么是关系&quot; class=&quot;headerlink&quot; title=&quot;2.1什么是关系&quot;&gt;&lt;/a&gt;2.1什么是关系&lt;/h2&gt;&lt;h3 id=&quot;1-什么是表&quot;&gt;&lt;a href=&quot;#1-什么是表&quot; class=&quot;headerlink&quot; title=&quot;1.什么是表&quot;&gt;&lt;/a&gt;1.什么是表&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yokeso.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>模式分解存在的问题</title>
    <link href="http://yokeso.github.io/2022/01/18/15%20%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yokeso.github.io/2022/01/18/15%20%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-18T02:22:28.000Z</published>
    <updated>2023-05-16T16:15:02.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模式分解存在的问题"><a href="#模式分解存在的问题" class="headerlink" title="模式分解存在的问题"></a>模式分解存在的问题</h1><h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><p>模式分解是指用R的一组子集来替代这个关系</p><span id="more"></span><h3 id="投影链接"><a href="#投影链接" class="headerlink" title="投影链接"></a>投影链接</h3><p><img src="/2022/01/18/15%20%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/image-20210203113352039.png" alt="image-20210203113352039"></p><p>模式分解需要关注：</p><p>R与p在数据内容方面是否等价：分解的无损连接性</p><p>R与p在数据依赖方面是否等价：分解的保持依赖性</p><p><img src="/2022/01/18/15%20%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/image-20210203114626676.png" alt="image-20210203114626676"></p><h2 id="无损链接分解"><a href="#无损链接分解" class="headerlink" title="无损链接分解"></a>无损链接分解</h2><p>对于关系模式R(U,F),U是全局属性，F是函数依赖集合，$p={R_1,…,R_k}$是R 的一个分解，如果对于R的任何满足函数依赖集F的关系r，有</p><script type="math/tex; mode=display">r=m_\rho(r)</script><p>则称$\rho$是R相对于F的一个无损链接分解，其中</p><p><img src="/2022/01/18/15%20%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/image-20210203120557755.png" alt="image-20210203120557755"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模式分解存在的问题&quot;&gt;&lt;a href=&quot;#模式分解存在的问题&quot; class=&quot;headerlink&quot; title=&quot;模式分解存在的问题&quot;&gt;&lt;/a&gt;模式分解存在的问题&lt;/h1&gt;&lt;h2 id=&quot;模式分解&quot;&gt;&lt;a href=&quot;#模式分解&quot; class=&quot;headerlink&quot; title=&quot;模式分解&quot;&gt;&lt;/a&gt;模式分解&lt;/h2&gt;&lt;p&gt;模式分解是指用R的一组子集来替代这个关系&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yokeso.github.io/2021/03/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yokeso.github.io/2021/03/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-03-20T13:17:36.000Z</published>
    <updated>2021-04-10T14:20:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式是一种文本模式，能够便捷高效的处理文本，赋予使用者描述和分析文本的能力。正则表达式能够添加，删除，分离，叠加、插入和修整各种类型的文本和数据。</p><p>正则表达式由两种字符构成：特殊字符（元字符），以及普通文本。究其根本，正则表达式就是通过符号上的表述去匹配一个字符串的通式，处于4NF的内部。</p><span id="more"></span><p>乍一眼看上去正则表达式很难，找不到头绪，但实际上正则表达式很简单，我更喜欢把他看作是一种变形的数学公式。在具有公式（规则）后通过几种解题方法就能轻松的进行解题（匹配字符串）我们只需要掌握它的规则和用法就可以了。</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li>表达式全集</li><li>常用正则表达式</li><li>常用函数</li><li>示例代码</li></ul><hr><h4 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h4><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td style="text-align:center">将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“<code>n</code>”匹配字符“<code>n</code>”。“<code>\n</code>”匹配一个换行符。串行“<code>\\</code>”匹配“<code>\</code>”而“<code>\(</code>”则匹配“<code>(</code>”。</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“<code>\n</code>”或“<code>\r</code>”之后的位置。</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“<code>\n</code>”或“<code>\r</code>”之前的位置。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配前面的子表达式零次或多次。例如，zo<em>能匹配“<code>z</code>”以及“<code>zoo</code>”。</em>等价于{0,}。</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。+等价于{1,}。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配前面的子表达式零次或一次。例如，“<code>do(es)?</code>”可以匹配“<code>does</code>”或“<code>does</code>”中的“<code>do</code>”。?等价于{0,1}。</td></tr><tr><td style="text-align:center">{<em>n</em>}</td><td style="text-align:center"><em>n</em>是一个非负整数。匹配确定的<em>n</em>次。例如，“<code>o&#123;2&#125;</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但是能匹配“<code>food</code>”中的两个o。</td></tr><tr><td style="text-align:center">{<em>n</em>,}</td><td style="text-align:center"><em>n</em>是一个非负整数。至少匹配<em>n</em>次。例如，“<code>o&#123;2,&#125;</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但能匹配“<code>foooood</code>”中的所有o。“<code>o&#123;1,&#125;</code>”等价于“<code>o+</code>”。“<code>o&#123;0,&#125;</code>”则等价于“<code>o*</code>”。</td></tr><tr><td style="text-align:center">{<em>n</em>,<em>m</em>}</td><td style="text-align:center"><em>m</em>和<em>n</em>均为非负整数，其中<em>n</em>&lt;=<em>m</em>。最少匹配<em>n</em>次且最多匹配<em>m</em>次。例如，“<code>o&#123;1,3&#125;</code>”将匹配“<code>fooooood</code>”中的前三个o。“<code>o&#123;0,1&#125;</code>”等价于“<code>o?</code>”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">当该字符紧跟在任何一个其他限制符（<em>,+,?，{</em>n<em>}，{</em>n<em>,}，{</em>n<em>,</em>m*}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”。</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除“<code>\</code><em><code>n</code></em>”之外的任何单个字符。要匹配包括“<code>\</code><em><code>n</code></em>”在内的任何字符，请使用像“`(.</td><td>\n)`”的模式。</td></tr><tr><td style="text-align:center">(pattern)</td><td style="text-align:center">匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<code>\(</code>”或“<code>\)</code>”。</td></tr><tr><td style="text-align:center">(?:pattern)</td><td style="text-align:center">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td><td>)<code>”来组合一个模式的各个部分是很有用。例如“</code>industr(?:y</td><td>ies)<code>”就是一个比“</code>industry</td><td>industries`”更简略的表达式。</td></tr><tr><td style="text-align:center">(?=pattern)</td><td style="text-align:center">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td><td>98</td><td>NT</td><td>2000)<code>”能匹配“</code>Windows2000<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows3.1<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td style="text-align:center">(?!pattern)</td><td style="text-align:center">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td><td>98</td><td>NT</td><td>2000)<code>”能匹配“</code>Windows3.1<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows2000<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td></tr><tr><td style="text-align:center">(?&lt;=pattern)</td><td style="text-align:center">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td><td>98</td><td>NT</td><td>2000)Windows<code>”能匹配“</code>2000Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>3.1Windows<code>”中的“</code>Windows`”。</td></tr><tr><td style="text-align:center">(?&lt;!pattern)</td><td style="text-align:center">反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td><td>98</td><td>NT</td><td>2000)Windows<code>”能匹配“</code>3.1Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>2000Windows<code>”中的“</code>Windows`”。</td></tr><tr><td style="text-align:center">x\</td><td style="text-align:center">y</td><td>匹配x或y。例如，“`z</td><td>food<code>”能匹配“</code>z<code>”或“</code>food<code>”。“</code>(z</td><td>f)ood<code>”则匹配“</code>zood<code>”或“</code>food`”。</td></tr><tr><td style="text-align:center">[xyz]</td><td style="text-align:center">字符集合。匹配所包含的任意一个字符。例如，“<code>[abc]</code>”可以匹配“<code>plain</code>”中的“<code>a</code>”。</td></tr><tr><td style="text-align:center"><sup><a href="#fn_xyz" id="reffn_xyz">xyz</a></sup></td><td style="text-align:center">负值字符集合。匹配未包含的任意字符。例如，“<code>[^abc]</code>”可以匹配“<code>plain</code>”中的“<code>p</code>”。</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:center">字符范围。匹配指定范围内的任意字符。例如，“<code>[a-z]</code>”可以匹配“<code>a</code>”到“<code>z</code>”范围内的任意小写字母字符。</td></tr><tr><td style="text-align:center"><sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup></td><td style="text-align:center">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<code>[^a-z]</code>”可以匹配任何不在“<code>a</code>”到“<code>z</code>”范围内的任意字符。</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">匹配非单词边界。“<code>er\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td></tr><tr><td style="text-align:center">\cx</td><td style="text-align:center">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配一个数字字符。等价于[0-9]。</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配一个非数字字符。等价于<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup>。</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任何非空白字符。等价于<sup><a href="#fn_ \f\n\r\t\v" id="reffn_ \f\n\r\t\v"> \f\n\r\t\v</a></sup>。</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:center">匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配包括下划线的任何单词字符。等价于“<code>[A-Za-z0-9_]</code>”。</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9_]</code>”。</td></tr><tr><td style="text-align:center">\x<em>n</em></td><td style="text-align:center">匹配<em>n</em>，其中<em>n</em>为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td></tr><tr><td style="text-align:center">*num*</td><td style="text-align:center">匹配<em>num</em>，其中<em>num</em>是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\1</code>”匹配两个连续的相同字符。</td></tr><tr><td style="text-align:center">*n*</td><td style="text-align:center">标识一个八进制转义值或一个向后引用。如果*n<em>之前至少</em>n<em>个获取的子表达式，则</em>n<em>为向后引用。否则，如果</em>n<em>为八进制数字（0-7），则</em>n*为一个八进制转义值。</td></tr><tr><td style="text-align:center">*nm*</td><td style="text-align:center">标识一个八进制转义值或一个向后引用。如果*nm<em>之前至少有</em>nm<em>个获得子表达式，则</em>nm<em>为向后引用。如果\</em>nm<em>之前至少有</em>n<em>个获取，则</em>n<em>为一个后跟文字</em>m<em>的向后引用。如果前面的条件都不满足，若</em>n<em>和</em>m<em>均为八进制数字（0-7），则\</em>nm<em>将匹配八进制转义值</em>nm*。</td></tr><tr><td style="text-align:center">*nml*</td><td style="text-align:center">如果<em>n</em>为八进制数字（0-3），且<em>m和l</em>均为八进制数字（0-7），则匹配八进制转义值<em>nm</em>l。</td></tr><tr><td style="text-align:center">\u<em>n</em></td><td style="text-align:center">匹配<em>n</em>，其中<em>n</em>是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td></tr></tbody></table></div><h4 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h4><div class="table-container"><table><thead><tr><th style="text-align:center">用户名</th><th>/^[a-z0-9_-]{3,16}$/</th></tr></thead><tbody><tr><td style="text-align:center">密码</td><td>/^[a-z0-9_-]{6,18}$/</td></tr><tr><td style="text-align:center">十六进制值</td><td>/^#?([a-f0-9]{6}\</td><td>[a-f0-9]{3})$/</td></tr><tr><td style="text-align:center">电子邮箱</td><td>/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/ /^[a-z\d]+(.[a-z\d]+)*@(<a href="-[\da-z]">\da-z</a>?)+(.{1,2}[a-z]+)+$/</td></tr><tr><td style="text-align:center">URL</td><td>/^(https?:\/\/)?([\da-z.-]+).([a-z.]{2,6})([\/\w .-]<em>)</em>\/?$/</td></tr><tr><td style="text-align:center">IP 地址</td><td>/((2[0-4]\d\</td><td>25[0-5]\</td><td>[01]?\d\d?).){3}(2[0-4]\d\</td><td>25[0-5]\</td><td>[01]?\d\d?)/ /^(?:(?:25[0-5]\</td><td>2[0-4][0-9]\</td><td>[01]?[0-9][0-9]?).){3}(?:25[0-5]\</td><td>2[0-4][0-9]\</td><td>[01]?[0-9][0-9]?)$/</td></tr><tr><td style="text-align:center">HTML 标签</td><td>/^&lt;([a-z]+)(<sup><a href="#fn_<" id="reffn_<"><</a></sup>+)<em>(?:&gt;(.</em>)&lt;\/\1&gt;\</td><td>\s+\/&gt;)$/</td></tr><tr><td style="text-align:center">删除代码\注释</td><td>(?&lt;!http:\</td><td>\S)//.*$</td></tr><tr><td style="text-align:center">Unicode编码中的汉字范围</td><td>/^[\u2E80-\u9FFF]+$/</td></tr></tbody></table></div><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h6 id="正则表达式的构建"><a href="#正则表达式的构建" class="headerlink" title="正则表达式的构建"></a>正则表达式的构建</h6><p>regex这个库是需要std命名空间支持的，在下面我会省略std命名空间，但需要注意这点。</p><p>正则表达式的构建有两种方法，我把他们叫做直接构建和赋值构建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接构建</span></span><br><span class="line"><span class="function">regex <span class="title">e</span><span class="params">(<span class="string">&quot;(sub)(.*)&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//赋值构建</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;(sub)(.*)&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">rule</span><span class="params">(str)</span></span>;</span><br></pre></td></tr></table></figure><p>注意正则表达式一定要在构建后才可以进行字符串的匹配</p><h6 id="字符串匹配函数"><a href="#字符串匹配函数" class="headerlink" title="字符串匹配函数"></a>字符串匹配函数</h6><p>字符串匹配使用<code>regex_match()</code>函数，函数的返回值为bool，即是否匹配，函数有几种形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> cstr[] = <span class="string">&quot;subject&quot;</span></span><br><span class="line"><span class="built_in">string</span> str (<span class="string">&quot;subject&quot;</span>);</span><br><span class="line"><span class="function">regex <span class="title">rule</span> <span class="params">(<span class="string">&quot;(sub)(.*)&quot;</span>)</span></span>;</span><br><span class="line">cmatch cm;</span><br><span class="line">smatch sm;</span><br><span class="line"><span class="comment">//以下函数原型都是自己整理，并非模板中的函数原型，仅作为方便学习使用</span></span><br><span class="line">regex_match(str,rule);   <span class="comment">//字符串和规则 返回是否匹配</span></span><br><span class="line">regex_match(str.begin(),str.end(),e); <span class="comment">//匹配某一范围字符</span></span><br><span class="line">regex_match(cstr,cm,e); <span class="comment">//cm.size()返回匹配字符长度</span></span><br><span class="line">regex_match(str,sm,e);  <span class="comment">//sm.size()返回匹配字符长度</span></span><br><span class="line"></span><br><span class="line">regex_match ( cstr, cm, e, <span class="built_in">std</span>::regex_constants::match_default );<span class="comment">//返回匹配的每个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the matches were: &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;cm.size(); ++i) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; cm[i] &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串搜索函数"><a href="#字符串搜索函数" class="headerlink" title="字符串搜索函数"></a>字符串搜索函数</h6><p>字符串搜索函数使用<code>regex_search</code>函数，函数的返回值为bool</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::regex_search (s,m,e)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x:m) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  s = m.suffix().str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串替换函数"><a href="#字符串替换函数" class="headerlink" title="字符串替换函数"></a>字符串替换函数</h6><p>字符串替换使用<code>regex_rlace()</code>函数，函数返回修改后的字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regex_replace (str,rule,<span class="string">&quot;sub-$2&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> re = <span class="string">&quot;[[:graph:]]+@163[.]com&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">rule</span><span class="params">(re)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;acvds.cpp@163.com&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; regex_match(str, rule) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//true</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;正则表达式是一种文本模式，能够便捷高效的处理文本，赋予使用者描述和分析文本的能力。正则表达式能够添加，删除，分离，叠加、插入和修整各种类型的文本和数据。&lt;/p&gt;
&lt;p&gt;正则表达式由两种字符构成：特殊字符（元字符），以及普通文本。究其根本，正则表达式就是通过符号上的表述去匹配一个字符串的通式，处于4NF的内部。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ccf" scheme="http://yokeso.github.io/tags/ccf/"/>
    
      <category term="正则表达式" scheme="http://yokeso.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="字符串处理" scheme="http://yokeso.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
